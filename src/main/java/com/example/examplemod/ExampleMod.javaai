   1: package com.example.examplemod;
   2: 
   3: import com.sun.net.httpserver.Headers;
   4: import com.sun.net.httpserver.HttpExchange;
   5: import com.sun.net.httpserver.HttpServer;
   6: import io.netty.buffer.Unpooled;
   7: import net.minecraft.block.Block;
   8: import net.minecraft.block.BlockPistonBase;
   9: import net.minecraft.block.BlockShulkerBox;
  10: import net.minecraft.block.state.IBlockState;
  11: import net.minecraft.client.Minecraft;
  12: import net.minecraft.client.gui.GuiChat;
  13: import net.minecraft.client.gui.GuiDisconnected;
  14: import net.minecraft.client.gui.GuiScreen;
  15: import net.minecraft.client.gui.GuiTextField;
  16: import net.minecraft.client.gui.Gui;
  17: import net.minecraft.client.gui.inventory.GuiChest;
  18: import net.minecraft.client.gui.inventory.GuiContainer;
  19: import net.minecraft.client.gui.inventory.GuiInventory;
  20: import net.minecraft.client.gui.inventory.GuiShulkerBox;
  21: import net.minecraft.client.gui.ScaledResolution;
  22: import net.minecraft.client.network.NetworkPlayerInfo;
  23: import net.minecraft.client.renderer.GlStateManager;
  24: import net.minecraft.client.renderer.RenderHelper;
  25: import net.minecraft.client.renderer.Tessellator;
  26: import net.minecraft.client.renderer.BufferBuilder;
  27: import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
  28: import net.minecraft.client.renderer.texture.TextureManager;
  29: import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
  30: import net.minecraft.client.settings.KeyBinding;
  31: import net.minecraft.client.shader.Framebuffer;
  32: import net.minecraft.command.ICommandSender;
  33: import net.minecraft.command.CommandBase;
  34: import net.minecraft.entity.player.EntityPlayer;
  35: import net.minecraft.entity.player.EntityPlayerMP;
  36: import net.minecraft.init.Blocks;
  37: import net.minecraft.init.Items;
  38: import net.minecraft.inventory.ClickType;
  39: import net.minecraft.inventory.Container;
  40: import net.minecraft.inventory.IInventory;
  41: import net.minecraft.inventory.InventoryBasic;
  42: import net.minecraft.inventory.Slot;
  43: import net.minecraft.item.Item;
  44: import net.minecraft.item.ItemStack;
  45: import net.minecraft.item.EnumDyeColor;
  46: import net.minecraft.scoreboard.Score;
  47: import net.minecraft.scoreboard.ScoreObjective;
  48: import net.minecraft.scoreboard.ScorePlayerTeam;
  49: import net.minecraft.scoreboard.Scoreboard;
  50: import net.minecraft.nbt.NBTTagCompound;
  51: import net.minecraft.nbt.NBTTagList;
  52: import net.minecraft.nbt.NBTTagString;
  53: import net.minecraft.nbt.CompressedStreamTools;
  54: import net.minecraft.network.PacketBuffer;
  55: import net.minecraft.network.play.client.CPacketCreativeInventoryAction;
  56: import net.minecraft.network.play.client.CPacketCustomPayload;
  57: import net.minecraft.server.MinecraftServer;
  58: import net.minecraft.tileentity.TileEntity;
  59: import net.minecraft.tileentity.TileEntityChest;
  60: import net.minecraft.tileentity.TileEntityShulkerBox;
  61: import net.minecraft.tileentity.TileEntitySign;
  62: import net.minecraft.util.ResourceLocation;
  63: import net.minecraft.util.EnumFacing;
  64: import net.minecraft.util.EnumHand;
  65: import net.minecraft.util.math.BlockPos;
  66: import net.minecraft.util.math.Vec3d;
  67: import net.minecraft.util.text.TextComponentString;
  68: import net.minecraft.util.text.TextFormatting;
  69: import net.minecraft.world.GameType;
  70: import net.minecraft.world.World;
  71: import net.minecraftforge.client.ClientCommandHandler;
  72: import net.minecraftforge.client.event.ClientChatEvent;
  73: import net.minecraftforge.client.event.ClientChatReceivedEvent;
  74: import net.minecraftforge.client.event.GuiOpenEvent;
  75: import net.minecraftforge.client.event.GuiScreenEvent;
  76: import net.minecraftforge.client.event.RenderGameOverlayEvent;
  77: import net.minecraftforge.client.event.RenderWorldLastEvent;
  78: import net.minecraftforge.common.MinecraftForge;
  79: import net.minecraftforge.common.config.Configuration;
  80: import net.minecraftforge.fml.client.event.ConfigChangedEvent;
  81: import net.minecraftforge.event.ServerChatEvent;
  82: import net.minecraftforge.event.entity.player.PlayerInteractEvent;
  83: import net.minecraftforge.fml.common.Mod;
  84: import net.minecraftforge.fml.common.Mod.EventHandler;
  85: import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
  86: import net.minecraftforge.fml.common.event.FMLInitializationEvent;
  87: import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
  88: import net.minecraftforge.fml.common.event.FMLServerStartingEvent;
  89: import net.minecraftforge.fml.common.event.FMLServerStoppingEvent;
  90: import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
  91: import net.minecraftforge.fml.common.gameevent.TickEvent;
  92: import net.minecraftforge.fml.client.registry.ClientRegistry;
  93: import org.apache.logging.log4j.Logger;
  94: import org.lwjgl.input.Keyboard;
  95: import org.lwjgl.input.Mouse;
  96: import org.lwjgl.opengl.GL11;
  97: 
  98: import java.io.IOException;
  99: import java.io.InputStream;
 100: import java.io.OutputStream;
 101: import java.io.BufferedReader;
 102: import java.io.BufferedWriter;
 103: import java.io.File;
 104: import java.io.FileInputStream;
 105: import java.io.FileOutputStream;
 106: import java.io.InputStreamReader;
 107: import java.io.OutputStreamWriter;
 108: import java.lang.reflect.Method;
 109: import java.net.BindException;
 110: import java.net.HttpURLConnection;
 111: import java.net.InetSocketAddress;
 112: import java.net.URL;
 113: import java.net.URLDecoder;
 114: import java.nio.charset.StandardCharsets;
 115: import java.util.ArrayDeque;
 116: import java.util.ArrayList;
 117: import java.util.Collections;
 118: import java.util.Collection;
 119: import java.util.Deque;
 120: import java.util.HashMap;
 121: import java.util.HashSet;
 122: import java.util.LinkedHashMap;
 123: import java.util.LinkedHashSet;
 124: import java.util.List;
 125: import java.util.Locale;
 126: import java.util.Map;
 127: import java.util.Set;
 128: import java.util.concurrent.ConcurrentHashMap;
 129: import java.util.concurrent.ExecutorService;
 130: import java.util.concurrent.Executors;
 131: import java.util.concurrent.ScheduledExecutorService;
 132: import java.util.concurrent.ThreadFactory;
 133: import java.util.concurrent.atomic.AtomicBoolean;
 134: import java.util.concurrent.TimeUnit;
 135: 
 136: @Mod(modid = ExampleMod.MODID, name = ExampleMod.NAME, version = ExampleMod.VERSION,
 137:     guiFactory = "com.example.examplemod.ModGuiFactory")
 138: public class ExampleMod
 139: {
 140:     public static final String MODID = "bettercode";
 141:     public static final String NAME = "Creative+ BetterCode";
 142:     public static final String VERSION = "1.0.0";
 143:     private static final int BASE_PORT = 8765;
 144:     private static final int MAX_PORT = 8790;
 145:     private static final long REGISTRY_TTL_MS = 15000L;
 146:     private static final long REGISTRY_HEARTBEAT_MS = 5000L;
 147:     private static final long BAR_DEFAULT_MS = 3000L;
 148:     private static final long CLIENT_CHAT_COOLDOWN_MS = 700L;
 149:     private static final long HOTBAR_DOUBLE_TAP_MS = 250L;
 150:     private static final long MENU_CACHE_ARM_MS = 5000L;
 151:     private static final String CODE_MENU_TITLE = "Code Menu";
 152:     private static final int INPUT_MODE_TEXT = 0;
 153:     private static final int INPUT_MODE_NUMBER = 1;
 154:     private static final int INPUT_MODE_VARIABLE = 2;
 155:     private static final int INPUT_MODE_ARRAY = 3;
 156:     private static final int INPUT_MODE_LOCATION = 4;
 157:     private static final int INPUT_CONTEXT_SLOT = 0;
 158:     private static final int INPUT_CONTEXT_GIVE = 1;
 159:     private static final int ENTRY_RECENT_LIMIT = 10;
 160:     private static final int ENTRY_FREQUENT_MIN = 3;
 161:     private static final String ARRAY_MARK = "\u2398";
 162:     private static final int MENU_CACHE_MAX = 48;
 163:     private static final int ENTRY_COUNT_MAX = 300;
 164:     private static final long EDITOR_MODE_GRACE_MS = 30000L;
 165:     private static final int CHEST_CACHE_MAX = 256;
 166:     private static final int CHEST_SNAPSHOT_TICK_INTERVAL = 5;
 167:     private static final double CHEST_PREVIEW_RANGE = 15.0;
 168:     private static final String EDIT_TEST_MARKER = "edit_test_ok";
 169:     private static final String HOLO_LABEL = "DIRT";
 170:     private static final String CHEST_HOLO_LABEL = "Chest";
 171:     private static final int CHEST_HOLO_TEX_SIZE = 1024;
 172:     private static final int CHEST_HOLO_TEXT_WIDTH = 40;
 173:     private static final float CHEST_HOLO_SCALE = 0.0118F;
 174:     private static final String[] ENTITY_BUTTON_LABELS = new String[]
 175:     {
 176:         "selected", "player", "default", "entity", "damager",
 177:         "victim", "selection", "random", "shooter"
 178:     };
 179: 
 180:     private static Logger logger;
 181:     private static Configuration config;
 182:     private static boolean enableSecondHotbar = true;
 183:     private static volatile String lastChatMessage = "";
 184:     private static volatile String lastChatPlayer = "";
 185:     private static volatile long lastChatTimeMs = 0L;
 186:     private static volatile long lastApiChatSentMs = 0L;
 187:     private static volatile String cachedServerPlayersJson = "{\"count\":0,\"players\":[]}";
 188:     private static volatile String cachedClientTabJson = "{\"count\":0,\"players\":[]}";
 189:     private static volatile String cachedServerCoordsJson = "{\"count\":0,\"players\":[]}";
 190:     private static volatile String cachedClientCoordsJson = "{\"count\":0,\"players\":[]}";
 191:     private HttpServer httpServer;
 192:     private HttpServer registryServer;
 193:     private MinecraftServer mcServer;
 194:     private int apiPort = -1;
 195:     private boolean registryEnabled = false;
 196:     private final Map<String, RegistryEntry> registryEntries = new ConcurrentHashMap<>();
 197:     private ScheduledExecutorService registryHeartbeat;
 198:     private static volatile String actionBarText = "";
 199:     private static volatile String actionBar2Text = "";
 200:     private static volatile long actionBarExpireMs = 0L;
 201:     private static volatile long actionBar2ExpireMs = 0L;
 202:     private final ItemStack[][] hotbarSets = new ItemStack[2][9];
 203:     private final long[] lastHotbarTapMs = new long[9];
 204:     private final boolean[] hotbarKeyDown = new boolean[9];
 205:     private int activeHotbarSet = 0;
 206:     private World lastWorldRef = null;
 207:     private boolean inputActive = false;
 208:     private boolean inputSaveVariable = false;
 209:     private GuiTextField inputField;
 210:     private boolean inputRepeatEnabled = false;
 211:     private int inputTargetWindowId = -1;
 212:     private int inputTargetSlotNumber = -1;
 213:     private String inputTitle = "";
 214:     private int inputMode = INPUT_MODE_TEXT;
 215:     private int inputContext = INPUT_CONTEXT_SLOT;
 216:     private ItemStack inputSlotTemplate = ItemStack.EMPTY;
 217:     private ItemStack inputGiveTemplate = ItemStack.EMPTY;
 218:     private final Map<String, List<InputEntry>> recentEntriesById = new HashMap<>();
 219:     private final Map<String, Map<String, Integer>> entryCountsById = new HashMap<>();
 220:     private final Set<String> savedVariableNames = new HashSet<>();
 221:     private boolean typePickerActive = false;
 222:     private int typePickerWindowId = -1;
 223:     private int typePickerSlotNumber = -1;
 224:     private int quickApplyWindowId = -1;
 225:     private int quickApplySlotNumber = -1;
 226:     private Method getSlotUnderMouseMethod;
 227:     private final Map<String, CachedMenu> menuCache = new LinkedHashMap<String, CachedMenu>(16, 0.75f, true)
 228:     {
 229:         @Override
 230:         protected boolean removeEldestEntry(Map.Entry<String, CachedMenu> eldest)
 231:         {
 232:             return size() > MENU_CACHE_MAX;
 233:         }
 234:     };
 235:     private CachedMenu customMenuCache = null;
 236:     private final List<ClickAction> queuedClicks = new ArrayList<>();
 237:     private String pendingCacheKey = null;
 238:     private long pendingCacheMs = 0L;
 239:     private boolean fakeMenuActive = false;
 240:     private String fakeMenuKey = null;
 241:     private boolean awaitingCacheSnapshot = false;
 242:     private int cacheOpenTicks = 0;
 243:     private boolean editorModeActive = false;
 244:     private boolean editorModeWasActive = false;
 245:     private boolean captureCustomMenuArmed = false;
 246:     private boolean captureCustomMenuNow = false;
 247:     private boolean codeMenuActive = false;
 248:     private IInventory codeMenuInventory = null;
 249:     private KeyBinding keyOpenCodeMenu;
 250:     private KeyBinding keyOpenCodeMenuAlt;
 251:     private KeyBinding keyTpForward;
 252:     private boolean codeMenuKeyDown = false;
 253:     private boolean tpForwardKeyDown = false;
 254:     private int tpScrollSteps = 0;
 255:     private int tpScrollQueue = 0;
 256:     private int tpScrollDir = 0;
 257:     private long tpScrollNextMs = 0L;
 258:     private final Deque<double[]> tpPathQueue = new ArrayDeque<>();
 259:     private long tpPathNextMs = 0L;
 260:     private File codeBlueGlassFile = null;
 261:     private boolean codeBlueGlassDirty = false;
 262:     private long lastCodeBlueGlassSaveMs = 0L;
 263:     private final AtomicBoolean codeBlueGlassSaveQueued = new AtomicBoolean(false);
 264:     private final Map<String, BlockPos> codeBlueGlassById = new HashMap<>();
 265:     private String signSearchQuery = null;
 266:     private int signSearchDim = 0;
 267:     private final List<BlockPos> signSearchMatches = new ArrayList<>();
 268:     private boolean debugUi = false;
 269:     private long lastDevCommandMs = 0L;
 270:     private boolean pendingDev = false;
 271:     private long pendingDevUntilMs = 0L;
 272:     private String cachePathRoot = null;
 273:     private final List<CopiedSlot> copiedSlots = new ArrayList<>();
 274:     private final Map<String, ChestCache> chestCaches = new LinkedHashMap<String, ChestCache>(32, 0.75f, true)
 275:     {
 276:         @Override
 277:         protected boolean removeEldestEntry(Map.Entry<String, ChestCache> eldest)
 278:         {
 279:             return size() > CHEST_CACHE_MAX;
 280:         }
 281:     };
 282:     private final Map<String, ChestCache> chestIdCaches = new LinkedHashMap<String, ChestCache>(64, 0.75f, true)
 283:     {
 284:         @Override
 285:         protected boolean removeEldestEntry(Map.Entry<String, ChestCache> eldest)
 286:         {
 287:             return size() > CHEST_CACHE_MAX;
 288:         }
 289:     };
 290:     private final Map<String, ChestPreviewFbo> chestPreviewFbos = new LinkedHashMap<String, ChestPreviewFbo>(32, 0.75f, true)
 291:     {
 292:         @Override
 293:         protected boolean removeEldestEntry(Map.Entry<String, ChestPreviewFbo> eldest)
 294:         {
 295:             return size() > CHEST_CACHE_MAX;
 296:         }
 297:     };
 298:     private File entriesFile = null;
 299:     private File chestCacheFile = null;
 300:     private File noteFile = null;
 301:     private File menuCacheFile = null;
 302:     private File shulkerHoloFile = null;
 303:     private boolean entriesDirty = false;
 304:     private long lastEntriesSaveMs = 0L;
 305:     private String noteText = "";
 306:     private BlockPos lastClickedPos = null;
 307:     private int lastClickedDim = 0;
 308:     private long lastClickedMs = 0L;
 309:     private boolean lastClickedChest = false;
 310:     private String lastClickedLabel = null;
 311:     private boolean lastClickedIsSign = false;
 312: 
 313:     private BlockPos lastGlassPos = null;
 314:     private int lastGlassDim = 0;
 315:     private boolean pendingChestSnapshot = false;
 316:     private long pendingChestUntilMs = 0L;
 317:     private String lastSnapshotInfo = "";
 318:     private final Map<String, Boolean> chestFaceSouth = new HashMap<>();
 319:     private final Map<String, Double> chestYOffset = new HashMap<>();
 320:     private boolean allowChestSnapshot = false;
 321:     private long allowChestUntilMs = 0L;
 322:     private long lastChestSnapshotMs = 0L;
 323:     private long lastChestSnapshotTick = -1L;
 324:     private boolean lastEditorModeActive = false;
 325:     private boolean chestIdDirty = false;
 326:     private long lastChestIdSaveMs = 0L;
 327:     private boolean menuCacheDirty = false;
 328:     private long lastMenuCacheSaveMs = 0L;
 329:     private boolean shulkerHoloDirty = false;
 330:     private long lastShulkerHoloSaveMs = 0L;
 331:     private long lastConfigCheckMs = 0L;
 332:     private long lastConfigStamp = 0L;
 333:     private ExecutorService ioExecutor;
 334:     private final AtomicBoolean entriesSaveQueued = new AtomicBoolean(false);
 335:     private final AtomicBoolean menuSaveQueued = new AtomicBoolean(false);
 336:     private final AtomicBoolean chestSaveQueued = new AtomicBoolean(false);
 337:     private final AtomicBoolean shulkerHoloSaveQueued = new AtomicBoolean(false);
 338:     private boolean pendingShulkerEdit = false;
 339:     private long pendingShulkerUntilMs = 0L;
 340:     private BlockPos pendingShulkerPos = null;
 341:     private int pendingShulkerDim = 0;
 342:     private int pendingShulkerColor = 0xFFFFFF;
 343:     private boolean shulkerEditActive = false;
 344:     private int shulkerEditWindowId = -1;
 345:     private int shulkerEditSlotNumber = -1;
 346:     private BlockPos shulkerEditPos = null;
 347:     private int shulkerEditDim = 0;
 348:     private int shulkerEditColor = 0xFFFFFF;
 349:     private float chestHoloScale = CHEST_HOLO_SCALE;
 350:     private int chestHoloTextWidth = CHEST_HOLO_TEXT_WIDTH;
 351:     private int chestHoloTexSize = CHEST_HOLO_TEX_SIZE;
 352:     private String lastHoloInfo = "";
 353:     private boolean chestHoloForceRerender = true;
 354:     private boolean chestHoloUseTestPipeline = false;
 355:     private boolean chestHoloSmoothFont = true;
 356:     private boolean chestHoloUseGuiRender = true;
 357:     private static int chestHoloTextColor = 0xFFFFFF;
 358:     private final Map<String, TestChestHolo> chestTestHolos = new HashMap<>();
 359:     private final Map<String, ShulkerHolo> shulkerHolos = new HashMap<>();
 360:     private float shulkerHoloScale = 0.06F;
 361:     private double shulkerHoloYOffset = 1.15;
 362:     private double shulkerHoloZOffset = 0.0;
 363:     private boolean shulkerHoloBillboard = true;
 364:     private boolean shulkerHoloDepth = false;
 365:     private boolean shulkerHoloCull = false;
 366:     private float lastTestScale = CHEST_HOLO_SCALE;
 367:     private int lastTestTextWidth = CHEST_HOLO_TEXT_WIDTH;
 368:     private int lastTestTexSize = CHEST_HOLO_TEX_SIZE;
 369:     private java.lang.reflect.Field lowerChestField;
 370:     private java.lang.reflect.Field guiLeftField;
 371:     private java.lang.reflect.Field guiTopField;
 372:     private java.lang.reflect.Field xSizeField;
 373:     private java.lang.reflect.Field ySizeField;
 374:     private java.lang.reflect.Field fontTextureField;
 375:     private boolean testHoloActive = false;
 376:     private BlockPos testHoloPos = null;
 377:     private final List<TestChestHolo> testChestHolos = new ArrayList<>();
 378: 
 379:     @EventHandler
 380:     public void preInit(FMLPreInitializationEvent event)
 381:     {
 382:         logger = event.getModLog();
 383:         MinecraftForge.EVENT_BUS.register(this);
 384:         loadConfig(event);
 385:         initEntriesFile(event);
 386:         initIoExecutor();
 387:     }
 388: 
 389:     @EventHandler
 390:     public void init(FMLInitializationEvent event)
 391:     {
 392:         // some example code
 393:         logger.info("DIRT BLOCK >> {}", Blocks.DIRT.getRegistryName());
 394:         initHotbarStorage();
 395:         registerKeybinds();
 396:         startHttpServer();
 397:     }
 398: 
 399:     @EventHandler
 400:     public void postInit(FMLPostInitializationEvent event)
 401:     {
 402:         registerClientCommands();
 403:     }
 404: 
 405:     @EventHandler
 406:     public void onServerStarting(FMLServerStartingEvent event)
 407:     {
 408:         mcServer = event.getServer();
 409:     }
 410: 
 411:     @EventHandler
 412:     public void onServerStopping(FMLServerStoppingEvent event)
 413:     {
 414:         mcServer = null;
 415:     }
 416: 
 417:     @SubscribeEvent
 418:     public void onServerChat(ServerChatEvent event)
 419:     {
 420:         lastChatPlayer = event.getPlayer().getName();
 421:         lastChatMessage = event.getMessage();
 422:         lastChatTimeMs = System.currentTimeMillis();
 423:     }
 424: 
 425:     @SubscribeEvent
 426:     public void onConfigChanged(ConfigChangedEvent.OnConfigChangedEvent event)
 427:     {
 428:         if (event != null && MODID.equals(event.getModID()))
 429:         {
 430:             syncConfig(false);
 431:             setActionBar(true, "&eConfig: hotbar=" + enableSecondHotbar + " holo=#"
 432:                 + String.format(Locale.ROOT, "%06X", chestHoloTextColor), 3000L);
 433:             if (!enableSecondHotbar)
 434:             {
 435:                 Minecraft mc = Minecraft.getMinecraft();
 436:                 if (mc != null)
 437:                 {
 438:                     activeHotbarSet = 0;
 439:                     if (mc.player != null)
 440:                     {
 441:                         loadHotbar(mc, activeHotbarSet);
 442:                     }
 443:                 }
 444:                 for (int i = 0; i < hotbarKeyDown.length; i++)
 445:                 {
 446:                     hotbarKeyDown[i] = false;
 447:                     lastHotbarTapMs[i] = 0L;
 448:                 }
 449:             }
 450:         }
 451:     }
 452: 
 453:     @SubscribeEvent
 454:     public void onClientChat(ClientChatReceivedEvent event)
 455:     {
 456:         String msg = event.getMessage().getUnformattedText();
 457:         lastChatMessage = msg;
 458:         lastChatTimeMs = System.currentTimeMillis();
 459:         lastChatPlayer = parseChatPlayer(msg);
 460:     }
 461: 
 462:     @SubscribeEvent
 463:     public void onClientChatSend(ClientChatEvent event)
 464:     {
 465:         if (event == null || event.getMessage() == null)
 466:         {
 467:             return;
 468:         }
 469:         String message = event.getMessage().trim();
 470:         if (!message.startsWith("/"))
 471:         {
 472:             return;
 473:         }
 474:         String lower = message.toLowerCase(Locale.ROOT);
 475:         String cmd = lower.split("\\s+")[0];
 476:         if ("/dev".equals(cmd))
 477:         {
 478:             editorModeActive = true;
 479:             editorModeWasActive = true;
 480:             pendingDev = true;
 481:             lastDevCommandMs = System.currentTimeMillis();
 482:             pendingDevUntilMs = lastDevCommandMs + EDITOR_MODE_GRACE_MS;
 483:             setActionBar(true, "&b\u0412\u044b \u0432\u043e\u0448\u043b\u0438 \u0432 \u043a\u043e\u0434", BAR_DEFAULT_MS);
 484:             return;
 485:         }
 486:         if (isExitCodeCommand(cmd))
 487:         {
 488:             editorModeActive = false;
 489:             editorModeWasActive = false;
 490:         }
 491:     }
 492: 
 493:     private void startHttpServer()
 494:     {
 495:         if (httpServer != null)
 496:         {
 497:             return;
 498:         }
 499: 
 500:         try
 501:         {
 502:             for (int port = BASE_PORT; port <= MAX_PORT; port++)
 503:             {
 504:                 try
 505:                 {
 506:                     httpServer = HttpServer.create(new InetSocketAddress("127.0.0.1", port), 0);
 507:                     apiPort = port;
 508:                     break;
 509:                 }
 510:                 catch (BindException e)
 511:                 {
 512:                     // Port in use, try the next one.
 513:                 }
 514:             }
 515: 
 516:             if (httpServer == null)
 517:             {
 518:                 logger.error("No available port for API server in range {}-{}", BASE_PORT, MAX_PORT);
 519:                 return;
 520:             }
 521: 
 522:             httpServer.createContext("/player", this::handlePlayers);
 523:             httpServer.createContext("/player/self", this::handleSelfPlayer);
 524:             httpServer.createContext("/players/tab", this::handleTabPlayers);
 525:             httpServer.createContext("/players/coords", this::handlePlayerCoords);
 526:             httpServer.createContext("/chat/last", this::handleLastChat);
 527:             httpServer.createContext("/chat/send", this::handleChatSend);
 528:             httpServer.createContext("/command", this::handleCommand);
 529:             httpServer.createContext("/block", this::handleBlock);
 530:             httpServer.createContext("/book/write", this::handleBookWrite);
 531:             httpServer.createContext("/bar", this::handleActionBar);
 532:             httpServer.createContext("/bar2", this::handleActionBar2);
 533: 
 534:             if (apiPort == BASE_PORT)
 535:             {
 536:                 registryServer = httpServer;
 537:                 registryEnabled = true;
 538:                 registerRegistryEndpoints(registryServer);
 539:             }
 540: 
 541:             httpServer.setExecutor(Executors.newCachedThreadPool());
 542:             httpServer.start();
 543: 
 544:             if (apiPort != BASE_PORT)
 545:             {
 546:                 startRegistryServer();
 547:             }
 548: 
 549:             startRegistryHeartbeat();
 550:             logger.info("Local API started on http://127.0.0.1:{} (registry:{})", apiPort,
 551:                 registryEnabled ? BASE_PORT : "none");
 552:         }
 553:         catch (IOException e)
 554:         {
 555:             logger.error("Failed to start local API", e);
 556:             httpServer = null;
 557:         }
 558:     }
 559: 
 560:     private void stopHttpServer()
 561:     {
 562:         if (httpServer != null)
 563:         {
 564:             httpServer.stop(0);
 565:             httpServer = null;
 566:             logger.info("Local API stopped");
 567:         }
 568:         if (registryServer != null && registryServer != httpServer)
 569:         {
 570:             registryServer.stop(0);
 571:             registryServer = null;
 572:         }
 573:         if (registryHeartbeat != null)
 574:         {
 575:             registryHeartbeat.shutdownNow();
 576:             registryHeartbeat = null;
 577:         }
 578:     }
 579: 
 580:     private void handlePlayers(HttpExchange exchange) throws IOException
 581:     {
 582:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
 583:         {
 584:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 585:             return;
 586:         }
 587: 
 588:         String payload = mcServer != null ? cachedServerPlayersJson : cachedClientTabJson;
 589:         sendJson(exchange, 200, payload);
 590:     }
 591: 
 592:     private void handleSelfPlayer(HttpExchange exchange) throws IOException
 593:     {
 594:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
 595:         {
 596:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 597:             return;
 598:         }
 599: 
 600:         Minecraft mc = Minecraft.getMinecraft();
 601:         if (mc == null || mc.player == null)
 602:         {
 603:             if (mcServer != null && mcServer.getPlayerList() != null && !mcServer.getPlayerList().getPlayers().isEmpty())
 604:             {
 605:                 EntityPlayerMP player = mcServer.getPlayerList().getPlayers().get(0);
 606:                 sendJson(exchange, 200, buildSelfJson(player, "server"));
 607:             }
 608:             else
 609:             {
 610:                 sendJson(exchange, 503, "{\"ok\":false,\"error\":\"no_player\"}");
 611:             }
 612:         }
 613:         else
 614:         {
 615:             sendJson(exchange, 200, buildSelfJson(mc.player, "client"));
 616:         }
 617:     }
 618: 
 619:     private void handleTabPlayers(HttpExchange exchange) throws IOException
 620:     {
 621:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
 622:         {
 623:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 624:             return;
 625:         }
 626: 
 627:         sendJson(exchange, 200, cachedClientTabJson);
 628:     }
 629: 
 630:     private void handlePlayerCoords(HttpExchange exchange) throws IOException
 631:     {
 632:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
 633:         {
 634:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 635:             return;
 636:         }
 637: 
 638:         String payload = mcServer != null ? cachedServerCoordsJson : cachedClientCoordsJson;
 639:         sendJson(exchange, 200, payload);
 640:     }
 641: 
 642:     private void handleLastChat(HttpExchange exchange) throws IOException
 643:     {
 644:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
 645:         {
 646:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 647:             return;
 648:         }
 649: 
 650:         String payload = "{\"player\":\"" + escapeJson(lastChatPlayer) + "\",\"message\":\""
 651:             + escapeJson(lastChatMessage) + "\",\"timeMs\":" + lastChatTimeMs + "}";
 652:         sendJson(exchange, 200, payload);
 653:     }
 654: 
 655:     private void handleCommand(HttpExchange exchange) throws IOException
 656:     {
 657:         if (!"POST".equalsIgnoreCase(exchange.getRequestMethod()))
 658:         {
 659:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 660:             return;
 661:         }
 662: 
 663:         String body = readBody(exchange.getRequestBody()).trim();
 664:         String query = exchange.getRequestURI().getRawQuery();
 665:         String cmd = body.isEmpty() ? getQueryParam(query, "cmd") : body;
 666:         String asPlayer = getQueryParam(query, "player");
 667: 
 668:         if (cmd == null || cmd.trim().isEmpty())
 669:         {
 670:             sendJson(exchange, 400, "{\"error\":\"missing_cmd\"}");
 671:             return;
 672:         }
 673: 
 674:         String cmdFinal = stripSlash(cmd.trim());
 675:         if (mcServer == null)
 676:         {
 677:             String blockReason = getClientBlockReason();
 678:             if (blockReason != null)
 679:             {
 680:                 sendJson(exchange, 429, "{\"ok\":false,\"error\":\"" + blockReason + "\"}");
 681:                 return;
 682:             }
 683:         }
 684:         CommandResult result = executeCommand(cmdFinal, asPlayer);
 685: 
 686:         if (result.executed)
 687:         {
 688:             sendJson(exchange, 200, "{\"ok\":true,\"mode\":\"" + result.mode + "\"}");
 689:         }
 690:         else
 691:         {
 692:             sendJson(exchange, 503, "{\"ok\":false,\"error\":\"no_world\"}");
 693:         }
 694:     }
 695: 
 696:     private void handleBlock(HttpExchange exchange) throws IOException
 697:     {
 698:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
 699:         {
 700:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 701:             return;
 702:         }
 703: 
 704:         String query = exchange.getRequestURI().getRawQuery();
 705:         Integer x = parseIntParam(query, "x");
 706:         Integer y = parseIntParam(query, "y");
 707:         Integer z = parseIntParam(query, "z");
 708:         Integer dim = parseIntParam(query, "dim");
 709: 
 710:         if (x == null || y == null || z == null)
 711:         {
 712:             sendJson(exchange, 400, "{\"error\":\"missing_coords\"}");
 713:             return;
 714:         }
 715: 
 716:         World world = getWorld(dim);
 717:         if (world == null)
 718:         {
 719:             sendJson(exchange, 503, "{\"ok\":false,\"error\":\"no_world\"}");
 720:             return;
 721:         }
 722: 
 723:         BlockPos pos = new BlockPos(x, y, z);
 724:         if (!world.isBlockLoaded(pos))
 725:         {
 726:             sendJson(exchange, 200, "{\"ok\":false,\"error\":\"unloaded\"}");
 727:             return;
 728:         }
 729: 
 730:         IBlockState state = world.getBlockState(pos);
 731:         ResourceLocation id = state.getBlock().getRegistryName();
 732:         int numericId = Block.getIdFromBlock(state.getBlock());
 733:         int meta = state.getBlock().getMetaFromState(state);
 734:         String payload = "{\"ok\":true,\"id\":\"" + escapeJson(id == null ? "" : id.toString())
 735:             + "\",\"idNum\":" + numericId + ",\"meta\":" + meta + "}";
 736:         sendJson(exchange, 200, payload);
 737:     }
 738: 
 739:     private void handleChatSend(HttpExchange exchange) throws IOException
 740:     {
 741:         if (!"POST".equalsIgnoreCase(exchange.getRequestMethod()))
 742:         {
 743:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 744:             return;
 745:         }
 746: 
 747:         String body = readBody(exchange.getRequestBody()).trim();
 748:         String query = exchange.getRequestURI().getRawQuery();
 749:         Map<String, String> params = parseParams(query, body);
 750:         String text = params.get("text");
 751:         if (text == null || text.trim().isEmpty())
 752:         {
 753:             sendJson(exchange, 400, "{\"error\":\"missing_text\"}");
 754:             return;
 755:         }
 756:         text = text.trim();
 757: 
 758:         if (text.startsWith("/"))
 759:         {
 760:             if (mcServer == null)
 761:             {
 762:                 String blockReason = getClientBlockReason();
 763:                 if (blockReason != null)
 764:                 {
 765:                     sendJson(exchange, 429, "{\"ok\":false,\"error\":\"" + blockReason + "\"}");
 766:                     return;
 767:                 }
 768:             }
 769:             CommandResult result = executeCommand(stripSlash(text), params.get("player"));
 770:             if (result.executed)
 771:             {
 772:                 sendJson(exchange, 200, "{\"ok\":true,\"mode\":\"" + result.mode + "\"}");
 773:             }
 774:             else
 775:             {
 776:                 sendJson(exchange, 503, "{\"ok\":false,\"error\":\"no_world\"}");
 777:             }
 778:             return;
 779:         }
 780: 
 781:         if (mcServer == null)
 782:         {
 783:             String blockReason = getClientBlockReason();
 784:             if (blockReason != null)
 785:             {
 786:                 sendJson(exchange, 429, "{\"ok\":false,\"error\":\"" + blockReason + "\"}");
 787:                 return;
 788:             }
 789:         }
 790: 
 791:         if (sendChatMessage(text))
 792:         {
 793:             sendJson(exchange, 200, "{\"ok\":true,\"mode\":\"client\"}");
 794:         }
 795:         else if (broadcastServerMessage(text))
 796:         {
 797:             sendJson(exchange, 200, "{\"ok\":true,\"mode\":\"server_broadcast\"}");
 798:         }
 799:         else
 800:         {
 801:             sendJson(exchange, 503, "{\"ok\":false,\"error\":\"no_player\"}");
 802:         }
 803:     }
 804: 
 805:     private void handleBookWrite(HttpExchange exchange) throws IOException
 806:     {
 807:         if (!"POST".equalsIgnoreCase(exchange.getRequestMethod()))
 808:         {
 809:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 810:             return;
 811:         }
 812: 
 813:         Minecraft mc = Minecraft.getMinecraft();
 814:         if (mc == null || mc.player == null)
 815:         {
 816:             sendJson(exchange, 503, "{\"ok\":false,\"error\":\"no_player\"}");
 817:             return;
 818:         }
 819: 
 820:         String body = readBody(exchange.getRequestBody()).trim();
 821:         String query = exchange.getRequestURI().getRawQuery();
 822:         Map<String, String> params = parseParams(query, body);
 823: 
 824:         String text = params.get("text");
 825:         if (text == null) text = "";
 826:         int pages = parseIntParam(params.get("pages"), 1);
 827:         if (pages < 1) pages = 1;
 828:         if (pages > 200) pages = 200;
 829:         boolean sign = "1".equals(params.get("sign"));
 830:         String title = params.get("title");
 831:         if (title == null || title.isEmpty())
 832:         {
 833:             title = "Book";
 834:         }
 835: 
 836:         ItemStack stack = mc.player.getHeldItemMainhand();
 837:         if (stack.isEmpty() || stack.getItem() != Items.WRITABLE_BOOK)
 838:         {
 839:             sendJson(exchange, 400, "{\"ok\":false,\"error\":\"hold_writable_book\"}");
 840:             return;
 841:         }
 842: 
 843:         NBTTagCompound tag = stack.getTagCompound();
 844:         if (tag == null) tag = new NBTTagCompound();
 845: 
 846:         NBTTagList list = new NBTTagList();
 847:         List<String> pageTexts = extractPageTexts(params);
 848:         if (!pageTexts.isEmpty())
 849:         {
 850:             int max = Math.min(200, pageTexts.size());
 851:             for (int i = 0; i < max; i++)
 852:             {
 853:                 list.appendTag(new NBTTagString(pageTexts.get(i)));
 854:             }
 855:         }
 856:         else
 857:         {
 858:             for (int i = 0; i < pages; i++)
 859:             {
 860:                 list.appendTag(new NBTTagString(text));
 861:             }
 862:         }
 863:         tag.setTag("pages", list);
 864: 
 865:         if (sign)
 866:         {
 867:             tag.setString("author", mc.player.getName());
 868:             tag.setString("title", title);
 869:         }
 870: 
 871:         stack.setTagCompound(tag);
 872: 
 873:         PacketBuffer buffer = new PacketBuffer(Unpooled.buffer());
 874:         buffer.writeItemStack(stack);
 875:         String channel = sign ? "MC|BSign" : "MC|BEdit";
 876:         mc.player.connection.sendPacket(new CPacketCustomPayload(channel, buffer));
 877: 
 878:         sendJson(exchange, 200, "{\"ok\":true}");
 879:     }
 880: 
 881:     private void handleActionBar(HttpExchange exchange) throws IOException
 882:     {
 883:         handleActionBarCommon(exchange, true);
 884:     }
 885: 
 886:     private void handleActionBar2(HttpExchange exchange) throws IOException
 887:     {
 888:         handleActionBarCommon(exchange, false);
 889:     }
 890: 
 891:     private void handleActionBarCommon(HttpExchange exchange, boolean primary) throws IOException
 892:     {
 893:         if (!"POST".equalsIgnoreCase(exchange.getRequestMethod()))
 894:         {
 895:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
 896:             return;
 897:         }
 898: 
 899:         String body = readBody(exchange.getRequestBody()).trim();
 900:         String query = exchange.getRequestURI().getRawQuery();
 901:         Map<String, String> params = parseParams(query, body);
 902:         String text = params.get("text");
 903:         if (text == null || text.trim().isEmpty())
 904:         {
 905:             sendJson(exchange, 400, "{\"error\":\"missing_text\"}");
 906:             return;
 907:         }
 908:         long duration = parseLongParam(params.get("time"), BAR_DEFAULT_MS);
 909:         setActionBar(primary, text, duration);
 910:         sendJson(exchange, 200, "{\"ok\":true}");
 911:     }
 912: 
 913:     private static void sendJson(HttpExchange exchange, int status, String payload) throws IOException
 914:     {
 915:         byte[] data = payload.getBytes(StandardCharsets.UTF_8);
 916:         Headers headers = exchange.getResponseHeaders();
 917:         headers.set("Content-Type", "application/json; charset=utf-8");
 918:         exchange.sendResponseHeaders(status, data.length);
 919:         try (OutputStream os = exchange.getResponseBody())
 920:         {
 921:             os.write(data);
 922:         }
 923:     }
 924: 
 925:     private static String readBody(InputStream is) throws IOException
 926:     {
 927:         byte[] buffer = new byte[4096];
 928:         int read;
 929:         StringBuilder sb = new StringBuilder();
 930:         while ((read = is.read(buffer)) != -1)
 931:         {
 932:             sb.append(new String(buffer, 0, read, StandardCharsets.UTF_8));
 933:         }
 934:         return sb.toString();
 935:     }
 936: 
 937:     private static String getQueryParam(String query, String key)
 938:     {
 939:         if (query == null || query.isEmpty())
 940:         {
 941:             return null;
 942:         }
 943: 
 944:         String[] parts = query.split("&");
 945:         for (String part : parts)
 946:         {
 947:             int idx = part.indexOf('=');
 948:             if (idx <= 0) continue;
 949:             String k = decodeUrl(part.substring(0, idx));
 950:             if (key.equals(k))
 951:             {
 952:                 return decodeUrl(part.substring(idx + 1));
 953:             }
 954:         }
 955:         return null;
 956:     }
 957: 
 958:     private static Map<String, String> parseParams(String query, String body)
 959:     {
 960:         Map<String, String> result = new HashMap<>();
 961:         if (query != null && !query.isEmpty())
 962:         {
 963:             result.putAll(parseQueryString(query));
 964:         }
 965:         if (body != null && !body.isEmpty())
 966:         {
 967:             if (body.contains("="))
 968:             {
 969:                 result.putAll(parseQueryString(body));
 970:             }
 971:             else
 972:             {
 973:                 result.put("text", body);
 974:             }
 975:         }
 976:         return result;
 977:     }
 978: 
 979:     private static Map<String, String> parseQueryString(String query)
 980:     {
 981:         Map<String, String> out = new HashMap<>();
 982:         String[] parts = query.split("&");
 983:         for (String part : parts)
 984:         {
 985:             int idx = part.indexOf('=');
 986:             if (idx <= 0) continue;
 987:             String k = decodeUrl(part.substring(0, idx));
 988:             String v = decodeUrl(part.substring(idx + 1));
 989:             out.put(k, v);
 990:         }
 991:         return out;
 992:     }
 993: 
 994:     private static Integer parseIntParam(String query, String key)
 995:     {
 996:         String value = getQueryParam(query, key);
 997:         if (value == null || value.isEmpty())
 998:         {
 999:             return null;
1000:         }
1001:         try
1002:         {
1003:             return Integer.parseInt(value.trim());
1004:         }
1005:         catch (NumberFormatException e)
1006:         {
1007:             return null;
1008:         }
1009:     }
1010: 
1011:     private static int parseIntParam(String value, int fallback)
1012:     {
1013:         if (value == null) return fallback;
1014:         try
1015:         {
1016:             return Integer.parseInt(value.trim());
1017:         }
1018:         catch (NumberFormatException e)
1019:         {
1020:             return fallback;
1021:         }
1022:     }
1023: 
1024:     private static long parseLongParam(String value, long fallback)
1025:     {
1026:         if (value == null) return fallback;
1027:         try
1028:         {
1029:             return Long.parseLong(value.trim());
1030:         }
1031:         catch (NumberFormatException e)
1032:         {
1033:             return fallback;
1034:         }
1035:     }
1036: 
1037:     private static float parseFloat(String value, float fallback)
1038:     {
1039:         if (value == null) return fallback;
1040:         try
1041:         {
1042:             return Float.parseFloat(value.trim());
1043:         }
1044:         catch (NumberFormatException e)
1045:         {
1046:             return fallback;
1047:         }
1048:     }
1049: 
1050:     private static double parseDouble(String value, double fallback)
1051:     {
1052:         if (value == null) return fallback;
1053:         try
1054:         {
1055:             return Double.parseDouble(value.trim());
1056:         }
1057:         catch (NumberFormatException e)
1058:         {
1059:             return fallback;
1060:         }
1061:     }
1062: 
1063:     private World getWorld(Integer dim)
1064:     {
1065:         if (mcServer != null)
1066:         {
1067:             int d = dim == null ? 0 : dim;
1068:             return mcServer.getWorld(d);
1069:         }
1070:         Minecraft mc = Minecraft.getMinecraft();
1071:         return mc == null ? null : mc.world;
1072:     }
1073: 
1074:     private static String parseChatPlayer(String msg)
1075:     {
1076:         if (msg == null) return "";
1077:         if (msg.startsWith("<"))
1078:         {
1079:             int end = msg.indexOf('>');
1080:             if (end > 1)
1081:             {
1082:                 return msg.substring(1, end).trim();
1083:             }
1084:         }
1085:         return "";
1086:     }
1087: 
1088:     private static String stripSlash(String cmd)
1089:     {
1090:         if (cmd.startsWith("/"))
1091:         {
1092:             return cmd.substring(1);
1093:         }
1094:         return cmd;
1095:     }
1096: 
1097:     private static String decodeUrl(String s)
1098:     {
1099:         try
1100:         {
1101:             return URLDecoder.decode(s, "UTF-8");
1102:         }
1103:         catch (Exception e)
1104:         {
1105:             return s;
1106:         }
1107:     }
1108: 
1109:     private static String escapeJson(String s)
1110:     {
1111:         if (s == null) return "";
1112:         return s.replace("\\", "\\\\")
1113:             .replace("\"", "\\\"")
1114:             .replace("\n", "\\n")
1115:             .replace("\r", "\\r")
1116:             .replace("\t", "\\t");
1117:     }
1118: 
1119:     private static boolean isExitCodeCommand(String cmd)
1120:     {
1121:         return "/build".equals(cmd)
1122:             || "/play".equals(cmd)
1123:             || "/s".equals(cmd)
1124:             || "/lobby".equals(cmd)
1125:             || "/hub".equals(cmd)
1126:             || "/\u0437\u0434\u0444\u043d".equals(cmd)
1127:             || "/\u0438\u0433\u0448\u0434\u0432".equals(cmd);
1128:     }
1129: 
1130:     @SubscribeEvent
1131:     public void onServerTick(TickEvent.ServerTickEvent event)
1132:     {
1133:         if (event.phase != TickEvent.Phase.END || mcServer == null || mcServer.getPlayerList() == null)
1134:         {
1135:             return;
1136:         }
1137: 
1138:         List<EntityPlayerMP> players = mcServer.getPlayerList().getPlayers();
1139:         cachedServerPlayersJson = buildPlayerListJson(players);
1140:         cachedServerCoordsJson = buildPlayerCoordsJson(players);
1141:     }
1142: 
1143:     @SubscribeEvent
1144:     public void onClientTick(TickEvent.ClientTickEvent event)
1145:     {
1146:         if (event.phase != TickEvent.Phase.END)
1147:         {
1148:             return;
1149:         }
1150: 
1151:         Minecraft mc = Minecraft.getMinecraft();
1152:         if (mc != null && mc.world != lastWorldRef)
1153:         {
1154:             lastWorldRef = mc.world;
1155:             if (mc.world != null)
1156:             {
1157:                 initHotbarsForWorld(mc);
1158:             }
1159:         }
1160:         long now = System.currentTimeMillis();
1161:         if (allowChestSnapshot && now > allowChestUntilMs)
1162:         {
1163:             clearChestClickState();
1164:         }
1165:         long worldTick = (mc != null && mc.world != null) ? mc.world.getTotalWorldTime() : -1L;
1166:         if (mc != null && mc.currentScreen instanceof GuiChest)
1167:         {
1168:             if (lastClickedChest && allowChestSnapshot)
1169:             {
1170:                 lastClickedMs = now;
1171:                 if (!pendingChestSnapshot)
1172:                 {
1173:                     pendingChestSnapshot = true;
1174:                     pendingChestUntilMs = lastClickedMs + 5000L;
1175:                 }
1176:                 if (worldTick >= 0 && worldTick != lastChestSnapshotTick
1177:                     && (worldTick % CHEST_SNAPSHOT_TICK_INTERVAL == 0))
1178:                 {
1179:                     snapshotCurrentContainer((GuiContainer) mc.currentScreen);
1180:                     lastChestSnapshotMs = now;
1181:                     lastChestSnapshotTick = worldTick;
1182:                 }
1183:             }
1184:         }
1185:         if (pendingDev)
1186:         {
1187:             if (now > pendingDevUntilMs)
1188:             {
1189:                 pendingDev = false;
1190:             }
1191:             else if (mc != null && mc.playerController != null && mc.playerController.isInCreativeMode()
1192:                 && mc.playerController.getCurrentGameType() == GameType.CREATIVE)
1193:             {
1194:                 editorModeActive = true;
1195:                 editorModeWasActive = true;
1196:                 pendingDev = false;
1197:             }
1198:         }
1199:         boolean scoreboardCodeMode = false;
1200:         if (mc != null && mc.playerController != null && mc.playerController.isInCreativeMode()
1201:             && mc.playerController.getCurrentGameType() == GameType.CREATIVE)
1202:         {
1203:             String title = getScoreboardTitle();
1204:             if ("\u0420\u0415\u0414\u0410\u041a\u0422\u041e\u0420 \u0418\u0413\u0420\u042b".equals(title))
1205:             {  
1206:                 scoreboardCodeMode = true;
1207:                 editorModeActive = true;
1208:                 editorModeWasActive = true;
1209:                 pendingDev = false;
1210:             }
1211:         }
1212:         if (mc != null && mc.playerController != null && mc.playerController.isInCreativeMode()
1213:             && mc.playerController.getCurrentGameType() == GameType.CREATIVE && !scoreboardCodeMode)
1214:         {
1215:             editorModeActive = false;
1216:             editorModeWasActive = false;
1217:             codeMenuActive = false;
1218:             codeMenuInventory = null;
1219:             typePickerActive = false;
1220:             setInputActive(false);
1221:         }
1222:         if (mc != null && mc.currentScreen == null && !pendingChestSnapshot && !allowChestSnapshot)
1223:         {
1224:             lastClickedPos = null;
1225:             lastClickedChest = false;
1226:             lastClickedLabel = null;
1227:         }
1228:         if (pendingShulkerEdit && now > pendingShulkerUntilMs)
1229:         {
1230:             pendingShulkerEdit = false;
1231:             pendingShulkerPos = null;
1232:         }
1233:         if (pendingShulkerEdit && mc != null && mc.currentScreen instanceof GuiContainer)
1234:         {
1235:             handlePendingShulkerEdit((GuiContainer) mc.currentScreen);
1236:         }
1237:         if (editorModeActive && mc != null && mc.world != null && !lastEditorModeActive)
1238:         {
1239:             ensureChestCaches(mc.world.provider.getDimension());
1240:         }
1241:         lastEditorModeActive = editorModeActive;
1242:         if (editorModeActive && !pendingDev && (mc == null || mc.player == null || mc.playerController == null
1243:             || !mc.playerController.isInCreativeMode()
1244:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE))
1245:         {
1246:             if (now - lastDevCommandMs > EDITOR_MODE_GRACE_MS)
1247:             {
1248:                 editorModeActive = false;
1249:                 editorModeWasActive = false;
1250:                 codeMenuActive = false;
1251:                 codeMenuInventory = null;
1252:                 typePickerActive = false;
1253:                 setInputActive(false);
1254:             }
1255:         }
1256:         if (pendingChestSnapshot)
1257:         {
1258:             if (now > pendingChestUntilMs)
1259:             {
1260:                 pendingChestSnapshot = false;
1261:             }
1262:             else if (mc != null && !lastClickedIsSign)
1263:             {
1264:                 if (mc.currentScreen instanceof GuiContainer && !(mc.currentScreen instanceof GuiInventory))
1265:                 {
1266:                     if (worldTick >= 0 && worldTick != lastChestSnapshotTick)
1267:                     {
1268:                         snapshotCurrentContainer((GuiContainer) mc.currentScreen);
1269:                         lastChestSnapshotTick = worldTick;
1270:                     }
1271:                     pendingChestSnapshot = false;
1272:                     lastSnapshotInfo = "snap:screen=" + mc.currentScreen.getClass().getSimpleName()
1273:                         + " pos=" + (lastClickedPos == null ? "-" : lastClickedPos.toString());
1274:                 }
1275:                 else if (mc.player != null && mc.player.openContainer != null
1276:                     && mc.player.openContainer != mc.player.inventoryContainer)
1277:                 {
1278:                     if (worldTick >= 0 && worldTick != lastChestSnapshotTick)
1279:                     {
1280:                         snapshotOpenContainer(mc.player.openContainer);
1281:                         lastChestSnapshotTick = worldTick;
1282:                     }
1283:                     pendingChestSnapshot = false;
1284:                     lastSnapshotInfo = "snap:container=" + mc.player.openContainer.getClass().getSimpleName()
1285:                         + " pos=" + (lastClickedPos == null ? "-" : lastClickedPos.toString());
1286:                 }
1287:                 else
1288:                 {
1289:                     lastSnapshotInfo = "snap:waiting screen="
1290:                         + (mc.currentScreen == null ? "-" : mc.currentScreen.getClass().getSimpleName())
1291:                         + " container=" + (mc.player == null || mc.player.openContainer == null ? "-"
1292:                         : mc.player.openContainer.getClass().getSimpleName());
1293:                 }
1294:             }
1295:         }
1296:         if (mc != null)
1297:         {
1298:             lastClickedChest = mc.currentScreen instanceof GuiChest && !lastClickedIsSign;
1299:         }
1300:         if (mc == null || mc.getConnection() == null)
1301:         {
1302:             cachedClientTabJson = "{\"count\":0,\"players\":[]}";
1303:         }
1304:         else
1305:         {
1306:             List<String> names = new ArrayList<>();
1307:             for (NetworkPlayerInfo info : mc.getConnection().getPlayerInfoMap())
1308:             {
1309:                 if (info.getGameProfile() != null)
1310:                 {
1311:                     names.add(info.getGameProfile().getName());
1312:                 }
1313:             }
1314:             cachedClientTabJson = buildNameListJson(names);
1315:         }
1316: 
1317:         if (mc == null || mc.world == null)
1318:         {
1319:             cachedClientCoordsJson = "{\"count\":0,\"players\":[]}";
1320:         }
1321:         else
1322:         {
1323:             cachedClientCoordsJson = buildPlayerCoordsJson(mc.world.playerEntities);
1324:         }
1325: 
1326:         handleMenuCacheTick(mc);
1327:         handleCodeMenuKeys(mc);
1328:         handleTpForwardKey(mc);
1329:         handleTpScrollQueue(mc);
1330:         handleTpPathQueue(mc);
1331:         handleHotbarSwap(mc);
1332:         checkConfigFileChanges();
1333:         saveEntriesIfNeeded();
1334:         saveMenuCacheIfNeeded();
1335:         saveChestIdCachesIfNeeded();
1336:         saveShulkerHolosIfNeeded();
1337:         saveCodeBlueGlassIfNeeded();
1338:     }
1339: 
1340:     private static String buildNameListJson(List<String> names)
1341:     {
1342:         StringBuilder sb = new StringBuilder();
1343:         sb.append("{\"count\":").append(names.size()).append(",\"players\":[");
1344:         for (int i = 0; i < names.size(); i++)
1345:         {
1346:             if (i > 0) sb.append(",");
1347:             sb.append("\"").append(escapeJson(names.get(i))).append("\"");
1348:         }
1349:         sb.append("]}");
1350:         return sb.toString();
1351:     }
1352: 
1353:     private static String buildPlayerListJson(List<? extends net.minecraft.entity.player.EntityPlayer> players)
1354:     {
1355:         List<String> names = new ArrayList<>();
1356:         for (net.minecraft.entity.player.EntityPlayer p : players)
1357:         {
1358:             names.add(p.getName());
1359:         }
1360:         return buildNameListJson(names);
1361:     }
1362: 
1363:     private static String buildPlayerCoordsJson(List<? extends net.minecraft.entity.player.EntityPlayer> players)
1364:     {
1365:         StringBuilder sb = new StringBuilder();
1366:         sb.append("{\"count\":").append(players.size()).append(",\"players\":[");
1367:         for (int i = 0; i < players.size(); i++)
1368:         {
1369:             if (i > 0) sb.append(",");
1370:             net.minecraft.entity.player.EntityPlayer p = players.get(i);
1371:             int dim = p.world == null ? 0 : p.world.provider.getDimension();
1372:             sb.append("{\"name\":\"").append(escapeJson(p.getName())).append("\",")
1373:                 .append("\"x\":").append(formatCoord(p.posX)).append(",")
1374:                 .append("\"y\":").append(formatCoord(p.posY)).append(",")
1375:                 .append("\"z\":").append(formatCoord(p.posZ)).append(",")
1376:                 .append("\"dim\":").append(dim).append("}");
1377:         }
1378:         sb.append("]}");
1379:         return sb.toString();
1380:     }
1381: 
1382:     private String buildSelfJson(net.minecraft.entity.player.EntityPlayer player, String mode)
1383:     {
1384:         int dim = player.world == null ? 0 : player.world.provider.getDimension();
1385:         return "{\"ok\":true,\"name\":\"" + escapeJson(player.getName()) + "\",\"x\":"
1386:             + formatCoord(player.posX) + ",\"y\":" + formatCoord(player.posY) + ",\"z\":"
1387:             + formatCoord(player.posZ) + ",\"dim\":" + dim + ",\"mode\":\""
1388:             + mode + "\",\"port\":" + apiPort + "}";
1389:     }
1390: 
1391:     private static String formatCoord(double value)
1392:     {
1393:         return String.format(Locale.ROOT, "%.3f", value);
1394:     }
1395: 
1396:     private void startRegistryServer() throws IOException
1397:     {
1398:         try
1399:         {
1400:             registryServer = HttpServer.create(new InetSocketAddress("127.0.0.1", BASE_PORT), 0);
1401:             registryEnabled = true;
1402:             registerRegistryEndpoints(registryServer);
1403:             registryServer.setExecutor(Executors.newCachedThreadPool());
1404:             registryServer.start();
1405:         }
1406:         catch (BindException e)
1407:         {
1408:             registryEnabled = false;
1409:             registryServer = null;
1410:         }
1411:     }
1412: 
1413:     private void registerRegistryEndpoints(HttpServer server)
1414:     {
1415:         server.createContext("/registry/ping", this::handleRegistryPing);
1416:         server.createContext("/registry/register", this::handleRegistryRegister);
1417:         server.createContext("/registry/clients", this::handleRegistryClients);
1418:     }
1419: 
1420:     private void handleRegistryPing(HttpExchange exchange) throws IOException
1421:     {
1422:         sendJson(exchange, 200, "{\"ok\":true}");
1423:     }
1424: 
1425:     private void handleRegistryRegister(HttpExchange exchange) throws IOException
1426:     {
1427:         if (!"POST".equalsIgnoreCase(exchange.getRequestMethod()))
1428:         {
1429:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
1430:             return;
1431:         }
1432: 
1433:         String body = readBody(exchange.getRequestBody()).trim();
1434:         String query = exchange.getRequestURI().getRawQuery();
1435:         String name = body.isEmpty() ? getQueryParam(query, "name") : getQueryParam(body, "name");
1436:         String portStr = body.isEmpty() ? getQueryParam(query, "port") : getQueryParam(body, "port");
1437:         String mode = body.isEmpty() ? getQueryParam(query, "mode") : getQueryParam(body, "mode");
1438: 
1439:         if (name == null || name.isEmpty() || portStr == null)
1440:         {
1441:             sendJson(exchange, 400, "{\"ok\":false,\"error\":\"missing_name_or_port\"}");
1442:             return;
1443:         }
1444: 
1445:         int port;
1446:         try
1447:         {
1448:             port = Integer.parseInt(portStr.trim());
1449:         }
1450:         catch (NumberFormatException e)
1451:         {
1452:             sendJson(exchange, 400, "{\"ok\":false,\"error\":\"bad_port\"}");
1453:             return;
1454:         }
1455: 
1456:         String key = port + ":" + name;
1457:         RegistryEntry entry = new RegistryEntry(name, port, mode == null ? "" : mode);
1458:         entry.lastSeenMs = System.currentTimeMillis();
1459:         registryEntries.put(key, entry);
1460: 
1461:         sendJson(exchange, 200, "{\"ok\":true}");
1462:     }
1463: 
1464:     private void handleRegistryClients(HttpExchange exchange) throws IOException
1465:     {
1466:         if (!"GET".equalsIgnoreCase(exchange.getRequestMethod()))
1467:         {
1468:             sendJson(exchange, 405, "{\"error\":\"method_not_allowed\"}");
1469:             return;
1470:         }
1471: 
1472:         pruneRegistry();
1473:         StringBuilder sb = new StringBuilder();
1474:         sb.append("{\"count\":").append(registryEntries.size()).append(",\"clients\":[");
1475:         boolean first = true;
1476:         for (RegistryEntry entry : registryEntries.values())
1477:         {
1478:             if (!first) sb.append(",");
1479:             first = false;
1480:             sb.append("{\"name\":\"").append(escapeJson(entry.name)).append("\",")
1481:                 .append("\"port\":").append(entry.port).append(",")
1482:                 .append("\"mode\":\"").append(escapeJson(entry.mode)).append("\",")
1483:                 .append("\"lastSeenMs\":").append(entry.lastSeenMs).append("}");
1484:         }
1485:         sb.append("]}");
1486:         sendJson(exchange, 200, sb.toString());
1487:     }
1488: 
1489:     private void pruneRegistry()
1490:     {
1491:         long now = System.currentTimeMillis();
1492:         registryEntries.entrySet().removeIf(e -> now - e.getValue().lastSeenMs > REGISTRY_TTL_MS);
1493:     }
1494: 
1495:     private void startRegistryHeartbeat()
1496:     {
1497:         if (registryHeartbeat != null)
1498:         {
1499:             return;
1500:         }
1501:         registryHeartbeat = Executors.newSingleThreadScheduledExecutor();
1502:         registryHeartbeat.scheduleAtFixedRate(this::sendRegistryHeartbeat, 0, REGISTRY_HEARTBEAT_MS,
1503:             TimeUnit.MILLISECONDS);
1504:     }
1505: 
1506:     private void sendRegistryHeartbeat()
1507:     {
1508:         String name = getSelfName();
1509:         if (name == null || name.isEmpty() || apiPort <= 0)
1510:         {
1511:             return;
1512:         }
1513: 
1514:         String mode = mcServer != null ? "server" : "client";
1515:         String body = "name=" + urlEncode(name) + "&port=" + apiPort + "&mode=" + urlEncode(mode);
1516:         try
1517:         {
1518:             URL url = new URL("http://127.0.0.1:" + BASE_PORT + "/registry/register");
1519:             HttpURLConnection conn = (HttpURLConnection) url.openConnection();
1520:             conn.setRequestMethod("POST");
1521:             conn.setConnectTimeout(500);
1522:             conn.setReadTimeout(500);
1523:             conn.setDoOutput(true);
1524:             byte[] data = body.getBytes(StandardCharsets.UTF_8);
1525:             conn.getOutputStream().write(data);
1526:             conn.getOutputStream().flush();
1527:             conn.getInputStream().close();
1528:             conn.disconnect();
1529:         }
1530:         catch (IOException ignored)
1531:         {
1532:             // Registry not available, ignore.
1533:         }
1534:     }
1535: 
1536:     private String getSelfName()
1537:     {
1538:         Minecraft mc = Minecraft.getMinecraft();
1539:         if (mc != null && mc.player != null)
1540:         {
1541:             return mc.player.getName();
1542:         }
1543:         if (mcServer != null && mcServer.getPlayerList() != null && !mcServer.getPlayerList().getPlayers().isEmpty())
1544:         {
1545:             return mcServer.getPlayerList().getPlayers().get(0).getName();
1546:         }
1547:         return "";
1548:     }
1549: 
1550:     private static String urlEncode(String s)
1551:     {
1552:         try
1553:         {
1554:             return java.net.URLEncoder.encode(s, "UTF-8");
1555:         }
1556:         catch (Exception e)
1557:         {
1558:             return s;
1559:         }
1560:     }
1561: 
1562:     private void registerClientCommands()
1563:     {
1564:         ClientCommandHandler.instance.registerCommand(new CBarCommand("cbar", true));
1565:         ClientCommandHandler.instance.registerCommand(new CBarCommand("cbar2", false));
1566:         ClientCommandHandler.instance.registerCommand(new GenCommand());
1567:         ClientCommandHandler.instance.registerCommand(new DebugCommand());
1568:         ClientCommandHandler.instance.registerCommand(new ConfigDebugCommand());
1569:         ClientCommandHandler.instance.registerCommand(new TestHoloCommand());
1570:         ClientCommandHandler.instance.registerCommand(new TestChestHoloCommand());
1571:         ClientCommandHandler.instance.registerCommand(new TestShulkerHoloCommand());
1572:         ClientCommandHandler.instance.registerCommand(new NoteCommand());
1573:         ClientCommandHandler.instance.registerCommand(new ScoreLineCommand());
1574:         ClientCommandHandler.instance.registerCommand(new ScoreTitleCommand());
1575:         ClientCommandHandler.instance.registerCommand(new ApiPortCommand());
1576:         ClientCommandHandler.instance.registerCommand(new GuiExportCommand());
1577:         ClientCommandHandler.instance.registerCommand(new TestTpLocalCommand());
1578:         ClientCommandHandler.instance.registerCommand(new TpPathCommand());
1579:         ClientCommandHandler.instance.registerCommand(new SignSearchCommand());
1580:         ClientCommandHandler.instance.registerCommand(new ExportLineCommand());
1581:     }
1582: 
1583: 
1584:     private void registerKeybinds()
1585:     {
1586:         keyOpenCodeMenu = new KeyBinding("key.mcpythonapi.codemenu", Keyboard.KEY_R, "key.categories.mcpythonapi");
1587:         keyOpenCodeMenuAlt = new KeyBinding("key.mcpythonapi.codemenu_alt", Keyboard.KEY_RMENU,
1588:             "key.categories.mcpythonapi");
1589:         keyTpForward = new KeyBinding("key.mcpythonapi.tpfwd", Keyboard.KEY_G, "key.categories.mcpythonapi");
1590:         ClientRegistry.registerKeyBinding(keyOpenCodeMenu);
1591:         ClientRegistry.registerKeyBinding(keyOpenCodeMenuAlt);
1592:         ClientRegistry.registerKeyBinding(keyTpForward);
1593:     }
1594: 
1595:     private static class CBarCommand extends CommandBase
1596:     {
1597:         private final String name;
1598:         private final boolean primary;
1599: 
1600:         CBarCommand(String name, boolean primary)
1601:         {
1602:             this.name = name;
1603:             this.primary = primary;
1604:         }
1605: 
1606:         @Override
1607:         public String getName()
1608:         {
1609:             return name;
1610:         }
1611: 
1612:         @Override
1613:         public String getUsage(ICommandSender sender)
1614:         {
1615:             return "/" + name + " <text>";
1616:         }
1617: 
1618:         @Override
1619:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1620:         {
1621:             if (args.length == 0)
1622:             {
1623:                 return;
1624:             }
1625:             String text = String.join(" ", args);
1626:             setActionBar(primary, text, BAR_DEFAULT_MS);
1627:         }
1628: 
1629:         @Override
1630:         public int getRequiredPermissionLevel()
1631:         {
1632:             return 0;
1633:         }
1634:     }
1635: 
1636:     private static class GenCommand extends CommandBase
1637:     {
1638:         @Override
1639:         public String getName()
1640:         {
1641:             return "gen";
1642:         }
1643: 
1644:         @Override
1645:         public String getUsage(ICommandSender sender)
1646:         {
1647:             return "/gen <name> <start-end>";
1648:         }
1649: 
1650:         @Override
1651:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1652:         {
1653:             if (args.length < 2)
1654:             {
1655:                 return;
1656:             }
1657:             Minecraft mc = Minecraft.getMinecraft();
1658:             if (mc == null || mc.player == null)
1659:             {
1660:                 return;
1661:             }
1662:             String base = args[0];
1663:             int[] range = parseRange(args[1]);
1664:             if (range == null)
1665:             {
1666:                 return;
1667:             }
1668:             int start = range[0];
1669:             int end = range[1];
1670:             int count = Math.min(9, end - start + 1);
1671:             for (int i = 0; i < count; i++)
1672:             {
1673:                 int index = start + i;
1674:                 ItemStack stack = new ItemStack(Items.MAGMA_CREAM, 1);
1675:                 stack.setStackDisplayName(base + index);
1676:                 mc.player.inventory.setInventorySlotContents(i, stack);
1677:             }
1678:         }
1679: 
1680:         @Override
1681:         public int getRequiredPermissionLevel()
1682:         {
1683:             return 0;
1684:         }
1685:     }
1686: 
1687:     private class DebugCommand extends CommandBase
1688:     {
1689:         @Override
1690:         public String getName()
1691:         {
1692:             return "mpdebug";
1693:         }
1694: 
1695:         @Override
1696:         public String getUsage(ICommandSender sender)
1697:         {
1698:             return "/mpdebug";
1699:         }
1700: 
1701:         @Override
1702:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1703:         {
1704:             debugUi = !debugUi;
1705:             setActionBar(true, debugUi ? "&aDebug ON" : "&cDebug OFF", 2000L);
1706:         }
1707: 
1708:         @Override
1709:         public int getRequiredPermissionLevel()
1710:         {
1711:             return 0;
1712:         }
1713:     }
1714: 
1715:     private class TestHoloCommand extends CommandBase
1716:     {
1717:         @Override
1718:         public String getName()
1719:         {
1720:             return "testholo";
1721:         }
1722: 
1723:         @Override
1724:         public String getUsage(ICommandSender sender)
1725:         {
1726:             return "/testholo [on|off]";
1727:         }
1728: 
1729:         @Override
1730:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1731:         {
1732:             Minecraft mc = Minecraft.getMinecraft();
1733:             if (mc == null || mc.player == null)
1734:             {
1735:                 return;
1736:             }
1737:             if (args.length > 0)
1738:             {
1739:                 String arg = args[0].toLowerCase(Locale.ROOT);
1740:                 if ("on".equals(arg))
1741:                 {
1742:                     testHoloActive = true;
1743:                 }
1744:                 else if ("off".equals(arg))
1745:                 {
1746:                     testHoloActive = false;
1747:                 }
1748:             }
1749:             else
1750:             {
1751:                 testHoloActive = !testHoloActive;
1752:             }
1753:             if (testHoloActive)
1754:             {
1755:                 testHoloPos = new BlockPos(mc.player.posX, mc.player.posY + 1.5, mc.player.posZ);
1756:                 setActionBar(true, "&aHolo ON", 1500L);
1757:             }
1758:             else
1759:             {
1760:                 setActionBar(true, "&cHolo OFF", 1500L);
1761:             }
1762:         }
1763: 
1764:         @Override
1765:         public int getRequiredPermissionLevel()
1766:         {
1767:             return 0;
1768:         }
1769:     }
1770: 
1771:     private class TestChestHoloCommand extends CommandBase
1772:     {
1773:         @Override
1774:         public String getName()
1775:         {
1776:             return "testchestholo";
1777:         }
1778: 
1779:         @Override
1780:         public String getUsage(ICommandSender sender)
1781:         {
1782:             return "/testchestholo add [gui|fbo] [s=0.016] [w=40] [tex=1024] | set [s=0.016] [w=40] [tex=1024] [mode=cache|test|gui] [font=linear|nearest] | clear";
1783:         }
1784: 
1785:         @Override
1786:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1787:         {
1788:             Minecraft mc = Minecraft.getMinecraft();
1789:             if (mc == null || mc.player == null || mc.world == null)
1790:             {
1791:                 return;
1792:             }
1793:             if (args.length == 0)
1794:             {
1795:                 addTestChestHolo(mc, false, CHEST_HOLO_SCALE, CHEST_HOLO_TEXT_WIDTH, CHEST_HOLO_TEX_SIZE);
1796:                 return;
1797:             }
1798:             String arg = args[0].toLowerCase(Locale.ROOT);
1799:             if ("clear".equals(arg))
1800:             {
1801:                 testChestHolos.clear();
1802:                 setActionBar(true, "&cChest holo cleared", 1500L);
1803:                 return;
1804:             }
1805:             if ("set".equals(arg))
1806:             {
1807:                 float scale = chestHoloScale;
1808:                 int textWidth = chestHoloTextWidth;
1809:                 int texSize = chestHoloTexSize;
1810:                 boolean force = chestHoloForceRerender;
1811:                 boolean useTest = chestHoloUseTestPipeline;
1812:                 boolean smoothFont = chestHoloSmoothFont;
1813:                 boolean useGui = chestHoloUseGuiRender;
1814:                 for (int i = 1; i < args.length; i++)
1815:                 {
1816:                     String opt = args[i];
1817:                     if (opt.startsWith("s="))
1818:                     {
1819:                         try { scale = Float.parseFloat(opt.substring(2)); } catch (Exception e) { }
1820:                     }
1821:                     else if (opt.startsWith("w="))
1822:                     {
1823:                         try { textWidth = Integer.parseInt(opt.substring(2)); } catch (Exception e) { }
1824:                     }
1825:                     else if (opt.startsWith("tex="))
1826:                     {
1827:                         try { texSize = Integer.parseInt(opt.substring(4)); } catch (Exception e) { }
1828:                     }
1829:                     else if (opt.startsWith("force="))
1830:                     {
1831:                         force = "1".equals(opt.substring(6)) || "true".equalsIgnoreCase(opt.substring(6));
1832:                     }
1833:                     else if (opt.startsWith("mode="))
1834:                     {
1835:                         String mode = opt.substring(5).toLowerCase(Locale.ROOT);
1836:                         if ("gui".equals(mode))
1837:                         {
1838:                             useGui = true;
1839:                             useTest = false;
1840:                         }
1841:                         else if ("test".equals(mode))
1842:                         {
1843:                             useTest = true;
1844:                             useGui = false;
1845:                         }
1846:                         else
1847:                         {
1848:                             useTest = false;
1849:                             useGui = false;
1850:                         }
1851:                     }
1852:                     else if (opt.startsWith("font="))
1853:                     {
1854:                         String mode = opt.substring(5).toLowerCase(Locale.ROOT);
1855:                         smoothFont = !"nearest".equals(mode);
1856:                     }
1857:                 }
1858:                 chestHoloScale = scale;
1859:                 chestHoloTextWidth = textWidth;
1860:                 chestHoloTexSize = texSize;
1861:                 chestHoloForceRerender = force;
1862:                 chestHoloUseTestPipeline = useTest;
1863:                 chestHoloSmoothFont = smoothFont;
1864:                 chestHoloUseGuiRender = useGui;
1865:                 lastTestScale = scale;
1866:                 lastTestTextWidth = textWidth;
1867:                 lastTestTexSize = texSize;
1868:                 chestPreviewFbos.clear();
1869:                 chestTestHolos.clear();
1870:                 setActionBar(true, "&aChest holo set", 1500L);
1871:                 return;
1872:             }
1873:             boolean useFbo = "fbo".equals(arg);
1874:             float scale = CHEST_HOLO_SCALE;
1875:             int textWidth = CHEST_HOLO_TEXT_WIDTH;
1876:             int texSize = CHEST_HOLO_TEX_SIZE;
1877:             boolean force = chestHoloForceRerender;
1878:             boolean smoothFont = chestHoloSmoothFont;
1879:             for (int i = 1; i < args.length; i++)
1880:             {
1881:                 String opt = args[i];
1882:                 if (opt.startsWith("s="))
1883:                 {
1884:                     try { scale = Float.parseFloat(opt.substring(2)); } catch (Exception e) { }
1885:                 }
1886:                 else if (opt.startsWith("w="))
1887:                 {
1888:                     try { textWidth = Integer.parseInt(opt.substring(2)); } catch (Exception e) { }
1889:                 }
1890:                 else if (opt.startsWith("tex="))
1891:                 {
1892:                     try { texSize = Integer.parseInt(opt.substring(4)); } catch (Exception e) { }
1893:                 }
1894:                 else if (opt.startsWith("force="))
1895:                 {
1896:                     force = "1".equals(opt.substring(6)) || "true".equalsIgnoreCase(opt.substring(6));
1897:                 }
1898:                 else if (opt.startsWith("font="))
1899:                 {
1900:                     String mode = opt.substring(5).toLowerCase(Locale.ROOT);
1901:                     smoothFont = !"nearest".equals(mode);
1902:                 }
1903:             }
1904:             chestHoloScale = scale;
1905:             chestHoloTextWidth = textWidth;
1906:             chestHoloTexSize = texSize;
1907:             chestHoloForceRerender = force;
1908:             chestHoloSmoothFont = smoothFont;
1909:             chestHoloUseGuiRender = false;
1910:             lastTestScale = scale;
1911:             lastTestTextWidth = textWidth;
1912:             lastTestTexSize = texSize;
1913:             chestPreviewFbos.clear();
1914:             addTestChestHolo(mc, useFbo, scale, textWidth, texSize);
1915:         }
1916: 
1917:         @Override
1918:         public int getRequiredPermissionLevel()
1919:         {
1920:             return 0;
1921:         }
1922:     }
1923: 
1924:     private class ConfigDebugCommand extends CommandBase
1925:     {
1926:         @Override
1927:         public String getName()
1928:         {
1929:             return "mpcfg";
1930:         }
1931: 
1932:         @Override
1933:         public String getUsage(ICommandSender sender)
1934:         {
1935:             return "/mpcfg";
1936:         }
1937: 
1938:         @Override
1939:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1940:         {
1941:             File cfg = config == null ? null : config.getConfigFile();
1942:             String path = cfg == null ? "null" : cfg.getAbsolutePath();
1943:             long stamp = cfg == null ? 0L : cfg.lastModified();
1944:             setActionBar(true, "&eCfg file: " + path, 4000L);
1945:             setActionBar(false, "&eCfg hotbar=" + enableSecondHotbar + " holo=#"
1946:                 + String.format(Locale.ROOT, "%06X", chestHoloTextColor) + " t=" + stamp, 4000L);
1947:         }
1948: 
1949:         @Override
1950:         public int getRequiredPermissionLevel()
1951:         {
1952:             return 0;
1953:         }
1954:     }
1955: 
1956:     private class TestShulkerHoloCommand extends CommandBase
1957:     {
1958:         @Override
1959:         public String getName()
1960:         {
1961:             return "testshulkerholo";
1962:         }
1963: 
1964:         @Override
1965:         public String getUsage(ICommandSender sender)
1966:         {
1967:             return "/testshulkerholo set [s=0.03] [y=1.15] [z=0.0] | clear | me <text> | mefront <text> | mode [billboard|fixed] | depth [on|off] | cull [on|off] | info";
1968:         }
1969: 
1970:         @Override
1971:         public int getRequiredPermissionLevel()
1972:         {
1973:             return 0;
1974:         }
1975: 
1976:         @Override
1977:         public boolean checkPermission(MinecraftServer server, ICommandSender sender)
1978:         {
1979:             return true;
1980:         }
1981: 
1982:         @Override
1983:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
1984:         {
1985:             if (args.length == 0)
1986:             {
1987:                 setActionBar(true, "&eShulker holo s=" + shulkerHoloScale + " y=" + shulkerHoloYOffset
1988:                     + " z=" + shulkerHoloZOffset, 3000L);
1989:                 return;
1990:             }
1991:             String cmd = args[0].toLowerCase(Locale.ROOT);
1992:             if ("clear".equals(cmd))
1993:             {
1994:                 shulkerHolos.clear();
1995:                 shulkerHoloDirty = true;
1996:                 setActionBar(true, "&cShulker holos cleared", 1500L);
1997:                 return;
1998:             }
1999:             if ("info".equals(cmd))
2000:             {
2001:                 int count = shulkerHolos.size();
2002:                 StringBuilder sb = new StringBuilder();
2003:                 sb.append("Shulker holos=").append(count);
2004:                 if (count > 0)
2005:                 {
2006:                     ShulkerHolo first = shulkerHolos.values().iterator().next();
2007:                     if (first != null && first.pos != null)
2008:                     {
2009:                         sb.append(" pos=").append(first.pos.getX()).append(",")
2010:                             .append(first.pos.getY()).append(",").append(first.pos.getZ());
2011:                     }
2012:                 }
2013:                 setActionBar(true, sb.toString(), 3000L);
2014:                 return;
2015:             }
2016:             if ("me".equals(cmd))
2017:             {
2018:                 Minecraft mc = Minecraft.getMinecraft();
2019:                 if (mc == null || mc.player == null)
2020:                 {
2021:                     setActionBar(true, "&cNo player", 1500L);
2022:                     return;
2023:                 }
2024:                 if (args.length < 2)
2025:                 {
2026:                     setActionBar(true, "&cText required", 1500L);
2027:                     return;
2028:                 }
2029:                 StringBuilder sb = new StringBuilder();
2030:                 for (int i = 1; i < args.length; i++)
2031:                 {
2032:                     if (i > 1)
2033:                     {
2034:                         sb.append(' ');
2035:                     }
2036:                     sb.append(args[i]);
2037:                 }
2038:                 BlockPos pos = mc.player.getPosition().up(2);
2039:                 int dim = mc.player.dimension;
2040:                 putShulkerHolo(dim, pos, sb.toString(), 0xFFFFFF);
2041:                 setActionBar(true, "&aShulker holo me", 1500L);
2042:                 return;
2043:             }
2044:             if ("mefront".equals(cmd))
2045:             {
2046:                 Minecraft mc = Minecraft.getMinecraft();
2047:                 if (mc == null || mc.player == null)
2048:                 {
2049:                     setActionBar(true, "&cNo player", 1500L);
2050:                     return;
2051:                 }
2052:                 if (args.length < 2)
2053:                 {
2054:                     setActionBar(true, "&cText required", 1500L);
2055:                     return;
2056:                 }
2057:                 StringBuilder sb = new StringBuilder();
2058:                 for (int i = 1; i < args.length; i++)
2059:                 {
2060:                     if (i > 1)
2061:                     {
2062:                         sb.append(' ');
2063:                     }
2064:                     sb.append(args[i]);
2065:                 }
2066:                 Vec3d look = mc.player.getLookVec();
2067:                 BlockPos pos = new BlockPos(mc.player.posX + look.x * 2.0,
2068:                     mc.player.posY + look.y * 2.0 + 1.0,
2069:                     mc.player.posZ + look.z * 2.0);
2070:                 int dim = mc.player.dimension;
2071:                 putShulkerHolo(dim, pos, sb.toString(), 0xFFFFFF);
2072:                 setActionBar(true, "&aShulker holo front", 1500L);
2073:                 return;
2074:             }
2075:             if ("set".equals(cmd))
2076:             {
2077:                 for (int i = 1; i < args.length; i++)
2078:                 {
2079:                     String token = args[i];
2080:                     if (token.startsWith("s="))
2081:                     {
2082:                         shulkerHoloScale = ExampleMod.parseFloat(token.substring(2), shulkerHoloScale);
2083:                     }
2084:                     else if (token.startsWith("y="))
2085:                     {
2086:                         shulkerHoloYOffset = ExampleMod.parseDouble(token.substring(2), shulkerHoloYOffset);
2087:                     }
2088:                     else if (token.startsWith("z="))
2089:                     {
2090:                         shulkerHoloZOffset = ExampleMod.parseDouble(token.substring(2), shulkerHoloZOffset);
2091:                     }
2092:                 }
2093:                 setActionBar(true, "&aShulker holo set", 1500L);
2094:                 return;
2095:             }
2096:             if ("mode".equals(cmd))
2097:             {
2098:                 if (args.length < 2)
2099:                 {
2100:                     setActionBar(true, "&eMode=" + (shulkerHoloBillboard ? "billboard" : "fixed"), 1500L);
2101:                     return;
2102:                 }
2103:                 String mode = args[1].toLowerCase(Locale.ROOT);
2104:                 shulkerHoloBillboard = !"fixed".equals(mode);
2105:                 setActionBar(true, "&aShulker holo mode=" + (shulkerHoloBillboard ? "billboard" : "fixed"), 1500L);
2106:                 return;
2107:             }
2108:             if ("depth".equals(cmd))
2109:             {
2110:                 if (args.length < 2)
2111:                 {
2112:                     setActionBar(true, "&eDepth=" + (shulkerHoloDepth ? "on" : "off"), 1500L);
2113:                     return;
2114:                 }
2115:                 String mode = args[1].toLowerCase(Locale.ROOT);
2116:                 shulkerHoloDepth = "on".equals(mode);
2117:                 setActionBar(true, "&aShulker holo depth=" + (shulkerHoloDepth ? "on" : "off"), 1500L);
2118:                 return;
2119:             }
2120:             if ("cull".equals(cmd))
2121:             {
2122:                 if (args.length < 2)
2123:                 {
2124:                     setActionBar(true, "&eCull=" + (shulkerHoloCull ? "on" : "off"), 1500L);
2125:                     return;
2126:                 }
2127:                 String mode = args[1].toLowerCase(Locale.ROOT);
2128:                 shulkerHoloCull = "on".equals(mode);
2129:                 setActionBar(true, "&aShulker holo cull=" + (shulkerHoloCull ? "on" : "off"), 1500L);
2130:                 return;
2131:             }
2132:             setActionBar(false, "&cUnknown args", 1500L);
2133:         }
2134:     }
2135: 
2136:     private class ApiPortCommand extends CommandBase
2137:     {
2138:         @Override
2139:         public String getName()
2140:         {
2141:             return "apiport";
2142:         }
2143: 
2144:         @Override
2145:         public String getUsage(ICommandSender sender)
2146:         {
2147:             return "/apiport";
2148:         }
2149: 
2150:         @Override
2151:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2152:         {
2153:             Minecraft mc = Minecraft.getMinecraft();
2154:             if (mc != null && mc.player != null)
2155:             {
2156:                 mc.player.sendMessage(new TextComponentString("API port: " + apiPort));
2157:             }
2158:         }
2159: 
2160:         @Override
2161:         public int getRequiredPermissionLevel()
2162:         {
2163:             return 0;
2164:         }
2165:     }
2166: 
2167:     private class NoteCommand extends CommandBase
2168:     {
2169:         @Override
2170:         public String getName()
2171:         {
2172:             return "note";
2173:         }
2174: 
2175:         @Override
2176:         public String getUsage(ICommandSender sender)
2177:         {
2178:             return "/note save <text> | /note read";
2179:         }
2180: 
2181:         @Override
2182:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2183:         {
2184:             if (args.length == 0)
2185:             {
2186:                 setActionBar(true, "&e" + getUsage(sender), 3000L);
2187:                 return;
2188:             }
2189:             String sub = args[0].toLowerCase(Locale.ROOT);
2190:             if ("read".equals(sub))
2191:             {
2192:                 String text = noteText == null ? "" : noteText;
2193:                 if (text.isEmpty())
2194:                 {
2195:                     setActionBar(true, "&eNote is empty.", 2000L);
2196:                 }
2197:                 else if (sender != null)
2198:                 {
2199:                     sender.sendMessage(new TextComponentString(text));
2200:                 }
2201:                 return;
2202:             }
2203:             if ("save".equals(sub))
2204:             {
2205:                 if (args.length < 2)
2206:                 {
2207:                     setActionBar(true, "&eNote text missing.", 2000L);
2208:                     return;
2209:                 }
2210:                 StringBuilder sb = new StringBuilder();
2211:                 for (int i = 1; i < args.length; i++)
2212:                 {
2213:                     if (i > 1)
2214:                     {
2215:                         sb.append(' ');
2216:                     }
2217:                     sb.append(args[i]);
2218:                 }
2219:                 noteText = sb.toString();
2220:                 saveNote();
2221:                 setActionBar(true, "&aNote saved.", 1500L);
2222:                 return;
2223:             }
2224:             setActionBar(true, "&e" + getUsage(sender), 3000L);
2225:         }
2226: 
2227:         @Override
2228:         public int getRequiredPermissionLevel()
2229:         {
2230:             return 0;
2231:         }
2232:     }
2233: 
2234:     private class ScoreLineCommand extends CommandBase
2235:     {
2236:         @Override
2237:         public String getName()
2238:         {
2239:             return "scoreline";
2240:         }
2241: 
2242:         @Override
2243:         public String getUsage(ICommandSender sender)
2244:         {
2245:             return "/scoreline <score>";
2246:         }
2247: 
2248:         @Override
2249:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2250:         {
2251:             if (args.length < 1)
2252:             {
2253:                 setActionBar(true, "&e" + getUsage(sender), 3000L);
2254:                 return;
2255:             }
2256:             int scoreValue;
2257:             try
2258:             {
2259:                 scoreValue = Integer.parseInt(args[0]);
2260:             }
2261:             catch (NumberFormatException e)
2262:             {
2263:                 setActionBar(true, "&cInvalid score.", 2000L);
2264:                 return;
2265:             }
2266:             String line = getScoreboardLineByScore(scoreValue);
2267:             if (line == null || line.isEmpty())
2268:             {
2269:                 setActionBar(true, "&eNo line for score " + scoreValue, 2000L);
2270:                 return;
2271:             }
2272:             if (sender != null)
2273:             {
2274:                 sender.sendMessage(new TextComponentString(line));
2275:             }
2276:         }
2277: 
2278:         @Override
2279:         public int getRequiredPermissionLevel()
2280:         {
2281:             return 0;
2282:         }
2283:     }
2284: 
2285:     private class ScoreTitleCommand extends CommandBase
2286:     {
2287:         @Override
2288:         public String getName()
2289:         {
2290:             return "scoretitle";
2291:         }
2292: 
2293:         @Override
2294:         public String getUsage(ICommandSender sender)
2295:         {
2296:             return "/scoretitle";
2297:         }
2298: 
2299:         @Override
2300:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2301:         {
2302:             String title = getScoreboardTitle();
2303:             if (title == null || title.isEmpty())
2304:             {
2305:                 setActionBar(true, "&eNo scoreboard title.", 2000L);
2306:                 return;
2307:             }
2308:             if (sender != null)
2309:             {
2310:                 sender.sendMessage(new TextComponentString(title));
2311:             }
2312:         }
2313: 
2314:         @Override
2315:         public int getRequiredPermissionLevel()
2316:         {
2317:             return 0;
2318:         }
2319:     }
2320: 
2321:     private class GuiExportCommand extends CommandBase
2322:     {
2323:         @Override
2324:         public String getName()
2325:         {
2326:             return "guiexport";
2327:         }
2328: 
2329:         @Override
2330:         public String getUsage(ICommandSender sender)
2331:         {
2332:             return "/guiexport [raw|clean|both]";
2333:         }
2334: 
2335:         @Override
2336:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2337:         {
2338:             Minecraft mc = Minecraft.getMinecraft();
2339:             if (mc == null || !(mc.currentScreen instanceof GuiContainer))
2340:             {
2341:                 setActionBar(true, "&eOpen a GUI container first.", 2000L);
2342:                 return;
2343:             }
2344:             String mode = args.length > 0 ? args[0].toLowerCase(Locale.ROOT) : "both";
2345:             boolean wantRaw = "raw".equals(mode) || "both".equals(mode);
2346:             boolean wantClean = "clean".equals(mode) || "both".equals(mode);
2347:             if (!wantRaw && !wantClean)
2348:             {
2349:                 setActionBar(true, "&e" + getUsage(sender), 3000L);
2350:                 return;
2351:             }
2352:             exportGuiToClipboard((GuiContainer) mc.currentScreen, wantRaw, wantClean);
2353:         }
2354: 
2355:         @Override
2356:         public int getRequiredPermissionLevel()
2357:         {
2358:             return 0;
2359:         }
2360:     }
2361: 
2362:     private class TestTpLocalCommand extends CommandBase
2363:     {
2364:         @Override
2365:         public String getName()
2366:         {
2367:             return "testtplocal";
2368:         }
2369: 
2370:         @Override
2371:         public String getUsage(ICommandSender sender)
2372:         {
2373:             return "/testtplocal <dx> <dy> <dz>";
2374:         }
2375: 
2376:         @Override
2377:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2378:         {
2379:             Minecraft mc = Minecraft.getMinecraft();
2380:             if (mc == null || mc.player == null || mc.playerController == null)
2381:             {
2382:                 return;
2383:             }
2384:             if (!mc.playerController.isInCreativeMode()
2385:                 || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
2386:             {
2387:                 setActionBar(false, "&cCreative only.", 2000L);
2388:                 return;
2389:             }
2390:             if (args.length < 3)
2391:             {
2392:                 setActionBar(true, "&e" + getUsage(sender), 3000L);
2393:                 return;
2394:             }
2395:             double dx;
2396:             double dy;
2397:             double dz;
2398:             try
2399:             {
2400:                 dx = Double.parseDouble(args[0]);
2401:                 dy = Double.parseDouble(args[1]);
2402:                 dz = Double.parseDouble(args[2]);
2403:             }
2404:             catch (NumberFormatException e)
2405:             {
2406:                 setActionBar(true, "&cInvalid offset.", 2000L);
2407:                 return;
2408:             }
2409:             double nx = mc.player.posX + dx;
2410:             double ny = mc.player.posY + dy;
2411:             double nz = mc.player.posZ + dz;
2412:             mc.player.setPosition(nx, ny, nz);
2413:             mc.player.motionX = 0.0;
2414:             mc.player.motionY = 0.0;
2415:             mc.player.motionZ = 0.0;
2416:             setActionBar(true, "&aLocal TP: " + (int) dx + " " + (int) dy + " " + (int) dz, 1500L);
2417:         }
2418: 
2419:         @Override
2420:         public int getRequiredPermissionLevel()
2421:         {
2422:             return 0;
2423:         }
2424:     }
2425: 
2426:     private class TpPathCommand extends CommandBase
2427:     {
2428:         @Override
2429:         public String getName()
2430:         {
2431:             return "tppath";
2432:         }
2433: 
2434:         @Override
2435:         public String getUsage(ICommandSender sender)
2436:         {
2437:             return "/tppath <x> <y> <z>";
2438:         }
2439: 
2440:         @Override
2441:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2442:         {
2443:             Minecraft mc = Minecraft.getMinecraft();
2444:             if (mc == null || mc.player == null || mc.playerController == null)
2445:             {
2446:                 return;
2447:             }
2448:             if (!editorModeActive || !mc.playerController.isInCreativeMode()
2449:                 || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
2450:             {
2451:                 setActionBar(false, "&cCreative+code only.", 2000L);
2452:                 return;
2453:             }
2454:             if (args.length < 3)
2455:             {
2456:                 setActionBar(true, "&e" + getUsage(sender), 3000L);
2457:                 return;
2458:             }
2459:             double tx;
2460:             double ty;
2461:             double tz;
2462:             try
2463:             {
2464:                 tx = Double.parseDouble(args[0]);
2465:                 ty = Double.parseDouble(args[1]);
2466:                 tz = Double.parseDouble(args[2]);
2467:             }
2468:             catch (NumberFormatException e)
2469:             {
2470:                 setActionBar(true, "&cInvalid coords.", 2000L);
2471:                 return;
2472:             }
2473:             buildTpPathQueue(mc.world, mc.player.posX, mc.player.posY, mc.player.posZ, tx, ty, tz);
2474:         }
2475: 
2476:         @Override
2477:         public int getRequiredPermissionLevel()
2478:         {
2479:             return 0;
2480:         }
2481:     }
2482: 
2483:     private class SignSearchCommand extends CommandBase
2484:     {
2485:         @Override
2486:         public String getName()
2487:         {
2488:             return "tsearch";
2489:         }
2490: 
2491:         @Override
2492:         public String getUsage(ICommandSender sender)
2493:         {
2494:             return "/tsearch <text> | /tsearch clear";
2495:         }
2496: 
2497:         @Override
2498:         public void execute(MinecraftServer server, ICommandSender sender, String[] args)
2499:         {
2500:             Minecraft mc = Minecraft.getMinecraft();
2501:             if (mc == null || mc.world == null)
2502:             {
2503:                 return;
2504:             }
2505:             if (args.length == 0)
2506:             {
2507:                 setActionBar(true, "&e" + getUsage(sender), 3000L);
2508:                 return;
2509:             }
2510:             String first = args[0].toLowerCase(Locale.ROOT);
2511:             if ("clear".equals(first))
2512:             {
2513:                 signSearchQuery = null;
2514:                 signSearchMatches.clear();
2515:                 setActionBar(true, "&eSign search cleared", 2000L);
2516:                 return;
2517:             }
2518:             String query = String.join(" ", args).trim();
2519:             if (query.isEmpty())
2520:             {
2521:                 setActionBar(true, "&cText required", 2000L);
2522:                 return;
2523:             }
2524:             signSearchQuery = query.toLowerCase(Locale.ROOT);
2525:             signSearchDim = mc.world.provider.getDimension();
2526:             signSearchMatches.clear();
2527:             for (TileEntity tile : new ArrayList<>(mc.world.loadedTileEntityList))
2528:             {
2529:                 if (!(tile instanceof TileEntitySign))
2530:                 {
2531:                     continue;
2532:                 }
2533:                 TileEntitySign sign = (TileEntitySign) tile;
2534:                 if (signMatchesQuery(sign, signSearchQuery))
2535:                 {
2536:                     signSearchMatches.add(sign.getPos());
2537:                 }
2538:             }
2539:             setActionBar(true, "&aSigns: " + signSearchMatches.size(), 2000L);
2540:         }
2541: 
2542:         @Override
2543:         public int getRequiredPermissionLevel()
2544:         {
2545:             return 0;
2546:         }
2547:     }
2548: 
2549:     private void addTestChestHolo(Minecraft mc, boolean useFbo, float scale, int textWidth, int texSize)
2550:     {
2551:         BlockPos pos = new BlockPos(mc.player.posX, mc.player.posY + 1.0, mc.player.posZ);
2552:         List<ItemStack> items = new ArrayList<>();
2553:         for (int i = 0; i < 54; i++)
2554:         {
2555:             items.add(new ItemStack(Blocks.DIRT, 64));
2556:         }
2557:         ChestCache cache = new ChestCache(mc.world.provider.getDimension(), pos, items, System.currentTimeMillis(),
2558:             CHEST_HOLO_LABEL);
2559:         TestChestHolo holo = new TestChestHolo(pos, cache, useFbo, scale, textWidth, texSize);
2560:         testChestHolos.add(holo);
2561:         setActionBar(true, useFbo ? "&aChest holo FBO" : "&aChest holo GUI", 1500L);
2562:     }
2563: 
2564:     private static int[] parseRange(String text)
2565:     {
2566:         String[] parts = text.split("-");
2567:         if (parts.length != 2) return null;
2568:         try
2569:         {
2570:             int start = Integer.parseInt(parts[0].trim());
2571:             int end = Integer.parseInt(parts[1].trim());
2572:             if (end < start) return null;
2573:             return new int[]{start, end};
2574:         }
2575:         catch (NumberFormatException e)
2576:         {
2577:             return null;
2578:         }
2579:     }
2580: 
2581:     private static void setActionBar(boolean primary, String text, long durationMs)
2582:     {
2583:         String formatted = applyColorCodes(text);
2584:         long until = System.currentTimeMillis() + Math.max(0, durationMs);
2585:         if (primary)
2586:         {
2587:             actionBarText = formatted;
2588:             actionBarExpireMs = until;
2589:         }
2590:         else
2591:         {
2592:             actionBar2Text = formatted;
2593:             actionBar2ExpireMs = until;
2594:         }
2595:     }
2596: 
2597:     private static String applyColorCodes(String text)
2598:     {
2599:         return text == null ? "" : text.replace("&", "\u00a7");
2600:     }
2601: 
2602:     private static int parseHexColor(String text, int fallback)
2603:     {
2604:         if (text == null)
2605:         {
2606:             return fallback;
2607:         }
2608:         String clean = text.trim();
2609:         if (clean.isEmpty())
2610:         {
2611:             return fallback;
2612:         }
2613:         if (!clean.startsWith("#") && clean.length() <= 6)
2614:         {
2615:             clean = "#" + clean;
2616:         }
2617:         try
2618:         {
2619:             return Integer.decode(clean);
2620:         }
2621:         catch (NumberFormatException e)
2622:         {
2623:             return fallback;
2624:         }
2625:     }
2626: 
2627:     private static List<String> extractPageTexts(Map<String, String> params)
2628:     {
2629:         List<Integer> indexes = new ArrayList<>();
2630:         for (String key : params.keySet())
2631:         {
2632:             if (key.startsWith("p"))
2633:             {
2634:                 try
2635:                 {
2636:                     int idx = Integer.parseInt(key.substring(1));
2637:                     if (idx >= 1 && idx <= 200)
2638:                     {
2639:                         indexes.add(idx);
2640:                     }
2641:                 }
2642:                 catch (NumberFormatException ignored)
2643:                 {
2644:                     // ignore
2645:                 }
2646:             }
2647:         }
2648:         if (indexes.isEmpty())
2649:         {
2650:             return Collections.emptyList();
2651:         }
2652:         Collections.sort(indexes);
2653:         int max = indexes.get(indexes.size() - 1);
2654:         List<String> pages = new ArrayList<>(Collections.nCopies(max, ""));
2655:         for (int idx : indexes)
2656:         {
2657:             String value = params.get("p" + idx);
2658:             pages.set(idx - 1, value == null ? "" : value);
2659:         }
2660:         return pages;
2661:     }
2662: 
2663:     private String getClientBlockReason()
2664:     {
2665:         Minecraft mc = Minecraft.getMinecraft();
2666:         if (mc != null && mc.currentScreen instanceof GuiChat)
2667:         {
2668:             return "chat_open";
2669:         }
2670:         long now = System.currentTimeMillis();
2671:         if (lastApiChatSentMs > 0 && now - lastApiChatSentMs < CLIENT_CHAT_COOLDOWN_MS)
2672:         {
2673:             return "chat_cooldown";
2674:         }
2675:         return null;
2676:     }
2677: 
2678:     private void initHotbarStorage()
2679:     {
2680:         for (int s = 0; s < hotbarSets.length; s++)
2681:         {
2682:             for (int i = 0; i < hotbarSets[s].length; i++)
2683:             {
2684:                 hotbarSets[s][i] = ItemStack.EMPTY;
2685:             }
2686:         }
2687:     }
2688: 
2689:     public static Configuration getConfig()
2690:     {
2691:         return config;
2692:     }
2693: 
2694:     private void initHotbarsForWorld(Minecraft mc)
2695:     {
2696:         activeHotbarSet = 0;
2697:         clearHotbarSet(1);
2698:         saveCurrentHotbar(mc, 0);
2699:         long now = System.currentTimeMillis();
2700:         boolean keepDev = pendingDev || (now - lastDevCommandMs <= EDITOR_MODE_GRACE_MS);
2701:         if (!keepDev)
2702:         {
2703:             editorModeActive = false;
2704:             editorModeWasActive = false;
2705:         }
2706:         menuCache.clear();
2707:         customMenuCache = null;
2708:         chestCaches.clear();
2709:         pendingCacheKey = null;
2710:         fakeMenuActive = false;
2711:         fakeMenuKey = null;
2712:         awaitingCacheSnapshot = false;
2713:         queuedClicks.clear();
2714:         typePickerActive = false;
2715:         quickApplyWindowId = -1;
2716:         quickApplySlotNumber = -1;
2717:         setInputActive(false);
2718:         signSearchQuery = null;
2719:         signSearchMatches.clear();
2720:         for (int i = 0; i < lastHotbarTapMs.length; i++)
2721:         {
2722:             lastHotbarTapMs[i] = 0L;
2723:             hotbarKeyDown[i] = false;
2724:         }
2725:     }
2726: 
2727:     private void clearHotbarSet(int setIndex)
2728:     {
2729:         for (int i = 0; i < 9; i++)
2730:         {
2731:             hotbarSets[setIndex][i] = ItemStack.EMPTY;
2732:         }
2733:     }
2734: 
2735:     private void saveCurrentHotbar(Minecraft mc, int setIndex)
2736:     {
2737:         if (mc == null || mc.player == null)
2738:         {
2739:             return;
2740:         }
2741:         for (int i = 0; i < 9; i++)
2742:         {
2743:             ItemStack stack = mc.player.inventory.getStackInSlot(i);
2744:             hotbarSets[setIndex][i] = stack.isEmpty() ? ItemStack.EMPTY : stack.copy();
2745:         }
2746:     }
2747: 
2748:     private void loadHotbar(Minecraft mc, int setIndex)
2749:     {
2750:         if (mc == null || mc.player == null)
2751:         {
2752:             return;
2753:         }
2754:         for (int i = 0; i < 9; i++)
2755:         {
2756:             ItemStack stack = hotbarSets[setIndex][i];
2757:             ItemStack target = stack.isEmpty() ? ItemStack.EMPTY : stack.copy();
2758:             mc.player.inventory.setInventorySlotContents(i, target);
2759:             sendCreativeSlotUpdate(mc, i, target);
2760:         }
2761:         mc.player.inventory.markDirty();
2762:     }
2763: 
2764:     private void sendCreativeSlotUpdate(Minecraft mc, int inventoryIndex, ItemStack stack)
2765:     {
2766:         if (mc == null || mc.getConnection() == null || mc.player == null)
2767:         {
2768:             return;
2769:         }
2770:         int size = mc.player.inventory.getSizeInventory();
2771:         if (inventoryIndex < 0 || inventoryIndex >= size)
2772:         {
2773:             return;
2774:         }
2775:         if (mc.playerController == null || !mc.playerController.isInCreativeMode())
2776:         {
2777:             return;
2778:         }
2779:         int slotId = inventoryIndex < 9 ? 36 + inventoryIndex : inventoryIndex;
2780:         mc.getConnection().sendPacket(new CPacketCreativeInventoryAction(slotId, stack));
2781:     }
2782: 
2783:     private ItemStack copyStackForGive(ItemStack stack)
2784:     {
2785:         if (stack == null || stack.isEmpty())
2786:         {
2787:             return ItemStack.EMPTY;
2788:         }
2789:         ItemStack copy = stack.copy();
2790:         copy.setCount(1);
2791:         if (stack.hasTagCompound())
2792:         {
2793:             copy.setTagCompound(stack.getTagCompound().copy());
2794:         }
2795:         if (stack.hasDisplayName())
2796:         {
2797:             copy.setStackDisplayName(stack.getDisplayName());
2798:         }
2799:         return copy;
2800:     }
2801: 
2802:     private void handleHotbarSwap(Minecraft mc)
2803:     {
2804:         if (mc == null || mc.gameSettings == null)
2805:         {
2806:             return;
2807:         }
2808:         if (mc.player == null || mc.playerController == null)
2809:         {
2810:             return;
2811:         }
2812:         if (!mc.playerController.isInCreativeMode() || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
2813:         {
2814:             return;
2815:         }
2816:         if (!enableSecondHotbar)
2817:         {
2818:             if (activeHotbarSet != 0)
2819:             {
2820:                 activeHotbarSet = 0;
2821:                 loadHotbar(mc, activeHotbarSet);
2822:             }
2823:             for (int i = 0; i < 9; i++)
2824:             {
2825:                 hotbarKeyDown[i] = false;
2826:                 lastHotbarTapMs[i] = 0L;
2827:             }
2828:             return;
2829:         }
2830: 
2831:         for (int i = 0; i < 9; i++)
2832:         {
2833:             boolean down = mc.gameSettings.keyBindsHotbar[i].isKeyDown();
2834:             if (down && !hotbarKeyDown[i])
2835:             {
2836:                 long now = System.currentTimeMillis();
2837:                 if (now - lastHotbarTapMs[i] <= HOTBAR_DOUBLE_TAP_MS)
2838:                 {
2839:                     saveCurrentHotbar(mc, activeHotbarSet);
2840:                     activeHotbarSet = 1 - activeHotbarSet;
2841:                     loadHotbar(mc, activeHotbarSet);
2842:                     lastHotbarTapMs[i] = 0L;
2843:                 }
2844:                 else
2845:                 {
2846:                     lastHotbarTapMs[i] = now;
2847:                 }
2848:             }
2849:             hotbarKeyDown[i] = down;
2850:         }
2851:     }
2852: 
2853:     @SubscribeEvent
2854:     public void onGuiMouseInput(GuiScreenEvent.MouseInputEvent.Pre event)
2855:     {
2856:         GuiScreen gui = event.getGui();
2857:         if (!(gui instanceof GuiContainer))
2858:         {
2859:             return;
2860:         }
2861:         Minecraft mc = Minecraft.getMinecraft();
2862:         int mouseX = getScaledMouseX(mc, gui);
2863:         int mouseY = getScaledMouseY(mc, gui);
2864:         if (inputActive)
2865:         {
2866:             if (Mouse.getEventButtonState())
2867:             {
2868:                 if (handleSidePanelClick((GuiContainer) gui, mouseX, mouseY))
2869:                 {
2870:                     event.setCanceled(true);
2871:                     return;
2872:                 }
2873:                 if (inputMode == INPUT_MODE_VARIABLE && handleVariableButtonClick(mouseX, mouseY, (GuiContainer) gui))
2874:                 {
2875:                     event.setCanceled(true);
2876:                     return;
2877:                 }
2878:                 if (inputMode == INPUT_MODE_VARIABLE && isSaveVariableButtonClicked(mouseX, mouseY, gui))
2879:                 {
2880:                     toggleVariableSavedState();
2881:                     event.setCanceled(true);
2882:                     return;
2883:                 }
2884:                 if (inputMode == INPUT_MODE_ARRAY && isSaveButtonClicked(mouseX, mouseY, gui))
2885:                 {
2886:                     appendArrayMark();
2887:                     event.setCanceled(true);
2888:                     return;
2889:                 }
2890:                 if (isShiftDown() && handleVariableInsertFromSlot((GuiContainer) gui))
2891:                 {
2892:                     event.setCanceled(true);
2893:                     return;
2894:                 }
2895:                 ensureInputField();
2896:                 if (inputField != null)
2897:                 {
2898:                     inputField.mouseClicked(mouseX, mouseY, Mouse.getEventButton());
2899:                 }
2900:                 event.setCanceled(true);
2901:             }
2902:             return;
2903:         }
2904:         if (Mouse.getEventButtonState() && handleSidePanelClick((GuiContainer) gui, mouseX, mouseY))
2905:         {
2906:             event.setCanceled(true);
2907:             return;
2908:         }
2909:         if (codeMenuActive && isCodeMenuScreen(gui))
2910:         {
2911:             if (Mouse.getEventButtonState())
2912:             {
2913:                 handleCodeMenuClick((GuiContainer) gui);
2914:                 event.setCanceled(true);
2915:             }
2916:             return;
2917:         }
2918:         if (Mouse.getEventButtonState() && Mouse.getEventButton() == 1
2919:             && (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT))
2920:             && editorModeActive && mc != null && mc.playerController != null
2921:             && mc.playerController.isInCreativeMode()
2922:             && mc.playerController.getCurrentGameType() == GameType.CREATIVE)
2923:         {
2924:             if (handleShiftEditClick((GuiContainer) gui))
2925:             {
2926:                 event.setCanceled(true);
2927:                 return;
2928:             }
2929:         }
2930:         if (fakeMenuActive)
2931:         {
2932:             if (Mouse.getEventButtonState())
2933:             {
2934:                 event.setCanceled(true);
2935:             }
2936:             return;
2937:         }
2938:         if (!editorModeActive || mc == null || mc.playerController == null
2939:             || !mc.playerController.isInCreativeMode()
2940:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
2941:         {
2942:             return;
2943:         }
2944:         if (!Mouse.getEventButtonState() || Mouse.getEventButton() != 0)
2945:         {
2946:             return;
2947:         }
2948: 
2949:         GuiContainer container = (GuiContainer) gui;
2950:         Slot hovered = getSlotUnderMouse(container);
2951:         if (hovered == null || !hovered.getHasStack())
2952:         {
2953:             return;
2954:         }
2955: 
2956:         ItemStack hoveredStack = hovered.getStack();
2957:         if (isTextGlassPane(hoveredStack))
2958:         {
2959:             if (handleGlassClick(container, hovered, hoveredStack, Items.BOOK, INPUT_MODE_TEXT))
2960:             {
2961:                 event.setCanceled(true);
2962:             }
2963:             return;
2964:         }
2965: 
2966:         if (isNumberGlassPane(hoveredStack))
2967:         {
2968:             if (handleGlassClick(container, hovered, hoveredStack, Items.SLIME_BALL, INPUT_MODE_NUMBER))
2969:             {
2970:                 event.setCanceled(true);
2971:             }
2972:             return;
2973:         }
2974: 
2975:         if (isLocationGlassPane(hoveredStack))
2976:         {
2977:             if (handleGlassClick(container, hovered, hoveredStack, Items.PAPER, INPUT_MODE_LOCATION))
2978:             {
2979:                 event.setCanceled(true);
2980:             }
2981:             return;
2982:         }
2983: 
2984:         if (isVariableGlassPane(hoveredStack))
2985:         {
2986:             if (handleGlassClick(container, hovered, hoveredStack, Items.MAGMA_CREAM, INPUT_MODE_VARIABLE))
2987:             {
2988:                 event.setCanceled(true);
2989:             }
2990:             return;
2991:         }
2992: 
2993:         if (isArrayGlassPane(hoveredStack))
2994:         {
2995:             if (handleGlassClick(container, hovered, hoveredStack, Items.ITEM_FRAME, INPUT_MODE_ARRAY))
2996:             {
2997:                 event.setCanceled(true);
2998:             }
2999:         }
3000:     }
3001: 
3002:     @SubscribeEvent
3003:     public void onGuiKeyInput(GuiScreenEvent.KeyboardInputEvent.Pre event)
3004:     {
3005:         if (!inputActive)
3006:         {
3007:             handleCopyPaste(event);
3008:         }
3009:         if (!inputActive)
3010:         {
3011:             return;
3012:         }
3013:         GuiScreen gui = event.getGui();
3014:         if (!(gui instanceof GuiContainer))
3015:         {
3016:             setInputActive(false);
3017:             return;
3018:         }
3019: 
3020:         if (!Keyboard.getEventKeyState())
3021:         {
3022:             return;
3023:         }
3024:         int key = Keyboard.getEventKey();
3025:         char ch = Keyboard.getEventCharacter();
3026: 
3027:         if (key == Keyboard.KEY_ESCAPE)
3028:         {
3029:             setInputActive(false);
3030:             event.setCanceled(true);
3031:             return;
3032:         }
3033:         if (key == Keyboard.KEY_RETURN || key == Keyboard.KEY_NUMPADENTER)
3034:         {
3035:             boolean giveExtra = Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT);
3036:             submitInputText(giveExtra);
3037:             event.setCanceled(true);
3038:             return;
3039:         }
3040:         if (key == Keyboard.KEY_TAB)
3041:         {
3042:             if (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT))
3043:             {
3044:                 submitInputText(false);
3045:             }
3046:             else
3047:             {
3048:                 applySuggestion();
3049:             }
3050:             event.setCanceled(true);
3051:             return;
3052:         }
3053: 
3054:         ensureInputField();
3055:         if (inputField != null)
3056:         {
3057:             inputField.textboxKeyTyped(ch, key);
3058:             if (inputMode == INPUT_MODE_NUMBER)
3059:             {
3060:                 inputField.setText(filterNumber(inputField.getText()));
3061:                 inputField.setCursorPositionEnd();
3062:             }
3063:             event.setCanceled(true);
3064:         }
3065:     }
3066: 
3067:     @SubscribeEvent
3068:     public void onGuiDraw(GuiScreenEvent.DrawScreenEvent.Post event)
3069:     {
3070:         Minecraft mc = Minecraft.getMinecraft();
3071:         if (mc == null || mc.fontRenderer == null)
3072:         {
3073:             return;
3074:         }
3075:         GuiScreen gui = event.getGui();
3076:         if (!(gui instanceof GuiContainer))
3077:         {
3078:             return;
3079:         }
3080: 
3081:         GlStateManager.disableLighting();
3082:         GlStateManager.disableDepth();
3083:         GlStateManager.enableBlend();
3084:         GlStateManager.color(1f, 1f, 1f, 1f);
3085: 
3086:         if (editorModeActive && mc.playerController != null && mc.playerController.isInCreativeMode()
3087:             && mc.playerController.getCurrentGameType() == GameType.CREATIVE)
3088:         {
3089:             drawSidePanels((GuiContainer) gui, event.getMouseX(), event.getMouseY());
3090:         }
3091: 
3092:         if (!inputActive)
3093:         {
3094:             GlStateManager.enableDepth();
3095:             return;
3096:         }
3097: 
3098:         int width = event.getGui().width;
3099:         int height = event.getGui().height;
3100:         int boxWidth = Math.min(300, width - 40);
3101:         int boxHeight = 56;
3102:         int x1 = (width - boxWidth) / 2;
3103:         int y1 = height - 86;
3104:         int x2 = x1 + boxWidth;
3105:         int y2 = y1 + boxHeight;
3106:         net.minecraft.client.gui.Gui.drawRect(x1, y1, x2, y2, 0xAA000000);
3107:         String title = inputTitle == null || inputTitle.isEmpty() ? "Input" : inputTitle;
3108:         ensureInputField();
3109:         if (inputField != null)
3110:         {
3111:             inputField.x = x1 + 6;
3112:             inputField.y = y1 + 18;
3113:             inputField.width = boxWidth - 12;
3114:             inputField.height = 12;
3115:             inputField.setEnableBackgroundDrawing(false);
3116:             inputField.drawTextBox();
3117:         }
3118:         String rawLine = getInputText();
3119:         String preview;
3120:         if (inputMode == INPUT_MODE_NUMBER)
3121:         {
3122:             preview = applyColorCodes("&c" + rawLine);
3123:         }
3124:         else if (inputMode == INPUT_MODE_LOCATION)
3125:         {
3126:             preview = applyColorCodes("&b" + rawLine);
3127:         }
3128:         else if (inputMode == INPUT_MODE_VARIABLE || inputMode == INPUT_MODE_ARRAY)
3129:         {
3130:             preview = applyColorCodes("&r" + normalizePlainName(rawLine));
3131:         }
3132:         else
3133:         {
3134:             preview = applyColorCodes(rawLine);
3135:         }
3136:         mc.fontRenderer.drawStringWithShadow("\u00a7f\u00a7l" + title, x1 + 6, y1 + 6, 0xFFFFFF);
3137:         mc.fontRenderer.drawStringWithShadow(preview, x1 + 6, y1 + 30, 0xFFFFFF);
3138:         drawSuggestion(mc, rawLine, x1 + 6, y1 + 18);
3139:         if (inputMode == INPUT_MODE_ARRAY)
3140:         {
3141:             drawSaveButton(mc, x2 - 48, y1 + 6);
3142:         }
3143:         if (inputMode == INPUT_MODE_VARIABLE)
3144:         {
3145:             drawSaveButton(mc, x2 - 48, y1 + 6);
3146:             drawVariableButtons(mc, x1, y1, boxWidth);
3147:         }
3148:         GlStateManager.enableDepth();
3149:     }
3150: 
3151:     @SubscribeEvent
3152:     public void onGuiOpen(GuiOpenEvent event)
3153:     {
3154:         GuiScreen gui = event.getGui();
3155:         if (gui == null)
3156:         {
3157:             if (allowChestSnapshot && lastClickedChest)
3158:             {
3159:                 long now = System.currentTimeMillis();
3160:                 pendingChestSnapshot = true;
3161:                 pendingChestUntilMs = now + 1000L;
3162:                 lastClickedMs = now;
3163:                 if (allowChestUntilMs < now + 1500L)
3164:                 {
3165:                     allowChestUntilMs = now + 1500L;
3166:                 }
3167:             }
3168:             return;
3169:         }
3170:         if (gui instanceof GuiDisconnected)
3171:         {
3172:             saveEntriesIfNeeded();
3173:             saveMenuCacheIfNeeded();
3174:             saveChestIdCachesIfNeeded();
3175:             editorModeActive = false;
3176:             editorModeWasActive = false;
3177:             codeMenuActive = false;
3178:             codeMenuInventory = null;
3179:             setInputActive(false);
3180:             menuCache.clear();
3181:             customMenuCache = null;
3182:             clearEntryCaches();
3183:             chestCaches.clear();
3184:             pendingCacheKey = null;
3185:             fakeMenuActive = false;
3186:             fakeMenuKey = null;
3187:             awaitingCacheSnapshot = false;
3188:             queuedClicks.clear();
3189:             return;
3190:         }
3191:         if (gui instanceof GuiContainer)
3192:         {
3193:             boolean shouldSnapshot = false;
3194:             boolean isPlayerInventory = gui instanceof GuiInventory;
3195:             if (gui instanceof GuiChest)
3196:             {
3197:                 if (allowChestSnapshot && lastClickedPos == null)
3198:                 {
3199:                     BlockPos targetPos = getTargetedBlockPos();
3200:                     if (targetPos != null)
3201:                     {
3202:                         lastClickedPos = targetPos;
3203:                         lastClickedDim = Minecraft.getMinecraft().world.provider.getDimension();
3204:                         lastClickedLabel = getChestLabel(Minecraft.getMinecraft().world, targetPos);
3205:                         lastClickedMs = System.currentTimeMillis();
3206:                     }
3207:                 }
3208:                 if (!pendingChestSnapshot && !lastClickedIsSign && lastClickedChest && allowChestSnapshot)
3209:                 {
3210:                     pendingChestSnapshot = true;
3211:                     pendingChestUntilMs = System.currentTimeMillis() + 5000L;
3212:                 }
3213:             }
3214:             if (pendingCacheKey != null && System.currentTimeMillis() - pendingCacheMs <= MENU_CACHE_ARM_MS)
3215:             {
3216:                 shouldSnapshot = true;
3217:             }
3218:             if (captureCustomMenuArmed)
3219:             {
3220:                 captureCustomMenuNow = true;
3221:                 shouldSnapshot = true;
3222:             }
3223:             if (!shouldSnapshot && editorModeActive && gui instanceof GuiChest && lastClickedChest && allowChestSnapshot)
3224:             {
3225:                 shouldSnapshot = true;
3226:             }
3227:             if (!shouldSnapshot && lastClickedPos != null && lastClickedChest && allowChestSnapshot && !isPlayerInventory
3228:                 && System.currentTimeMillis() - lastClickedMs < 5000L)
3229:             {
3230:                 shouldSnapshot = true;
3231:             }
3232:             awaitingCacheSnapshot = shouldSnapshot;
3233:             if (shouldSnapshot)
3234:             {
3235:                 cacheOpenTicks = 0;
3236:             }
3237:             if (editorModeActive && gui instanceof GuiChest)
3238:             {
3239:                 scanChestEntries((GuiChest) gui);
3240:             }
3241:             if (gui instanceof GuiShulkerBox || gui.getClass().getSimpleName().toLowerCase(Locale.ROOT).contains("shulker"))
3242:             {
3243:                 Minecraft mc = Minecraft.getMinecraft();
3244:                 if (mc != null && mc.player != null && mc.player.isSneaking())
3245:                 {
3246:                     pendingShulkerEdit = true;
3247:                     pendingShulkerUntilMs = System.currentTimeMillis() + 5000L;
3248:                     if (pendingShulkerPos == null)
3249:                     {
3250:                         pendingShulkerPos = lastClickedPos;
3251:                         pendingShulkerDim = lastClickedDim;
3252:                     }
3253:                 }
3254:                 if (pendingShulkerEdit)
3255:                 {
3256:                     handlePendingShulkerEdit((GuiContainer) gui);
3257:                 }
3258:             }
3259:         }
3260:         else
3261:         {
3262:             awaitingCacheSnapshot = false;
3263:         }
3264:     }
3265: 
3266:     @SubscribeEvent
3267:     public void onRightClickBlock(PlayerInteractEvent.RightClickBlock event)
3268:     {
3269:         if (!event.getWorld().isRemote)
3270:         {
3271:             return;
3272:         }
3273:         if (event.getHand() != EnumHand.MAIN_HAND)
3274:         {
3275:             return;
3276:         }
3277:         Minecraft mc = Minecraft.getMinecraft();
3278:         if (mc != null && mc.player != null)
3279:         {
3280:             ItemStack heldEarly = mc.player.getHeldItemMainhand();
3281:             ItemStack heldOff = mc.player.getHeldItemOffhand();
3282:             if ((!heldEarly.isEmpty() && heldEarly.getItem() == Items.ARROW)
3283:                 || (!heldOff.isEmpty() && heldOff.getItem() == Items.ARROW))
3284:             {
3285:                 pendingCacheKey = null;
3286:                 cachePathRoot = null;
3287:                 captureCustomMenuArmed = false;
3288:                 return;
3289:             }
3290:         }
3291:         if (editorModeActive && event.getEntityPlayer() != null && event.getEntityPlayer().isSneaking())
3292:         {
3293:             Block block = event.getWorld().getBlockState(event.getPos()).getBlock();
3294:             TileEntity tile = event.getWorld().getTileEntity(event.getPos());
3295:             if (block instanceof BlockShulkerBox || tile instanceof TileEntityShulkerBox)
3296:             {
3297:                 pendingShulkerEdit = true;
3298:                 pendingShulkerUntilMs = System.currentTimeMillis() + 5000L;
3299:                 pendingShulkerPos = event.getPos();
3300:                 pendingShulkerDim = event.getWorld().provider.getDimension();
3301:                 pendingShulkerColor = getShulkerColor(event.getWorld(), event.getPos(), tile);
3302:                 setActionBar(true, "&eShulker edit armed", 1500L);
3303:             }
3304:         }
3305:         if (editorModeActive && event.getEntityPlayer() != null && event.getEntityPlayer().world != null)
3306:         {
3307:             ensureBlueGlassCached(event.getEntityPlayer().world);
3308:             ItemStack held = event.getEntityPlayer().getHeldItem(event.getHand());
3309:             if (!held.isEmpty() && held.getItem() instanceof net.minecraft.item.ItemBlock)
3310:             {
3311:                 BlockPos placePos = event.getPos().offset(event.getFace());
3312:                 updateBlueGlassFromPlacement(event.getWorld(), placePos);
3313:             }
3314:         }
3315:         lastClickedPos = event.getPos();
3316:         lastClickedDim = event.getWorld().provider.getDimension();
3317:         lastClickedMs = System.currentTimeMillis();
3318:         Block clickedBlock = event.getWorld().getBlockState(event.getPos()).getBlock();
3319:         TileEntity clickedTile = event.getWorld().getTileEntity(event.getPos());
3320:         boolean isInventory = clickedTile instanceof net.minecraft.inventory.IInventory;
3321:         lastClickedChest = isInventory || clickedBlock == Blocks.CHEST || clickedBlock == Blocks.TRAPPED_CHEST;
3322:         allowChestSnapshot = lastClickedChest;
3323:         if (allowChestSnapshot)
3324:         {
3325:             allowChestUntilMs = System.currentTimeMillis() + 5000L;
3326:             String id = getScoreboardIdLine();
3327:             if (id != null && !id.isEmpty())
3328:             {
3329:                 String idKey = chestIdKey(id, lastClickedDim, lastClickedPos);
3330:                 ChestCache cached = idKey == null ? null : chestIdCaches.get(idKey);
3331:                 if (cached != null)
3332:                 {
3333:                     List<ItemStack> copy = new ArrayList<>();
3334:                     for (ItemStack stack : cached.items)
3335:                     {
3336:                         copy.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
3337:                     }
3338:                     chestCaches.put(chestKey(lastClickedDim, lastClickedPos),
3339:                         new ChestCache(lastClickedDim, lastClickedPos, copy, System.currentTimeMillis(),
3340:                             cached.label));
3341:                 }
3342:             }
3343:         }
3344:         lastClickedLabel = getChestLabel(event.getWorld(), event.getPos());
3345:         lastClickedIsSign = clickedTile instanceof TileEntitySign;
3346:         if (lastClickedIsSign)
3347:         {
3348:             pendingChestSnapshot = false;
3349:             lastClickedChest = false;
3350:             allowChestSnapshot = false;
3351:         }
3352:         if (!lastClickedChest)
3353:         {
3354:             pendingChestSnapshot = false;
3355:             allowChestSnapshot = false;
3356:         }
3357:         if (lastClickedChest)
3358:         {
3359:             pendingChestSnapshot = true;
3360:             pendingChestUntilMs = System.currentTimeMillis() + 5000L;
3361:         }
3362:         if (!editorModeActive && chestCaches.isEmpty() && testChestHolos.isEmpty() && !testHoloActive)
3363:         {
3364:             return;
3365:         }
3366:         if (mc != null && mc.player != null && mc.playerController != null)
3367:         {
3368:             if (!mc.playerController.isInCreativeMode()
3369:                 || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3370:             {
3371:                 return;
3372:             }
3373:             ItemStack held = mc.player.getHeldItemMainhand();
3374:             if (!held.isEmpty() && (held.getItem() == Items.IRON_INGOT || held.getItem() == Items.GOLD_INGOT))
3375:             {
3376:                 pendingChestSnapshot = false;
3377:                 lastClickedChest = false;
3378:                 allowChestSnapshot = false;
3379:                 lastClickedPos = null;
3380:                 lastClickedLabel = null;
3381:             }
3382:             if (!held.isEmpty() && held.getItem() == Items.REPEATER)
3383:             {
3384:                 captureCustomMenuArmed = false;
3385:                 captureCustomMenuNow = false;
3386:                 pendingCacheKey = null;
3387:                 cachePathRoot = null;
3388:                 return;
3389:             }
3390:             if (!held.isEmpty() && held.getItem() == Items.IRON_INGOT)
3391:             {
3392:                 captureCustomMenuArmed = true;
3393:                 setActionBar(true, "&eCache next menu...", 2000L);
3394:                 return;
3395:             }
3396:             if (!held.isEmpty() && held.getItem() == Items.GOLD_INGOT)
3397:             {
3398:                 return;
3399:             }
3400:             if (!held.isEmpty() && held.getItem() == Items.ARROW)
3401:             {
3402:                 pendingCacheKey = null;
3403:                 return;
3404:             }
3405:         }
3406:         TileEntity tile = event.getWorld().getTileEntity(event.getPos());
3407:         if (!(tile instanceof TileEntitySign))
3408:         {
3409:             return;
3410:         }
3411:         TileEntitySign sign = (TileEntitySign) tile;
3412:         Minecraft mc2 = Minecraft.getMinecraft();
3413:         boolean shift = mc2 != null && mc2.player != null && mc2.player.isSneaking();
3414:         if (mc2 != null && mc2.player != null)
3415:         {
3416:             ItemStack held2 = mc2.player.getHeldItemMainhand();
3417:             ItemStack heldOff2 = mc2.player.getHeldItemOffhand();
3418:             if ((!held2.isEmpty() && held2.getItem() == Items.ARROW)
3419:                 || (!heldOff2.isEmpty() && heldOff2.getItem() == Items.ARROW))
3420:             {
3421:                 pendingCacheKey = null;
3422:                 cachePathRoot = null;
3423:                 return;
3424:             }
3425:         }
3426:         String key = shift ? "__SHIFT_SIGN__" : sign.signText[0].getUnformattedText();
3427:         if (key == null)
3428:         {
3429:             return;
3430:         }
3431:         key = key.trim();
3432:         if (key.isEmpty())
3433:         {
3434:             return;
3435:         }
3436:         cachePathRoot = key;
3437:         pendingCacheKey = key;
3438:         pendingCacheMs = System.currentTimeMillis();
3439:         CachedMenu cached = menuCache.get(key);
3440:         if (cached != null)
3441:         {
3442:             openFakeMenuFromCache(key, cached);
3443:         }
3444:     }
3445: 
3446:     @SubscribeEvent
3447:     public void onRightClickItem(PlayerInteractEvent.RightClickItem event)
3448:     {
3449:         if (!event.getWorld().isRemote)
3450:         {
3451:             return;
3452:         }
3453:         if (event.getHand() != EnumHand.MAIN_HAND)
3454:         {
3455:             return;
3456:         }
3457:         if (!editorModeActive)
3458:         {
3459:             return;
3460:         }
3461:         Minecraft mc = Minecraft.getMinecraft();
3462:         if (mc != null && mc.player != null && mc.playerController != null)
3463:         {
3464:             if (!mc.playerController.isInCreativeMode()
3465:                 || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3466:             {
3467:                 return;
3468:             }
3469:             ItemStack held = mc.player.getHeldItemMainhand();
3470:             if (!held.isEmpty() && held.getItem() == Items.IRON_INGOT)
3471:             {
3472:                 captureCustomMenuArmed = true;
3473:                 setActionBar(true, "&eCache next menu...", 2000L);
3474:             }
3475:         }
3476:     }
3477: 
3478:     @SubscribeEvent
3479:     public void onLeftClickBlock(PlayerInteractEvent.LeftClickBlock event)
3480:     {
3481:         if (!event.getWorld().isRemote)
3482:         {
3483:             return;
3484:         }
3485:         BlockPos pos = event.getPos();
3486:         clearChestCacheAt(pos);
3487:         clearChestCacheAt(pos.up());
3488:         clearChestCacheAt(pos.up().south());
3489:         clearChestCacheAt(pos.up().north());
3490:         clearChestCacheAt(pos.up().east());
3491:         clearChestCacheAt(pos.up().west());
3492:     }
3493: 
3494:     private void handleMenuCacheTick(Minecraft mc)
3495:     {
3496:         if (mc == null)
3497:         {
3498:             return;
3499:         }
3500:         if (mc.currentScreen == null)
3501:         {
3502:             if (fakeMenuActive)
3503:             {
3504:                 fakeMenuActive = false;
3505:                 fakeMenuKey = null;
3506:                 queuedClicks.clear();
3507:             }
3508:             typePickerActive = false;
3509:             if (codeMenuActive)
3510:             {
3511:                 codeMenuActive = false;
3512:                 codeMenuInventory = null;
3513:             }
3514:             return;
3515:         }
3516:         if (!(mc.currentScreen instanceof GuiContainer))
3517:         {
3518:             if (fakeMenuActive)
3519:             {
3520:                 fakeMenuActive = false;
3521:                 fakeMenuKey = null;
3522:                 queuedClicks.clear();
3523:             }
3524:             typePickerActive = false;
3525:             if (codeMenuActive)
3526:             {
3527:                 codeMenuActive = false;
3528:                 codeMenuInventory = null;
3529:             }
3530:             return;
3531:         }
3532:         if (awaitingCacheSnapshot && mc.currentScreen instanceof GuiContainer)
3533:         {
3534:             cacheOpenTicks++;
3535:             if (cacheOpenTicks >= 2)
3536:             {
3537:                 snapshotCurrentContainer((GuiContainer) mc.currentScreen);
3538:                 awaitingCacheSnapshot = false;
3539:             }
3540:         }
3541:         if (codeMenuActive)
3542:         {
3543:             if (mc.currentScreen instanceof GuiChest)
3544:             {
3545:                 IInventory inv = getChestInventory((GuiChest) mc.currentScreen);
3546:                 if (inv != codeMenuInventory)
3547:                 {
3548:                     codeMenuActive = false;
3549:                     codeMenuInventory = null;
3550:                 }
3551:             }
3552:             else
3553:             {
3554:                 codeMenuActive = false;
3555:                 codeMenuInventory = null;
3556:             }
3557:         }
3558:     }
3559: 
3560:     private void handleCodeMenuKeys(Minecraft mc)
3561:     {
3562:         if (mc == null || mc.player == null || mc.playerController == null)
3563:         {
3564:             return;
3565:         }
3566:         if (!editorModeActive || !mc.playerController.isInCreativeMode()
3567:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3568:         {
3569:             return;
3570:         }
3571:         boolean down = (keyOpenCodeMenu != null && keyOpenCodeMenu.isKeyDown())
3572:             || (keyOpenCodeMenuAlt != null && keyOpenCodeMenuAlt.isKeyDown());
3573:         if (down && !codeMenuKeyDown)
3574:         {
3575:             openCodeMenu(mc);
3576:         }
3577:         codeMenuKeyDown = down;
3578:     }
3579: 
3580:     private void handleTpForwardKey(Minecraft mc)
3581:     {
3582:         if (mc == null || mc.player == null || mc.playerController == null)
3583:         {
3584:             return;
3585:         }
3586:         boolean down = keyTpForward != null && keyTpForward.isKeyDown();
3587:         if (down && !tpForwardKeyDown)
3588:         {
3589:             tpScrollSteps = 0;
3590:         }
3591:         if (down)
3592:         {
3593:             if (!editorModeActive || !mc.playerController.isInCreativeMode()
3594:                 || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3595:             {
3596:                 setActionBar(false, "&cDev+Creative only.", 2000L);
3597:             }
3598:             else
3599:             {
3600:                 int wheel = Mouse.getDWheel();
3601:                 if (wheel != 0)
3602:                 {
3603:                     tpScrollSteps += wheel > 0 ? 1 : -1;
3604:                 }
3605:                 boolean plus = Keyboard.isKeyDown(Keyboard.KEY_ADD) || Keyboard.isKeyDown(Keyboard.KEY_EQUALS);
3606:                 boolean minus = Keyboard.isKeyDown(Keyboard.KEY_SUBTRACT) || Keyboard.isKeyDown(Keyboard.KEY_MINUS);
3607:                 if (plus)
3608:                 {
3609:                     mc.player.setPosition(mc.player.posX, mc.player.posY + 10.0, mc.player.posZ);
3610:                 }
3611:                 else if (minus)
3612:                 {
3613:                     mc.player.setPosition(mc.player.posX, mc.player.posY - 10.0, mc.player.posZ);
3614:                 }
3615:             }
3616:         }
3617:         if (!down && tpForwardKeyDown)
3618:         {
3619:             if (!editorModeActive || !mc.playerController.isInCreativeMode()
3620:                 || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3621:             {
3622:                 setActionBar(false, "&cDev+Creative only.", 2000L);
3623:             }
3624:             else
3625:             {
3626:                 if (tpScrollSteps != 0)
3627:                 {
3628:                     tpScrollDir = tpScrollSteps > 0 ? 1 : -1;
3629:                     tpScrollQueue = Math.min(50, Math.abs(tpScrollSteps));
3630:                     tpScrollNextMs = System.currentTimeMillis() + 300L;
3631:                 }
3632:                 else
3633:                 {
3634:                     Vec3d look = mc.player.getLookVec();
3635:                     double step = 0.5;
3636:                     for (int i = 0; i < 9; i++)
3637:                     {
3638:                         mc.player.setPosition(
3639:                             mc.player.posX + look.x * step,
3640:                             mc.player.posY + look.y * step + 0.05,
3641:                             mc.player.posZ + look.z * step
3642:                         );
3643:                     }
3644:                 }
3645:                 mc.player.motionX = 0.0;
3646:                 mc.player.motionY = 0.0;
3647:                 mc.player.motionZ = 0.0;
3648:             }
3649:             tpScrollSteps = 0;
3650:         }
3651:         tpForwardKeyDown = down;
3652:     }
3653: 
3654:     private void handleTpScrollQueue(Minecraft mc)
3655:     {
3656:         if (tpScrollQueue <= 0)
3657:         {
3658:             return;
3659:         }
3660:         if (mc == null || mc.player == null || mc.playerController == null)
3661:         {
3662:             tpScrollQueue = 0;
3663:             return;
3664:         }
3665:         if (!editorModeActive || !mc.playerController.isInCreativeMode()
3666:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3667:         {
3668:             tpScrollQueue = 0;
3669:             return;
3670:         }
3671:         long now = System.currentTimeMillis();
3672:         if (now < tpScrollNextMs)
3673:         {
3674:             return;
3675:         }
3676:         double delta = tpScrollDir * 10.0;
3677:         mc.player.setPosition(mc.player.posX, mc.player.posY + delta, mc.player.posZ);
3678:         mc.player.motionX = 0.0;
3679:         mc.player.motionY = 0.0;
3680:         mc.player.motionZ = 0.0;
3681:         tpScrollQueue--;
3682:         tpScrollNextMs = now + 300L;
3683:     }
3684: 
3685:     private void buildTpPathQueue(World world, double sx, double sy, double sz, double tx, double ty, double tz)
3686:     {
3687:         if (world == null)
3688:         {
3689:             return;
3690:         }
3691:         if (!isTpTargetValid(world, tx, ty, tz))
3692:         {
3693:             tpPathQueue.clear();
3694:             setActionBar(true, "&cTarget outside world border/height", 2500L);
3695:             return;
3696:         }
3697:         tpPathQueue.clear();
3698:         double dx = tx - sx;
3699:         double dy = ty - sy;
3700:         double dz = tz - sz;
3701:         int safety = 0;
3702:         for (int axis = 0; axis < 3; axis++)
3703:         {
3704:             double delta = axis == 0 ? dx : axis == 1 ? dy : dz;
3705:             while (Math.abs(delta) >= 0.001 && safety < 5000)
3706:             {
3707:                 double step = Math.min(10.0, Math.abs(delta)) * Math.signum(delta);
3708:                 double[] move = new double[] {0.0, 0.0, 0.0};
3709:                 if (axis == 0)
3710:                 {
3711:                     move[0] = step;
3712:                     dx -= step;
3713:                     delta = dx;
3714:                 }
3715:                 else if (axis == 1)
3716:                 {
3717:                     move[1] = step;
3718:                     dy -= step;
3719:                     delta = dy;
3720:                 }
3721:                 else
3722:                 {
3723:                     move[2] = step;
3724:                     dz -= step;
3725:                     delta = dz;
3726:                 }
3727:                 tpPathQueue.add(move);
3728:                 safety++;
3729:             }
3730:         }
3731:         if (tpPathQueue.isEmpty())
3732:         {
3733:             setActionBar(true, "&eTP path empty", 1500L);
3734:             return;
3735:         }
3736:         tpPathNextMs = System.currentTimeMillis() + 300L;
3737:         setActionBar(true, "&aTP path steps=" + tpPathQueue.size(), 2000L);
3738:     }
3739: 
3740:     private boolean isTpTargetValid(World world, double tx, double ty, double tz)
3741:     {
3742:         if (world == null)
3743:         {
3744:             return false;
3745:         }
3746:         if (ty < 0.0 || ty > 255.0)
3747:         {
3748:             return false;
3749:         }
3750:         BlockPos pos = new BlockPos((int) Math.floor(tx), (int) Math.floor(ty), (int) Math.floor(tz));
3751:         return world.getWorldBorder() == null || world.getWorldBorder().contains(pos);
3752:     }
3753: 
3754:     private void handleTpPathQueue(Minecraft mc)
3755:     {
3756:         if (tpPathQueue.isEmpty())
3757:         {
3758:             return;
3759:         }
3760:         if (mc == null || mc.player == null || mc.playerController == null)
3761:         {
3762:             tpPathQueue.clear();
3763:             return;
3764:         }
3765:         if (!editorModeActive || !mc.playerController.isInCreativeMode()
3766:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3767:         {
3768:             tpPathQueue.clear();
3769:             return;
3770:         }
3771:         long now = System.currentTimeMillis();
3772:         if (now < tpPathNextMs)
3773:         {
3774:             return;
3775:         }
3776:         double[] step = tpPathQueue.poll();
3777:         if (step == null)
3778:         {
3779:             return;
3780:         }
3781:         mc.player.setPosition(mc.player.posX + step[0], mc.player.posY + step[1], mc.player.posZ + step[2]);
3782:         mc.player.motionX = 0.0;
3783:         mc.player.motionY = 0.0;
3784:         mc.player.motionZ = 0.0;
3785:         tpPathNextMs = now + 300L;
3786:     }
3787: 
3788:     private void handleCopyPaste(GuiScreenEvent.KeyboardInputEvent.Pre event)
3789:     {
3790:         if (event == null || event.getGui() == null)
3791:         {
3792:             return;
3793:         }
3794:         if (!(event.getGui() instanceof GuiContainer))
3795:         {
3796:             return;
3797:         }
3798:         if (!Keyboard.getEventKeyState())
3799:         {
3800:             return;
3801:         }
3802:         Minecraft mc = Minecraft.getMinecraft();
3803:         if (mc == null || mc.player == null || mc.playerController == null)
3804:         {
3805:             return;
3806:         }
3807:         if (!editorModeActive || !mc.playerController.isInCreativeMode()
3808:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
3809:         {
3810:             return;
3811:         }
3812:         boolean ctrl = Keyboard.isKeyDown(Keyboard.KEY_LCONTROL) || Keyboard.isKeyDown(Keyboard.KEY_RCONTROL);
3813:         if (!ctrl)
3814:         {
3815:             return;
3816:         }
3817:         int key = Keyboard.getEventKey();
3818:         GuiContainer gui = (GuiContainer) event.getGui();
3819:         if (key == Keyboard.KEY_C)
3820:         {
3821:             copyFromContainer(gui);
3822:             event.setCanceled(true);
3823:         }
3824:         else if (key == Keyboard.KEY_V)
3825:         {
3826:             pasteToContainer(gui);
3827:             event.setCanceled(true);
3828:         }
3829:     }
3830: 
3831:     private void copyFromContainer(GuiContainer gui)
3832:     {
3833:         copiedSlots.clear();
3834:         if (gui == null)
3835:         {
3836:             return;
3837:         }
3838:         Container container = gui.inventorySlots;
3839:         for (Slot slot : container.inventorySlots)
3840:         {
3841:             if (slot == null || !slot.getHasStack())
3842:             {
3843:                 continue;
3844:             }
3845:             ItemStack stack = slot.getStack();
3846:             if (isCodeMenuItem(stack))
3847:             {
3848:                 copiedSlots.add(new CopiedSlot(slot.slotNumber, stack.copy()));
3849:             }
3850:         }
3851:         setActionBar(true, "&aCopied " + copiedSlots.size(), 1500L);
3852:     }
3853: 
3854:     private void pasteToContainer(GuiContainer gui)
3855:     {
3856:         if (copiedSlots.isEmpty() || gui == null)
3857:         {
3858:             return;
3859:         }
3860:         Minecraft mc = Minecraft.getMinecraft();
3861:         if (mc == null || mc.player == null || mc.playerController == null)
3862:         {
3863:             return;
3864:         }
3865:         Container container = gui.inventorySlots;
3866:         for (CopiedSlot entry : copiedSlots)
3867:         {
3868:             Slot target = findSlotByNumber(container, entry.slotNumber);
3869:             if (target != null && !target.getHasStack())
3870:             {
3871:                 placeInContainerSlot(mc, container, target.slotNumber, entry.stack.copy());
3872:                 continue;
3873:             }
3874:             Slot empty = findFirstEmptySlot(container);
3875:             if (empty != null)
3876:             {
3877:                 placeInContainerSlot(mc, container, empty.slotNumber, entry.stack.copy());
3878:             }
3879:         }
3880:         setActionBar(true, "&aPasted " + copiedSlots.size(), 1500L);
3881:     }
3882: 
3883:     private void exportGuiToClipboard(GuiContainer gui, boolean includeRaw, boolean includeClean)
3884:     {
3885:         if (gui == null)
3886:         {
3887:             return;
3888:         }
3889:         ExportResult raw = includeRaw ? buildGuiExportText(gui, true) : null;
3890:         ExportResult clean = includeClean ? buildGuiExportText(gui, false) : null;
3891:         int count = raw != null ? raw.itemCount : (clean != null ? clean.itemCount : 0);
3892:         StringBuilder out = new StringBuilder();
3893:         if (raw != null && clean != null)
3894:         {
3895:             out.append("RAW:\n").append(raw.text).append("\n\nCLEAN:\n").append(clean.text);
3896:         }
3897:         else if (raw != null)
3898:         {
3899:             out.append(raw.text);
3900:         }
3901:         else if (clean != null)
3902:         {
3903:             out.append(clean.text);
3904:         }
3905:         GuiScreen.setClipboardString(out.toString());
3906:         setActionBar(true, "&aGUI export: " + count + " items", 2000L);
3907:     }
3908: 
3909:     private ExportResult buildGuiExportText(GuiContainer gui, boolean keepColors)
3910:     {
3911:         StringBuilder sb = new StringBuilder();
3912:         int count = 0;
3913:         if (gui == null || gui.inventorySlots == null)
3914:         {
3915:             return new ExportResult("", 0);
3916:         }
3917:         Container container = gui.inventorySlots;
3918:         for (Slot slot : container.inventorySlots)
3919:         {
3920:             if (slot == null || !slot.getHasStack())
3921:             {
3922:                 continue;
3923:             }
3924:             ItemStack stack = slot.getStack();
3925:             if (stack.isEmpty())
3926:             {
3927:                 continue;
3928:             }
3929:             String name = stack.getDisplayName();
3930:             if (!keepColors)
3931:             {
3932:                 name = TextFormatting.getTextWithoutFormattingCodes(name);
3933:             }
3934:             if (name == null)
3935:             {
3936:                 name = "";
3937:             }
3938:             ResourceLocation id = stack.getItem() != null ? stack.getItem().getRegistryName() : null;
3939:             String idText = id != null ? id.toString() : "unknown";
3940:             sb.append("[(").append(idText).append(") ").append(name);
3941:             if (stack.getCount() > 1)
3942:             {
3943:                 sb.append(" x").append(stack.getCount());
3944:             }
3945:             sb.append("]\n");
3946:             for (String loreLine : getStackLore(stack, keepColors))
3947:             {
3948:                 sb.append(loreLine).append("\n");
3949:             }
3950:             sb.append("\n");
3951:             count++;
3952:         }
3953:         return new ExportResult(sb.toString().trim(), count);
3954:     }
3955: 
3956:     private List<String> getStackLore(ItemStack stack, boolean keepColors)
3957:     {
3958:         List<String> out = new ArrayList<>();
3959:         if (stack == null || stack.isEmpty())
3960:         {
3961:             return out;
3962:         }
3963:         NBTTagCompound tag = stack.getTagCompound();
3964:         if (tag == null || !tag.hasKey("display", 10))
3965:         {
3966:             return out;
3967:         }
3968:         NBTTagCompound display = tag.getCompoundTag("display");
3969:         if (!display.hasKey("Lore", 9))
3970:         {
3971:             return out;
3972:         }
3973:         NBTTagList lore = display.getTagList("Lore", 8);
3974:         for (int i = 0; i < lore.tagCount(); i++)
3975:         {
3976:             String line = lore.getStringTagAt(i);
3977:             if (!keepColors)
3978:             {
3979:                 line = TextFormatting.getTextWithoutFormattingCodes(line);
3980:             }
3981:             out.add(line == null ? "" : line);
3982:         }
3983:         return out;
3984:     }
3985: 
3986:     private Slot findFirstEmptySlot(Container container)
3987:     {
3988:         if (container == null)
3989:         {
3990:             return null;
3991:         }
3992:         for (Slot slot : container.inventorySlots)
3993:         {
3994:             if (slot != null && !slot.getHasStack())
3995:             {
3996:                 return slot;
3997:             }
3998:         }
3999:         return null;
4000:     }
4001: 
4002:     private boolean isCodeMenuItem(ItemStack stack)
4003:     {
4004:         if (stack == null || stack.isEmpty())
4005:         {
4006:             return false;
4007:         }
4008:         return stack.getItem() == Items.BOOK
4009:             || stack.getItem() == Items.SLIME_BALL
4010:             || stack.getItem() == Items.MAGMA_CREAM
4011:             || stack.getItem() == Items.ITEM_FRAME
4012:             || stack.getItem() == Items.PAPER
4013:             || stack.getItem() == Items.GLASS_BOTTLE
4014:             || stack.getItem() == Items.APPLE
4015:             || stack.getItem() == Items.NETHER_STAR
4016:             || stack.getItem() == Items.SHULKER_SHELL
4017:             || stack.getItem() == Items.PRISMARINE_SHARD;
4018:     }
4019: 
4020:     private boolean isCodeMenuScreen(GuiScreen gui)
4021:     {
4022:         if (!(gui instanceof GuiChest))
4023:         {
4024:             return false;
4025:         }
4026:         if (!codeMenuActive || codeMenuInventory == null)
4027:         {
4028:             return false;
4029:         }
4030:         IInventory inv = getChestInventory((GuiChest) gui);
4031:         return inv == codeMenuInventory;
4032:     }
4033: 
4034:     private void handleCodeMenuClick(GuiContainer gui)
4035:     {
4036:         Slot hovered = getSlotUnderMouse(gui);
4037:         if (hovered == null || !hovered.getHasStack())
4038:         {
4039:             return;
4040:         }
4041:         ItemStack stack = hovered.getStack();
4042:         if (stack.isEmpty())
4043:         {
4044:             return;
4045:         }
4046: 
4047:         if (stack.getItem() == Items.SLIME_BALL)
4048:         {
4049:             startGiveInput(stack.copy(), INPUT_MODE_NUMBER, "Number");
4050:             return;
4051:         }
4052:         if (stack.getItem() == Items.MAGMA_CREAM)
4053:         {
4054:             startGiveInput(stack.copy(), INPUT_MODE_VARIABLE, "Variable");
4055:             return;
4056:         }
4057:         if (stack.getItem() == Items.ITEM_FRAME)
4058:         {
4059:             startGiveInput(stack.copy(), INPUT_MODE_ARRAY, "Array");
4060:             return;
4061:         }
4062:         if (stack.getItem() == Items.BOOK)
4063:         {
4064:             startGiveInput(stack.copy(), INPUT_MODE_TEXT, "Text");
4065:             return;
4066:         }
4067:         if (stack.getItem() == Items.PAPER)
4068:         {
4069:             startGiveInput(stack.copy(), INPUT_MODE_LOCATION, "Location");
4070:             return;
4071:         }
4072: 
4073:         Minecraft mc = Minecraft.getMinecraft();
4074:         if (mc == null || mc.player == null || mc.playerController == null)
4075:         {
4076:             return;
4077:         }
4078:         if (!mc.playerController.isInCreativeMode() || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
4079:         {
4080:             setActionBar(false, "&cCreative only.", 2000L);
4081:             return;
4082:         }
4083:         ItemStack give = copyStackForGive(stack);
4084:         if (give.isEmpty())
4085:         {
4086:             return;
4087:         }
4088:         giveItemToHotbar(mc, give);
4089:     }
4090: 
4091:     private void openCodeMenu(Minecraft mc)
4092:     {
4093:         if (mc == null || mc.player == null)
4094:         {
4095:             return;
4096:         }
4097:         IInventory inv;
4098:         if (customMenuCache != null)
4099:         {
4100:             InventoryBasic custom = new InventoryBasic(customMenuCache.title, true, customMenuCache.size);
4101:             for (int i = 0; i < customMenuCache.size; i++)
4102:             {
4103:                 ItemStack stack = customMenuCache.items.get(i);
4104:                 custom.setInventorySlotContents(i, stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4105:             }
4106:             inv = custom;
4107:         }
4108:         else
4109:         {
4110:             InventoryBasic base = new InventoryBasic(CODE_MENU_TITLE, true, 18);
4111:             List<ItemStack> items = buildDefaultCodeMenuItems();
4112:             for (int i = 0; i < items.size() && i < 18; i++)
4113:             {
4114:                 base.setInventorySlotContents(i, items.get(i));
4115:             }
4116:             inv = base;
4117:         }
4118:         mc.displayGuiScreen(new GuiChest(mc.player.inventory, inv));
4119:         codeMenuActive = true;
4120:         codeMenuInventory = inv;
4121:     }
4122: 
4123:     private List<ItemStack> buildDefaultCodeMenuItems()
4124:     {
4125:         List<ItemStack> items = new ArrayList<>();
4126:         items.add(new ItemStack(Items.BOOK));
4127:         items.add(new ItemStack(Items.SLIME_BALL));
4128:         items.add(new ItemStack(Items.PAPER));
4129:         items.add(new ItemStack(Items.GLASS_BOTTLE));
4130:         items.add(new ItemStack(Items.MAGMA_CREAM));
4131:         items.add(new ItemStack(Items.APPLE));
4132:         items.add(new ItemStack(Items.NETHER_STAR));
4133:         items.add(new ItemStack(Items.ITEM_FRAME));
4134:         items.add(new ItemStack(Items.SHULKER_SHELL));
4135:         items.add(new ItemStack(Items.PRISMARINE_SHARD));
4136:         return items;
4137:     }
4138: 
4139:     private void openFakeMenuFromCache(String key, CachedMenu cached)
4140:     {
4141:         Minecraft mc = Minecraft.getMinecraft();
4142:         if (mc == null || mc.player == null)
4143:         {
4144:             return;
4145:         }
4146:         InventoryBasic inv = new InventoryBasic(cached.title, true, cached.size);
4147:         for (int i = 0; i < cached.size; i++)
4148:         {
4149:             ItemStack stack = cached.items.get(i);
4150:             inv.setInventorySlotContents(i, stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4151:         }
4152:         mc.displayGuiScreen(new GuiChest(mc.player.inventory, inv));
4153:         fakeMenuActive = true;
4154:         fakeMenuKey = key;
4155:         queuedClicks.clear();
4156:     }
4157: 
4158:     private void snapshotCurrentMenu(GuiChest chest)
4159:     {
4160:         if (chest == null)
4161:         {
4162:             return;
4163:         }
4164:         IInventory inv = getChestInventory(chest);
4165:         if (inv == null)
4166:         {
4167:             return;
4168:         }
4169:         int size = inv.getSizeInventory();
4170:         List<ItemStack> items = new ArrayList<>();
4171:         for (int i = 0; i < size; i++)
4172:         {
4173:             ItemStack stack = inv.getStackInSlot(i);
4174:             items.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4175:         }
4176:         String title = getGuiTitle(chest);
4177:         String hash = buildMenuHash(items);
4178:         CachedMenu menu = new CachedMenu(title, size, items, hash);
4179:         if (pendingCacheKey != null)
4180:         {
4181:             menuCache.put(pendingCacheKey, menu);
4182:             cachePathRoot = pendingCacheKey;
4183:             if (debugUi)
4184:             {
4185:                 setActionBar(true, "&aCached " + pendingCacheKey, 1500L);
4186:             }
4187:             pendingCacheKey = null;
4188:             menuCacheDirty = true;
4189:         }
4190:         if (captureCustomMenuNow)
4191:         {
4192:             customMenuCache = menu;
4193:             captureCustomMenuNow = false;
4194:             captureCustomMenuArmed = false;
4195:             setActionBar(true, "&aCode menu cached.", 2000L);
4196:             menuCacheDirty = true;
4197:         }
4198:         if (inv instanceof TileEntityChest)
4199:         {
4200:             TileEntityChest te = (TileEntityChest) inv;
4201:             cacheChestInventory(te, items);
4202:             lastClickedPos = te.getPos();
4203:             lastClickedDim = te.getWorld().provider.getDimension();
4204:             lastClickedMs = System.currentTimeMillis();
4205:         }
4206:         else if (lastClickedPos != null && lastClickedChest && !lastClickedIsSign
4207:             && System.currentTimeMillis() - lastClickedMs < 5000L)
4208:         {
4209:             cacheChestInventoryAt(lastClickedDim, lastClickedPos, items, lastClickedLabel);
4210:         }
4211: 
4212:         if (fakeMenuActive && fakeMenuKey != null)
4213:         {
4214:             CachedMenu cached = menuCache.get(fakeMenuKey);
4215:             if (cached != null && cached.hash.equals(hash))
4216:             {
4217:                 replayQueuedClicks(Minecraft.getMinecraft());
4218:             }
4219:             queuedClicks.clear();
4220:             fakeMenuActive = false;
4221:             fakeMenuKey = null;
4222:         }
4223:     }
4224: 
4225:     private void snapshotCurrentContainer(GuiContainer gui)
4226:     {
4227:         if (gui == null)
4228:         {
4229:             return;
4230:         }
4231:         if (gui instanceof GuiInventory)
4232:         {
4233:             return;
4234:         }
4235:         if (gui instanceof GuiChest)
4236:         {
4237:             snapshotCurrentMenu((GuiChest) gui);
4238:             return;
4239:         }
4240:         Container container = gui.inventorySlots;
4241:         if (container == null)
4242:         {
4243:             return;
4244:         }
4245:         Minecraft mc = Minecraft.getMinecraft();
4246:         if (mc == null || mc.player == null)
4247:         {
4248:             return;
4249:         }
4250:         if (mc.player.openContainer != null && mc.player.openContainer == mc.player.inventoryContainer)
4251:         {
4252:             return;
4253:         }
4254:         List<ItemStack> items = new ArrayList<>();
4255:         int nonPlayerSlots = 0;
4256:         for (Slot slot : container.inventorySlots)
4257:         {
4258:             if (slot == null)
4259:             {
4260:                 continue;
4261:             }
4262:             if (slot.inventory == mc.player.inventory)
4263:             {
4264:                 continue;
4265:             }
4266:             nonPlayerSlots++;
4267:             ItemStack stack = slot.getStack();
4268:             items.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4269:         }
4270:         if (nonPlayerSlots == 0)
4271:         {
4272:             return;
4273:         }
4274:         String title = "Container";
4275:         String hash = buildMenuHash(items);
4276:         CachedMenu menu = new CachedMenu(title, items.size(), items, hash);
4277:         if (pendingCacheKey != null)
4278:         {
4279:             menuCache.put(pendingCacheKey, menu);
4280:             cachePathRoot = pendingCacheKey;
4281:             if (debugUi)
4282:             {
4283:                 setActionBar(true, "&aCached " + pendingCacheKey, 1500L);
4284:             }
4285:             pendingCacheKey = null;
4286:             menuCacheDirty = true;
4287:         }
4288:         if (captureCustomMenuNow)
4289:         {
4290:             customMenuCache = menu;
4291:             captureCustomMenuNow = false;
4292:             captureCustomMenuArmed = false;
4293:             setActionBar(true, "&aCode menu cached.", 2000L);
4294:             menuCacheDirty = true;
4295:         }
4296:         if (lastClickedPos != null && lastClickedChest && System.currentTimeMillis() - lastClickedMs < 5000L)
4297:         {
4298:             cacheChestInventoryAt(lastClickedDim, lastClickedPos, items, lastClickedLabel);
4299:         }
4300:     }
4301: 
4302:     private void snapshotOpenContainer(Container container)
4303:     {
4304:         if (container == null)
4305:         {
4306:             return;
4307:         }
4308:         Minecraft mc = Minecraft.getMinecraft();
4309:         if (mc == null || mc.player == null)
4310:         {
4311:             return;
4312:         }
4313:         if (container == mc.player.inventoryContainer)
4314:         {
4315:             return;
4316:         }
4317:         List<ItemStack> items = new ArrayList<>();
4318:         int nonPlayerSlots = 0;
4319:         for (Slot slot : container.inventorySlots)
4320:         {
4321:             if (slot == null)
4322:             {
4323:                 continue;
4324:             }
4325:             if (slot.inventory == mc.player.inventory)
4326:             {
4327:                 continue;
4328:             }
4329:             nonPlayerSlots++;
4330:             ItemStack stack = slot.getStack();
4331:             items.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4332:         }
4333:         if (nonPlayerSlots == 0)
4334:         {
4335:             return;
4336:         }
4337:         if (lastClickedPos != null && lastClickedChest && System.currentTimeMillis() - lastClickedMs < 5000L)
4338:         {
4339:             cacheChestInventoryAt(lastClickedDim, lastClickedPos, items, lastClickedLabel);
4340:         }
4341:     }
4342: 
4343:     private void queueFakeMenuClick(GuiContainer gui)
4344:     {
4345:         if (gui == null)
4346:         {
4347:             return;
4348:         }
4349:         Slot hovered = getSlotUnderMouse(gui);
4350:         if (hovered == null)
4351:         {
4352:             return;
4353:         }
4354:         Minecraft mc = Minecraft.getMinecraft();
4355:         if (mc != null && mc.player != null && hovered.inventory == mc.player.inventory)
4356:         {
4357:             return;
4358:         }
4359:         int button = Mouse.getEventButton();
4360:         ClickType type = (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT))
4361:             ? ClickType.QUICK_MOVE : ClickType.PICKUP;
4362:         queuedClicks.add(new ClickAction(hovered.slotNumber, button, type));
4363:     }
4364: 
4365:     private void replayQueuedClicks(Minecraft mc)
4366:     {
4367:         if (mc == null || mc.player == null || mc.playerController == null)
4368:         {
4369:             return;
4370:         }
4371:         Container container = mc.player.openContainer;
4372:         if (container == null)
4373:         {
4374:             return;
4375:         }
4376:         queuedClicks.clear();
4377:     }
4378: 
4379:     private void updateCachePathFromItem(ItemStack stack)
4380:     {
4381:         if (stack == null || stack.isEmpty() || cachePathRoot == null)
4382:         {
4383:             return;
4384:         }
4385:         String key = buildItemKey(stack);
4386:         pendingCacheKey = cachePathRoot + ">" + key;
4387:         pendingCacheMs = System.currentTimeMillis();
4388:         awaitingCacheSnapshot = true;
4389:         cacheOpenTicks = 0;
4390:         CachedMenu cached = menuCache.get(pendingCacheKey);
4391:         if (cached != null)
4392:         {
4393:             openFakeMenuFromCache(pendingCacheKey, cached);
4394:         }
4395:     }
4396: 
4397:     private void cacheChestInventory(TileEntityChest te, List<ItemStack> items)
4398:     {
4399:         if (te == null || te.getPos() == null || te.getWorld() == null)
4400:         {
4401:             return;
4402:         }
4403:         BlockPos pos = te.getPos();
4404:         int dim = te.getWorld().provider.getDimension();
4405:         String key = chestKey(dim, pos);
4406:         String label = getChestLabel(te.getWorld(), pos);
4407:         List<ItemStack> copy = new ArrayList<>();
4408:         for (ItemStack stack : items)
4409:         {
4410:             copy.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4411:         }
4412:         chestCaches.put(key, new ChestCache(dim, pos, copy, System.currentTimeMillis(), label));
4413:         if (debugUi)
4414:         {
4415:             setActionBar(true, "&aChest cached " + pos.getX() + "," + pos.getY() + "," + pos.getZ(), 1500L);
4416:         }
4417:         updateChestIdCache(dim, pos, copy, label);
4418:     }
4419: 
4420:     private void cacheChestInventoryAt(int dim, BlockPos pos, List<ItemStack> items, String labelOverride)
4421:     {
4422:         if (pos == null)
4423:         {
4424:             return;
4425:         }
4426:         String key = chestKey(dim, pos);
4427:         String label = labelOverride;
4428:         Minecraft mc = Minecraft.getMinecraft();
4429:         if ((label == null || label.trim().isEmpty()) && mc != null && mc.world != null
4430:             && mc.world.provider.getDimension() == dim)
4431:         {
4432:             label = getChestLabel(mc.world, pos);
4433:         }
4434:         List<ItemStack> copy = new ArrayList<>();
4435:         for (ItemStack stack : items)
4436:         {
4437:             copy.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4438:         }
4439:         chestCaches.put(key, new ChestCache(dim, pos, copy, System.currentTimeMillis(), label));
4440:         if (debugUi)
4441:         {
4442:             setActionBar(true, "&aChest cached " + pos.getX() + "," + pos.getY() + "," + pos.getZ(), 1500L);
4443:         }
4444:         updateChestIdCache(dim, pos, copy, label);
4445:     }
4446: 
4447:     private void updateChestIdCache(int dim, BlockPos pos, List<ItemStack> items, String label)
4448:     {
4449:         String id = getScoreboardIdLine();
4450:         if (id == null || id.trim().isEmpty())
4451:         {
4452:             return;
4453:         }
4454:         String key = chestIdKey(id, dim, pos);
4455:         if (key == null)
4456:         {
4457:             return;
4458:         }
4459:         List<ItemStack> copy = new ArrayList<>();
4460:         for (ItemStack stack : items)
4461:         {
4462:             copy.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4463:         }
4464:         ChestCache cached = new ChestCache(dim, pos, copy, System.currentTimeMillis(), label);
4465:         chestIdCaches.put(key, cached);
4466:         chestIdDirty = true;
4467:         if (editorModeActive && dim == Minecraft.getMinecraft().world.provider.getDimension())
4468:         {
4469:             ensureChestCaches(dim);
4470:         }
4471:     }
4472: 
4473:     private void clearChestClickState()
4474:     {
4475:         pendingChestSnapshot = false;
4476:         lastClickedChest = false;
4477:         allowChestSnapshot = false;
4478:         allowChestUntilMs = 0L;
4479:         lastClickedPos = null;
4480:         lastClickedLabel = null;
4481:         lastClickedIsSign = false;
4482:     }
4483: 
4484:     private String getChestLabel(World world, BlockPos chestPos)
4485:     {
4486:         if (world == null || chestPos == null)
4487:         {
4488:             return null;
4489:         }
4490:         BlockPos signPos = chestPos.add(0, -1, -1);
4491:         TileEntity te = world.getTileEntity(signPos);
4492:         if (!(te instanceof TileEntitySign))
4493:         {
4494:             return null;
4495:         }
4496:         TileEntitySign sign = (TileEntitySign) te;
4497:         String line = sign.signText[1].getUnformattedText();
4498:         if (line == null)
4499:         {
4500:             return null;
4501:         }
4502:         return line.trim();
4503:     }
4504: 
4505:     private void clearChestCacheAt(BlockPos pos)
4506:     {
4507:         Minecraft mc = Minecraft.getMinecraft();
4508:         if (mc == null || mc.world == null || pos == null)
4509:         {
4510:             return;
4511:         }
4512:         String key = chestKey(mc.world.provider.getDimension(), pos);
4513:         chestCaches.remove(key);
4514:     }
4515: 
4516:     private String chestKey(int dim, BlockPos pos)
4517:     {
4518:         return dim + ":" + pos.getX() + ":" + pos.getY() + ":" + pos.getZ();
4519:     }
4520: 
4521:     private String chestIdKey(String id, int dim, BlockPos pos)
4522:     {
4523:         if (id == null || id.trim().isEmpty() || pos == null)
4524:         {
4525:             return null;
4526:         }
4527:         return id.trim() + "|" + dim + ":" + pos.getX() + ":" + pos.getY() + ":" + pos.getZ();
4528:     }
4529: 
4530:     private void ensureChestCaches(int dim)
4531:     {
4532:         String id = getScoreboardIdLine();
4533:         if (id == null || id.trim().isEmpty())
4534:         {
4535:             return;
4536:         }
4537:         String idNeedle = id.trim();
4538:         for (Map.Entry<String, ChestCache> entry : chestIdCaches.entrySet())
4539:         {
4540:             ChestCache cache = entry.getValue();
4541:             if (cache == null || cache.pos == null || cache.dim != dim)
4542:             {
4543:                 continue;
4544:             }
4545:             String keyId = entry.getKey();
4546:             int pipe = keyId == null ? -1 : keyId.indexOf('|');
4547:             if (pipe > 0)
4548:             {
4549:                 String cacheId = keyId.substring(0, pipe);
4550:                 if (!idNeedle.contains(cacheId))
4551:                 {
4552:                     continue;
4553:                 }
4554:             }
4555:             String key = chestKey(cache.dim, cache.pos);
4556:             if (!chestCaches.containsKey(key))
4557:             {
4558:                 List<ItemStack> copy = new ArrayList<>();
4559:                 for (ItemStack stack : cache.items)
4560:                 {
4561:                     copy.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
4562:                 }
4563:                 chestCaches.put(key, new ChestCache(cache.dim, cache.pos, copy, System.currentTimeMillis(),
4564:                     cache.label));
4565:             }
4566:         }
4567:     }
4568: 
4569:     private String buildItemKey(ItemStack stack)
4570:     {
4571:         if (stack == null || stack.isEmpty())
4572:         {
4573:             return "empty";
4574:         }
4575:         ResourceLocation id = stack.getItem().getRegistryName();
4576:         StringBuilder sb = new StringBuilder();
4577:         sb.append(id == null ? "" : id.toString()).append(":");
4578:         sb.append(stack.getMetadata()).append(":");
4579:         sb.append(stack.getCount()).append(":");
4580:         sb.append(escapeJson(stack.getDisplayName())).append(":");
4581:         if (stack.hasTagCompound())
4582:         {
4583:             sb.append(stack.getTagCompound().toString());
4584:         }
4585:         return Integer.toHexString(sb.toString().hashCode());
4586:     }
4587: 
4588:     private IInventory getChestInventory(GuiChest chest)
4589:     {
4590:         if (chest == null)
4591:         {
4592:             return null;
4593:         }
4594:         try
4595:         {
4596:             if (lowerChestField == null)
4597:             {
4598:                 try
4599:                 {
4600:                     lowerChestField = GuiChest.class.getDeclaredField("lowerChestInventory");
4601:                 }
4602:                 catch (NoSuchFieldException e)
4603:                 {
4604:                     lowerChestField = GuiChest.class.getDeclaredField("field_147015_w");
4605:                 }
4606:                 lowerChestField.setAccessible(true);
4607:             }
4608:             Object value = lowerChestField.get(chest);
4609:             return value instanceof IInventory ? (IInventory) value : null;
4610:         }
4611:         catch (Exception e)
4612:         {
4613:             return null;
4614:         }
4615:     }
4616: 
4617:     private String getGuiTitle(GuiChest chest)
4618:     {
4619:         IInventory inv = getChestInventory(chest);
4620:         if (inv == null || inv.getDisplayName() == null)
4621:         {
4622:             return "";
4623:         }
4624:         return inv.getDisplayName().getUnformattedText();
4625:     }
4626: 
4627:     private String buildMenuHash(List<ItemStack> items)
4628:     {
4629:         StringBuilder sb = new StringBuilder();
4630:         for (ItemStack stack : items)
4631:         {
4632:             if (stack == null || stack.isEmpty())
4633:             {
4634:                 sb.append("empty|");
4635:                 continue;
4636:             }
4637:             ResourceLocation id = stack.getItem().getRegistryName();
4638:             sb.append(id == null ? "" : id.toString()).append(":");
4639:             sb.append(stack.getMetadata()).append(":");
4640:             sb.append(stack.getCount()).append(":");
4641:             sb.append(escapeJson(stack.getDisplayName())).append(":");
4642:             if (stack.hasTagCompound())
4643:             {
4644:                 sb.append(stack.getTagCompound().toString());
4645:             }
4646:             sb.append("|");
4647:         }
4648:         return Integer.toHexString(sb.toString().hashCode());
4649:     }
4650: 
4651:     private Slot getSlotUnderMouse(GuiContainer gui)
4652:     {
4653:         if (gui == null)
4654:         {
4655:             return null;
4656:         }
4657:         try
4658:         {
4659:             if (getSlotUnderMouseMethod == null)
4660:             {
4661:                 getSlotUnderMouseMethod = GuiContainer.class.getDeclaredMethod("getSlotUnderMouse");
4662:                 getSlotUnderMouseMethod.setAccessible(true);
4663:             }
4664:             Object result = getSlotUnderMouseMethod.invoke(gui);
4665:             return result instanceof Slot ? (Slot) result : null;
4666:         }
4667:         catch (Exception e)
4668:         {
4669:             return null;
4670:         }
4671:     }
4672: 
4673:     private Slot findSlotAbove(GuiContainer gui, Slot base)
4674:     {
4675:         if (gui == null || base == null)
4676:         {
4677:             return null;
4678:         }
4679:         Container container = gui.inventorySlots;
4680:         int targetX = base.xPos;
4681:         int targetY = base.yPos - 18;
4682:         for (Slot slot : container.inventorySlots)
4683:         {
4684:             if (slot.xPos == targetX && slot.yPos == targetY)
4685:             {
4686:                 return slot;
4687:             }
4688:         }
4689:         return null;
4690:     }
4691: 
4692:     private Slot resolveInputTarget(GuiContainer gui, Slot base)
4693:     {
4694:         return findSlotAbove(gui, base);
4695:     }
4696: 
4697:     private String getModeTitle(int mode, String fallback)
4698:     {
4699:         if (mode == INPUT_MODE_NUMBER)
4700:         {
4701:             return "Number";
4702:         }
4703:         if (mode == INPUT_MODE_VARIABLE)
4704:         {
4705:             return "Variable";
4706:         }
4707:         if (mode == INPUT_MODE_ARRAY)
4708:         {
4709:             return "Array";
4710:         }
4711:         if (mode == INPUT_MODE_LOCATION)
4712:         {
4713:             return "Location";
4714:         }
4715:         if (mode == INPUT_MODE_TEXT)
4716:         {
4717:             return "Text";
4718:         }
4719:         return fallback == null || fallback.isEmpty() ? "Input" : fallback;
4720:     }
4721: 
4722:     private boolean handleGlassClick(GuiContainer container, Slot hovered, ItemStack hoveredStack,
4723:         net.minecraft.item.Item allowedItem, int fallbackMode)
4724:     {
4725:         Slot target = findCandidateSlot(container, hovered, allowedItem, fallbackMode);
4726:         if (target == null)
4727:         {
4728:             return false;
4729:         }
4730:         int mode = fallbackMode;
4731:         ItemStack targetStack = target.getStack();
4732:         if (target.getHasStack())
4733:         {
4734:             int actualMode = getModeForItem(targetStack);
4735:             if (actualMode >= 0)
4736:             {
4737:                 mode = actualMode;
4738:             }
4739:         }
4740:         ItemStack template = target.getHasStack() ? targetStack.copy() : templateForMode(mode);
4741:         if (template.isEmpty())
4742:         {
4743:             template = templateForMode(mode);
4744:         }
4745:         String preset = target.getHasStack() ? extractEntryText(targetStack, mode) : "";
4746:         String title = getModeTitle(mode, TextFormatting.getTextWithoutFormattingCodes(hoveredStack.getDisplayName()));
4747:         startSlotInput(container, target, template, mode, preset, title);
4748:         quickApplyWindowId = container.inventorySlots.windowId;
4749:         quickApplySlotNumber = target.slotNumber;
4750:         return true;
4751:     }
4752: 
4753:     private Slot findCandidateSlot(GuiContainer gui, Slot base, net.minecraft.item.Item allowedItem, int mode)
4754:     {
4755:         if (gui == null || base == null)
4756:         {
4757:             return null;
4758:         }
4759:         int x = base.xPos;
4760:         int y = base.yPos;
4761:         int[][] offsets = new int[][]{
4762:             {0, -18}, {0, 18}, {-18, 0}, {18, 0}
4763:         };
4764:         Slot empty = null;
4765:         Slot fallback = null;
4766:         for (int[] off : offsets)
4767:         {
4768:             Slot slot = findSlotAt(gui, x + off[0], y + off[1]);
4769:             if (slot == null)
4770:             {
4771:                 continue;
4772:             }
4773:             if (slot.getHasStack())
4774:             {
4775:                 ItemStack st = slot.getStack();
4776:                 if (!isGlassPane(st))
4777:                 {
4778:                     if (st.getItem() == allowedItem)
4779:                     {
4780:                         return slot;
4781:                     }
4782:                     if (fallback == null)
4783:                     {
4784:                         fallback = slot;
4785:                     }
4786:                 }
4787:             }
4788:             else if (empty == null)
4789:             {
4790:                 empty = slot;
4791:             }
4792:         }
4793:         return fallback != null ? fallback : empty;
4794:     }
4795: 
4796:     private Slot findSlotAt(GuiContainer gui, int x, int y)
4797:     {
4798:         if (gui == null)
4799:         {
4800:             return null;
4801:         }
4802:         Container container = gui.inventorySlots;
4803:         for (Slot slot : container.inventorySlots)
4804:         {
4805:             if (slot.xPos == x && slot.yPos == y)
4806:             {
4807:                 return slot;
4808:             }
4809:         }
4810:         return null;
4811:     }
4812: 
4813:     private Slot findEmptySlotAt(GuiContainer gui, int x, int y)
4814:     {
4815:         Slot slot = findSlotAt(gui, x, y);
4816:         if (slot == null)
4817:         {
4818:             return null;
4819:         }
4820:         return slot.getHasStack() ? null : slot;
4821:     }
4822: 
4823:     private boolean isTextGlassPane(ItemStack stack)
4824:     {
4825:         if (stack == null || stack.isEmpty())
4826:         {
4827:             return false;
4828:         }
4829:         if (stack.getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE))
4830:         {
4831:             return false;
4832:         }
4833:         if (stack.getMetadata() != 3)
4834:         {
4835:             return false;
4836:         }
4837:         String name = stack.getDisplayName();
4838:         if (name == null)
4839:         {
4840:             return false;
4841:         }
4842:         String clean = TextFormatting.getTextWithoutFormattingCodes(name);
4843:         return clean != null && clean.startsWith("\u0422\u0435\u043a\u0441\u0442");
4844:     }
4845: 
4846:     private boolean isNumberGlassPane(ItemStack stack)
4847:     {
4848:         if (stack == null || stack.isEmpty())
4849:         {
4850:             return false;
4851:         }
4852:         if (stack.getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE))
4853:         {
4854:             return false;
4855:         }
4856:         return stack.getMetadata() == 14;
4857:     }
4858: 
4859:     private boolean isVariableGlassPane(ItemStack stack)
4860:     {
4861:         if (stack == null || stack.isEmpty())
4862:         {
4863:             return false;
4864:         }
4865:         if (stack.getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE))
4866:         {
4867:             return false;
4868:         }
4869:         return stack.getMetadata() == 1;
4870:     }
4871: 
4872:     private boolean isArrayGlassPane(ItemStack stack)
4873:     {
4874:         if (stack == null || stack.isEmpty())
4875:         {
4876:             return false;
4877:         }
4878:         if (stack.getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE))
4879:         {
4880:             return false;
4881:         }
4882:         if (stack.getMetadata() != 5)
4883:         {
4884:             return false;
4885:         }
4886:         return !isLocationGlassPane(stack);
4887:     }
4888: 
4889:     private boolean isLocationGlassPane(ItemStack stack)
4890:     {
4891:         if (stack == null || stack.isEmpty())
4892:         {
4893:             return false;
4894:         }
4895:         if (stack.getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE))
4896:         {
4897:             return false;
4898:         }
4899:         if (stack.getMetadata() != 5)
4900:         {
4901:             return false;
4902:         }
4903:         String name = stack.getDisplayName();
4904:         if (name == null)
4905:         {
4906:             return false;
4907:         }
4908:         String clean = TextFormatting.getTextWithoutFormattingCodes(name);
4909:         if (clean == null)
4910:         {
4911:             return false;
4912:         }
4913:         String lower = clean.toLowerCase(Locale.ROOT);
4914:         return lower.contains("\u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436");
4915:     }
4916: 
4917:     private boolean isGlassPane(ItemStack stack)
4918:     {
4919:         if (stack == null || stack.isEmpty())
4920:         {
4921:             return false;
4922:         }
4923:         return stack.getItem() == net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE);
4924:     }
4925: 
4926:     private void setInputActive(boolean active)
4927:     {
4928:         inputActive = active;
4929:         if (active)
4930:         {
4931:             if (!inputRepeatEnabled)
4932:             {
4933:                 Keyboard.enableRepeatEvents(true);
4934:                 inputRepeatEnabled = true;
4935:             }
4936:             if (inputField != null)
4937:             {
4938:                 inputField.setFocused(true);
4939:             }
4940:         }
4941:         else
4942:         {
4943:             if (inputRepeatEnabled)
4944:             {
4945:                 Keyboard.enableRepeatEvents(false);
4946:                 inputRepeatEnabled = false;
4947:             }
4948:             if (inputField != null)
4949:             {
4950:                 inputField.setFocused(false);
4951:             }
4952:             inputTitle = "";
4953:             inputContext = INPUT_CONTEXT_SLOT;
4954:             inputMode = INPUT_MODE_TEXT;
4955:             inputTargetWindowId = -1;
4956:             inputTargetSlotNumber = -1;
4957:             inputSaveVariable = false;
4958:             shulkerEditActive = false;
4959:             shulkerEditWindowId = -1;
4960:             shulkerEditSlotNumber = -1;
4961:             shulkerEditPos = null;
4962:         }
4963:     }
4964: 
4965:     private void ensureInputField()
4966:     {
4967:         if (inputField == null)
4968:         {
4969:             Minecraft mc = Minecraft.getMinecraft();
4970:             if (mc == null)
4971:             {
4972:                 return;
4973:             }
4974:             inputField = new GuiTextField(0, mc.fontRenderer, 0, 0, 200, 12);
4975:             inputField.setMaxStringLength(256);
4976:             inputField.setEnableBackgroundDrawing(false);
4977:             inputField.setFocused(true);
4978:         }
4979:     }
4980: 
4981:     private String getInputText()
4982:     {
4983:         return inputField == null ? "" : inputField.getText();
4984:     }
4985: 
4986:     private void setInputText(String text)
4987:     {
4988:         ensureInputField();
4989:         if (inputField != null)
4990:         {
4991:             inputField.setText(text == null ? "" : text);
4992:             inputField.setCursorPositionEnd();
4993:         }
4994:     }
4995: 
4996:     private void startSlotInput(GuiContainer container, Slot target, ItemStack template, int mode, String preset,
4997:         String title)
4998:     {
4999:         setInputActive(true);
5000:         setInputText(preset);
5001:         inputTargetWindowId = container.inventorySlots.windowId;
5002:         inputTargetSlotNumber = target.slotNumber;
5003:         inputMode = mode;
5004:         inputContext = INPUT_CONTEXT_SLOT;
5005:         inputSlotTemplate = template == null ? ItemStack.EMPTY : template;
5006:         inputTitle = title == null ? "" : title;
5007:         quickApplyWindowId = container.inventorySlots.windowId;
5008:         quickApplySlotNumber = target.slotNumber;
5009:     }
5010: 
5011:     private void startGiveInput(ItemStack template, int mode, String title)
5012:     {
5013:         setInputActive(true);
5014:         setInputText("");
5015:         inputMode = mode;
5016:         inputContext = INPUT_CONTEXT_GIVE;
5017:         inputGiveTemplate = template == null ? ItemStack.EMPTY : template;
5018:         inputTitle = title == null ? "" : title;
5019:     }
5020: 
5021:     private boolean isShiftDown()
5022:     {
5023:         return Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT);
5024:     }
5025: 
5026:     private void appendVariablePlaceholder(String name)
5027:     {
5028:         if (name == null || name.trim().isEmpty())
5029:         {
5030:             return;
5031:         }
5032:         String placeholder = "%var(" + name.trim() + ")%";
5033:         String raw = getInputText();
5034:         if (raw == null)
5035:         {
5036:             raw = "";
5037:         }
5038:         setInputText(raw + placeholder);
5039:     }
5040: 
5041:     private void applyEntityPlaceholderButton(String token)
5042:     {
5043:         applyEntityPlaceholderButton(token, false);
5044:     }
5045: 
5046:     private void applyEntityPlaceholderButton(String token, boolean forceAppend)
5047:     {
5048:         if (token == null || token.isEmpty())
5049:         {
5050:             return;
5051:         }
5052:         String placeholder = "%" + token + "%";
5053:         String raw = getInputText();
5054:         if (raw == null)
5055:         {
5056:             raw = "";
5057:         }
5058:         if (forceAppend)
5059:         {
5060:             setInputText(raw + placeholder);
5061:             return;
5062:         }
5063:         boolean replaced = false;
5064:         for (String label : ENTITY_BUTTON_LABELS)
5065:         {
5066:             String find = "%" + label + "%";
5067:             if (raw.contains(find))
5068:             {
5069:                 raw = raw.replace(find, placeholder);
5070:                 replaced = true;
5071:             }
5072:         }
5073:         if (!replaced)
5074:         {
5075:             raw += placeholder;
5076:         }
5077:         setInputText(raw);
5078:     }
5079: 
5080:     private void setVariableSavedFlag()
5081:     {
5082:         inputSaveVariable = true;
5083:         setActionBar(true, "&aSaved variable", 1500L);
5084:     }
5085: 
5086:     private void setVariableUnsavedFlag()
5087:     {
5088:         inputSaveVariable = false;
5089:         setActionBar(true, "&cUnsaved variable", 1500L);
5090:     }
5091: 
5092:     private boolean isCurrentVariableSaved()
5093:     {
5094:         if (inputMode != INPUT_MODE_VARIABLE)
5095:         {
5096:             return false;
5097:         }
5098:         String raw = normalizePlainName(getInputText());
5099:         if (raw.isEmpty())
5100:         {
5101:             return inputSaveVariable;
5102:         }
5103:         return inputSaveVariable || savedVariableNames.contains(raw);
5104:     }
5105: 
5106:     private void toggleVariableSavedState()
5107:     {
5108:         String raw = normalizePlainName(getInputText());
5109:         boolean saved = isCurrentVariableSaved();
5110:         if (saved)
5111:         {
5112:             if (!raw.isEmpty())
5113:             {
5114:                 savedVariableNames.remove(raw);
5115:             }
5116:             setVariableUnsavedFlag();
5117:         }
5118:         else
5119:         {
5120:             if (!raw.isEmpty())
5121:             {
5122:                 savedVariableNames.add(raw);
5123:             }
5124:             setVariableSavedFlag();
5125:         }
5126:     }
5127: 
5128:     private String normalizeEntryScopeId(String id)
5129:     {
5130:         if (id == null)
5131:         {
5132:             return "default";
5133:         }
5134:         String clean = id.trim();
5135:         return clean.isEmpty() ? "default" : clean;
5136:     }
5137: 
5138:     private String getCurrentEntryScopeId()
5139:     {
5140:         return normalizeEntryScopeId(getScoreboardIdLine());
5141:     }
5142: 
5143:     private List<InputEntry> getRecentEntries()
5144:     {
5145:         String scope = getCurrentEntryScopeId();
5146:         List<InputEntry> entries = getRecentEntriesForScope(scope);
5147:         if (!"default".equals(scope) && entries.isEmpty())
5148:         {
5149:             return getRecentEntriesForScope("default");
5150:         }
5151:         return entries;
5152:     }
5153: 
5154:     private Map<String, Integer> getEntryCounts()
5155:     {
5156:         String scope = getCurrentEntryScopeId();
5157:         Map<String, Integer> counts = getEntryCountsForScope(scope);
5158:         if (!"default".equals(scope) && counts.isEmpty())
5159:         {
5160:             return getEntryCountsForScope("default");
5161:         }
5162:         return counts;
5163:     }
5164: 
5165:     private List<InputEntry> getRecentEntriesForScope(String scope)
5166:     {
5167:         String key = normalizeEntryScopeId(scope);
5168:         List<InputEntry> entries = recentEntriesById.get(key);
5169:         if (entries == null)
5170:         {
5171:             entries = new ArrayList<>();
5172:             recentEntriesById.put(key, entries);
5173:         }
5174:         return entries;
5175:     }
5176: 
5177:     private Map<String, Integer> getEntryCountsForScope(String scope)
5178:     {
5179:         String key = normalizeEntryScopeId(scope);
5180:         Map<String, Integer> counts = entryCountsById.get(key);
5181:         if (counts == null)
5182:         {
5183:             counts = new HashMap<>();
5184:             entryCountsById.put(key, counts);
5185:         }
5186:         return counts;
5187:     }
5188: 
5189:     private void clearEntryCaches()
5190:     {
5191:         recentEntriesById.clear();
5192:         entryCountsById.clear();
5193:     }
5194: 
5195:     private void recordEntry(int mode, String text)
5196:     {
5197:         if (text == null)
5198:         {
5199:             return;
5200:         }
5201:         String clean = text.trim();
5202:         if (clean.isEmpty())
5203:         {
5204:             return;
5205:         }
5206:         String scope = getCurrentEntryScopeId();
5207:         Map<String, Integer> entryCounts = getEntryCountsForScope(scope);
5208:         List<InputEntry> recentEntries = getRecentEntriesForScope(scope);
5209:         String key = mode + "|" + clean;
5210:         entryCounts.put(key, entryCounts.getOrDefault(key, 0) + 1);
5211:         if (entryCounts.size() > ENTRY_COUNT_MAX)
5212:         {
5213:             entryCounts.clear();
5214:         }
5215:         recentEntries.removeIf(e -> e.mode == mode && e.text.equals(clean));
5216:         recentEntries.add(0, new InputEntry(mode, clean));
5217:         while (recentEntries.size() > ENTRY_RECENT_LIMIT)
5218:         {
5219:             recentEntries.remove(recentEntries.size() - 1);
5220:         }
5221:         entriesDirty = true;
5222:     }
5223: 
5224:     private List<InputEntry> getFrequentEntries()
5225:     {
5226:         List<InputEntry> entries = new ArrayList<>();
5227:         Map<String, Integer> entryCounts = getEntryCounts();
5228:         for (Map.Entry<String, Integer> entry : entryCounts.entrySet())
5229:         {
5230:             if (entry.getValue() < ENTRY_FREQUENT_MIN)
5231:             {
5232:                 continue;
5233:             }
5234:             String key = entry.getKey();
5235:             int sep = key.indexOf('|');
5236:             if (sep <= 0)
5237:             {
5238:                 continue;
5239:             }
5240:             try
5241:             {
5242:                 int mode = Integer.parseInt(key.substring(0, sep));
5243:                 String text = key.substring(sep + 1);
5244:                 entries.add(new InputEntry(mode, text));
5245:             }
5246:             catch (NumberFormatException ignored)
5247:             {
5248:                 // ignore
5249:             }
5250:         }
5251:         entries.sort((a, b) -> {
5252:             int ca = entryCounts.getOrDefault(a.mode + "|" + a.text, 0);
5253:             int cb = entryCounts.getOrDefault(b.mode + "|" + b.text, 0);
5254:             return Integer.compare(cb, ca);
5255:         });
5256:         return entries;
5257:     }
5258: 
5259:     private void applySuggestion()
5260:     {
5261:         String raw = getInputText();
5262:         if (raw.isEmpty())
5263:         {
5264:             return;
5265:         }
5266:         String suggestion = findSuggestion(raw, inputMode);
5267:         if (suggestion == null || suggestion.length() <= raw.length())
5268:         {
5269:             return;
5270:         }
5271:         setInputText(suggestion);
5272:     }
5273: 
5274:     private String findSuggestion(String raw, int mode)
5275:     {
5276:         if (raw == null || raw.isEmpty())
5277:         {
5278:             return null;
5279:         }
5280:         String lower = raw.toLowerCase(Locale.ROOT);
5281:         for (InputEntry entry : getRecentEntries())
5282:         {
5283:             if (entry.mode == mode && entry.text.toLowerCase(Locale.ROOT).startsWith(lower))
5284:             {
5285:                 return entry.text;
5286:             }
5287:         }
5288:         for (InputEntry entry : getFrequentEntries())
5289:         {
5290:             if (entry.mode == mode && entry.text.toLowerCase(Locale.ROOT).startsWith(lower))
5291:             {
5292:                 return entry.text;
5293:             }
5294:         }
5295:         return null;
5296:     }
5297: 
5298:     private void drawSuggestion(Minecraft mc, String raw, int x, int y)
5299:     {
5300:         if (mc == null || mc.fontRenderer == null)
5301:         {
5302:             return;
5303:         }
5304:         String suggestion = findSuggestion(raw, inputMode);
5305:         if (suggestion == null || suggestion.length() <= raw.length())
5306:         {
5307:             return;
5308:         }
5309:         String suffix = suggestion.substring(raw.length());
5310:         int w = mc.fontRenderer.getStringWidth(raw);
5311:         mc.fontRenderer.drawStringWithShadow(suffix, x + w + 2, y, 0x66FFEE);
5312:     }
5313: 
5314:     private String normalizePlainName(String raw)
5315:     {
5316:         if (raw == null)
5317:         {
5318:             return "";
5319:         }
5320:         String text = stripSectionCodes(raw);
5321:         text = stripAmpersandCodes(text);
5322:         text = TextFormatting.getTextWithoutFormattingCodes(text);
5323:         return text == null ? "" : text.trim();
5324:     }
5325: 
5326:     private String stripSectionCodes(String raw)
5327:     {
5328:         if (raw == null)
5329:         {
5330:             return "";
5331:         }
5332:         StringBuilder sb = new StringBuilder();
5333:         for (int i = 0; i < raw.length(); i++)
5334:         {
5335:             char c = raw.charAt(i);
5336:             if (c == '\u00a7' && i + 1 < raw.length())
5337:             {
5338:                 i++;
5339:                 continue;
5340:             }
5341:             sb.append(c);
5342:         }
5343:         return sb.toString();
5344:     }
5345: 
5346:     private String stripAmpersandCodes(String raw)
5347:     {
5348:         if (raw == null)
5349:         {
5350:             return "";
5351:         }
5352:         StringBuilder sb = new StringBuilder();
5353:         for (int i = 0; i < raw.length(); i++)
5354:         {
5355:             char c = raw.charAt(i);
5356:             if (c == '&' && i + 1 < raw.length())
5357:             {
5358:                 char code = Character.toLowerCase(raw.charAt(i + 1));
5359:                 if ((code >= '0' && code <= '9') || (code >= 'a' && code <= 'f') || code == 'k' || code == 'l'
5360:                     || code == 'm' || code == 'n' || code == 'o' || code == 'r')
5361:                 {
5362:                     i++;
5363:                     continue;
5364:                 }
5365:             }
5366:             sb.append(c);
5367:         }
5368:         return sb.toString();
5369:     }
5370: 
5371:     private String getCodeGlassScopeKey(World world)
5372:     {
5373:         int dim = world == null ? 0 : world.provider.getDimension();
5374:         return normalizeEntryScopeId(getScoreboardIdLine()) + ":" + dim;
5375:     }
5376: 
5377:     private void ensureBlueGlassCached(World world)
5378:     {
5379:         if (world == null)
5380:         {
5381:             return;
5382:         }
5383:         String key = getCodeGlassScopeKey(world);
5384:         if (codeBlueGlassById.containsKey(key))
5385:         {
5386:             return;
5387:         }
5388:         BlockPos pos = new BlockPos(219, 0, 219);
5389:         if (isStainedGlassMeta(world, pos, 3))
5390:         {
5391:             codeBlueGlassById.put(key, pos);
5392:             codeBlueGlassDirty = true;
5393:             setActionBar(true, "&aCode glass cached", 1500L);
5394:         }
5395:     }
5396: 
5397:     private void updateBlueGlassFromPlacement(World world, BlockPos placePos)
5398:     {
5399:         if (world == null || placePos == null)
5400:         {
5401:             return;
5402:         }
5403:         BlockPos base = placePos.down();
5404:         BlockPos found = findBlueGlassFromBase(world, base);
5405:         if (found == null)
5406:         {
5407:             return;
5408:         }
5409:         String key = getCodeGlassScopeKey(world);
5410:         BlockPos existing = codeBlueGlassById.get(key);
5411:         if (existing == null || !existing.equals(found))
5412:         {
5413:             codeBlueGlassById.put(key, found);
5414:             codeBlueGlassDirty = true;
5415:             setActionBar(true, "&aCode glass found", 1500L);
5416:         }
5417:     }
5418: 
5419:     private BlockPos findBlueGlassFromBase(World world, BlockPos base)
5420:     {
5421:         if (world == null || base == null)
5422:         {
5423:             return null;
5424:         }
5425:         if (isStainedGlassMeta(world, base, 3))
5426:         {
5427:             return base;
5428:         }
5429:         if (!isStainedGlassMeta(world, base, 8))
5430:         {
5431:             return null;
5432:         }
5433:         BlockPos scan = base;
5434:         for (int i = 0; i < 64; i++)
5435:         {
5436:             if (isStainedGlassMeta(world, scan, 3))
5437:             {
5438:                 return scan;
5439:             }
5440:             if (!isStainedGlassMeta(world, scan, 8))
5441:             {
5442:                 return null;
5443:             }
5444:             scan = scan.add(2, 0, 0);
5445:         }
5446:         return null;
5447:     }
5448: 
5449:     private boolean isStainedGlassMeta(World world, BlockPos pos, int meta)
5450:     {
5451:         if (world == null || pos == null)
5452:         {
5453:             return false;
5454:         }
5455:         IBlockState state = world.getBlockState(pos);
5456:         if (state.getBlock() != Blocks.STAINED_GLASS)
5457:         {
5458:             return false;
5459:         }
5460:         return state.getBlock().getMetaFromState(state) == meta;
5461:     }
5462: 
5463:     private boolean signMatchesQuery(TileEntitySign sign, String queryLower)
5464:     {
5465:         if (sign == null || queryLower == null || queryLower.isEmpty())
5466:         {
5467:             return false;
5468:         }
5469:         for (int i = 0; i < sign.signText.length; i++)
5470:         {
5471:             String raw = sign.signText[i] == null ? "" : sign.signText[i].getUnformattedText();
5472:             String clean = TextFormatting.getTextWithoutFormattingCodes(raw);
5473:             if (clean != null && clean.toLowerCase(Locale.ROOT).contains(queryLower))
5474:             {
5475:                 return true;
5476:             }
5477:         }
5478:         return false;
5479:     }
5480: 
5481:     private String filterNumber(String text)
5482:     {
5483:         if (text == null)
5484:         {
5485:             return "";
5486:         }
5487:         StringBuilder sb = new StringBuilder();
5488:         boolean dot = false;
5489:         boolean minus = false;
5490:         for (int i = 0; i < text.length(); i++)
5491:         {
5492:             char c = text.charAt(i);
5493:             if (c >= '0' && c <= '9')
5494:             {
5495:                 sb.append(c);
5496:             }
5497:             else if (c == '-' && !minus && sb.length() == 0)
5498:             {
5499:                 sb.append(c);
5500:                 minus = true;
5501:             }
5502:             else if (c == '.' && !dot)
5503:             {
5504:                 sb.append(c);
5505:                 dot = true;
5506:             }
5507:         }
5508:         return sb.toString();
5509:     }
5510: 
5511:     private void drawSaveButton(Minecraft mc, int x, int y)
5512:     {
5513:         if (mc == null || mc.fontRenderer == null)
5514:         {
5515:             return;
5516:         }
5517:         boolean saved = isCurrentVariableSaved();
5518:         String label = saved ? "\u00a7c\u00a7lUnsave" : "\u00a7a\u00a7lSave";
5519:         mc.fontRenderer.drawStringWithShadow(label, x, y, 0xFFFFFF);
5520:     }
5521: 
5522:     private void drawVariableButtons(Minecraft mc, int x1, int y1, int boxWidth)
5523:     {
5524:         if (mc == null || mc.fontRenderer == null)
5525:         {
5526:             return;
5527:         }
5528:         int buttonW = 54;
5529:         int buttonH = 10;
5530:         int pad = 4;
5531:         int cols = 5;
5532:         int startX = x1 + 6;
5533:         int startY = y1 + 44;
5534:         for (int i = 0; i < ENTITY_BUTTON_LABELS.length; i++)
5535:         {
5536:             int row = i / cols;
5537:             int col = i % cols;
5538:             int bx = startX + col * (buttonW + pad);
5539:             int by = startY + row * (buttonH + pad);
5540:             Gui.drawRect(bx, by, bx + buttonW, by + buttonH, 0x88202020);
5541:             mc.fontRenderer.drawStringWithShadow("\u00a7b" + ENTITY_BUTTON_LABELS[i], bx + 2, by + 1, 0xFFFFFF);
5542:         }
5543:     }
5544: 
5545:     private int getVariableButtonIndex(int mouseX, int mouseY, GuiScreen gui)
5546:     {
5547:         if (gui == null)
5548:         {
5549:             return -1;
5550:         }
5551:         int width = gui.width;
5552:         int height = gui.height;
5553:         int boxWidth = Math.min(300, width - 40);
5554:         int x1 = (width - boxWidth) / 2;
5555:         int y1 = height - 86;
5556:         int buttonW = 54;
5557:         int buttonH = 10;
5558:         int pad = 4;
5559:         int cols = 5;
5560:         int startX = x1 + 6;
5561:         int startY = y1 + 44;
5562:         for (int i = 0; i < ENTITY_BUTTON_LABELS.length; i++)
5563:         {
5564:             int row = i / cols;
5565:             int col = i % cols;
5566:             int bx = startX + col * (buttonW + pad);
5567:             int by = startY + row * (buttonH + pad);
5568:             if (mouseX >= bx && mouseX <= bx + buttonW && mouseY >= by && mouseY <= by + buttonH)
5569:             {
5570:                 return i;
5571:             }
5572:         }
5573:         return -1;
5574:     }
5575: 
5576:     private boolean handleVariableButtonClick(int mouseX, int mouseY, GuiContainer gui)
5577:     {
5578:         int idx = getVariableButtonIndex(mouseX, mouseY, gui);
5579:         if (idx < 0 || idx >= ENTITY_BUTTON_LABELS.length)
5580:         {
5581:             return false;
5582:         }
5583:         applyEntityPlaceholderButton(ENTITY_BUTTON_LABELS[idx], isShiftDown());
5584:         return true;
5585:     }
5586: 
5587:     private boolean isSaveVariableButtonClicked(int mouseX, int mouseY, GuiScreen gui)
5588:     {
5589:         return isSaveButtonClicked(mouseX, mouseY, gui);
5590:     }
5591: 
5592:     private boolean handleVariableInsertFromSlot(GuiContainer gui)
5593:     {
5594:         if (gui == null || !(inputMode == INPUT_MODE_VARIABLE || inputMode == INPUT_MODE_ARRAY))
5595:         {
5596:             return false;
5597:         }
5598:         Slot hovered = getSlotUnderMouse(gui);
5599:         if (hovered == null || !hovered.getHasStack())
5600:         {
5601:             return false;
5602:         }
5603:         ItemStack stack = hovered.getStack();
5604:         int mode = getModeForItem(stack);
5605:         if (mode != INPUT_MODE_VARIABLE && mode != INPUT_MODE_ARRAY)
5606:         {
5607:             return false;
5608:         }
5609:         String name = normalizePlainName(stack.getDisplayName());
5610:         if (name.isEmpty())
5611:         {
5612:             return false;
5613:         }
5614:         appendVariablePlaceholder(name);
5615:         return true;
5616:     }
5617: 
5618:     private boolean isSaveButtonClicked(int mouseX, int mouseY, GuiScreen gui)
5619:     {
5620:         if (gui == null)
5621:         {
5622:             return false;
5623:         }
5624:         int width = gui.width;
5625:         int height = gui.height;
5626:         int boxWidth = Math.min(300, width - 40);
5627:         int x1 = (width - boxWidth) / 2;
5628:         int y1 = height - 86;
5629:         int x = x1 + boxWidth - 48;
5630:         int y = y1 + 6;
5631:         return mouseX >= x && mouseX <= x + 44 && mouseY >= y && mouseY <= y + 10;
5632:     }
5633: 
5634:     private void appendArrayMark()
5635:     {
5636:         String raw = getInputText();
5637:         setInputText(raw + ARRAY_MARK);
5638:     }
5639: 
5640:     private void handlePendingShulkerEdit(GuiContainer gui)
5641:     {
5642:         if (gui == null)
5643:         {
5644:             return;
5645:         }
5646:         Minecraft mc = Minecraft.getMinecraft();
5647:         if (mc == null || mc.player == null || mc.playerController == null)
5648:         {
5649:             return;
5650:         }
5651:         if (!mc.playerController.isInCreativeMode()
5652:             || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
5653:         {
5654:             setActionBar(true, "&cShulker edit needs Creative", 2000L);
5655:             pendingShulkerEdit = false;
5656:             pendingShulkerPos = null;
5657:             return;
5658:         }
5659:         if (!pendingShulkerEdit || pendingShulkerPos == null)
5660:         {
5661:             return;
5662:         }
5663:         String guiName = gui.getClass().getSimpleName().toLowerCase(Locale.ROOT);
5664:         if (!(gui instanceof GuiShulkerBox) && !guiName.contains("shulker"))
5665:         {
5666:             return;
5667:         }
5668:         Slot target = findShulkerTargetSlot(gui, mc.player);
5669:         if (target == null)
5670:         {
5671:             if (debugUi)
5672:             {
5673:                 setActionBar(false, "&cShulker edit: no slot", 1500L);
5674:             }
5675:             return;
5676:         }
5677:         ItemStack stack = target.getStack();
5678:         if (!stack.isEmpty() && stack.getItem() != Items.BOOK)
5679:         {
5680:             setActionBar(true, "&cShulker slot not book/air", 2000L);
5681:             pendingShulkerEdit = false;
5682:             pendingShulkerPos = null;
5683:             return;
5684:         }
5685:         String preset = stack.isEmpty() ? "" : toAmpersandCodes(stack.getDisplayName());
5686:         ItemStack template = stack.isEmpty() ? new ItemStack(Items.BOOK, 1) : stack.copy();
5687:         startSlotInput(gui, target, template, INPUT_MODE_TEXT, preset, "Shulker Text");
5688:         shulkerEditActive = true;
5689:         shulkerEditWindowId = gui.inventorySlots.windowId;
5690:         shulkerEditSlotNumber = target.slotNumber;
5691:         shulkerEditPos = pendingShulkerPos;
5692:         shulkerEditDim = pendingShulkerDim;
5693:         shulkerEditColor = pendingShulkerColor;
5694:         pendingShulkerEdit = false;
5695:         pendingShulkerPos = null;
5696:         setActionBar(true, "&bEdit shulker text", 1500L);
5697:         if (debugUi)
5698:         {
5699:             setActionBar(false, "&7Shulker slot=" + target.slotNumber + " win=" + gui.inventorySlots.windowId,
5700:                 1500L);
5701:         }
5702:     }
5703: 
5704:     private Slot findLastContainerSlot(GuiContainer gui, EntityPlayer player)
5705:     {
5706:         if (gui == null || player == null)
5707:         {
5708:             return null;
5709:         }
5710:         Slot best = null;
5711:         int bestIndex = -1;
5712:         for (Slot slot : gui.inventorySlots.inventorySlots)
5713:         {
5714:             if (slot.inventory == player.inventory)
5715:             {
5716:                 continue;
5717:             }
5718:             int idx = slot.getSlotIndex();
5719:             if (idx > bestIndex)
5720:             {
5721:                 bestIndex = idx;
5722:                 best = slot;
5723:             }
5724:         }
5725:         return best;
5726:     }
5727: 
5728:     private Slot findFirstContainerSlot(GuiContainer gui, EntityPlayer player)
5729:     {
5730:         if (gui == null || player == null)
5731:         {
5732:             return null;
5733:         }
5734:         Slot best = null;
5735:         int bestIndex = Integer.MAX_VALUE;
5736:         for (Slot slot : gui.inventorySlots.inventorySlots)
5737:         {
5738:             if (slot.inventory == player.inventory)
5739:             {
5740:                 continue;
5741:             }
5742:             int idx = slot.getSlotIndex();
5743:             if (idx < bestIndex)
5744:             {
5745:                 bestIndex = idx;
5746:                 best = slot;
5747:             }
5748:         }
5749:         return best;
5750:     }
5751: 
5752:     private Slot findShulkerTargetSlot(GuiContainer gui, EntityPlayer player)
5753:     {
5754:         if (gui == null || player == null)
5755:         {
5756:             return null;
5757:         }
5758:         Slot firstEmpty = null;
5759:         Slot firstAny = null;
5760:         for (Slot slot : gui.inventorySlots.inventorySlots)
5761:         {
5762:             if (slot.inventory == player.inventory)
5763:             {
5764:                 continue;
5765:             }
5766:             if (firstAny == null)
5767:             {
5768:                 firstAny = slot;
5769:             }
5770:             ItemStack stack = slot.getStack();
5771:             if (!stack.isEmpty() && stack.getItem() == Items.BOOK)
5772:             {
5773:                 return slot;
5774:             }
5775:             if (firstEmpty == null && (stack.isEmpty() || stack.getItem() == Items.AIR))
5776:             {
5777:                 firstEmpty = slot;
5778:             }
5779:         }
5780:         return firstEmpty != null ? firstEmpty : firstAny;
5781:     }
5782: 
5783:     private int getShulkerColor(World world, BlockPos pos, TileEntity tile)
5784:     {
5785:         EnumDyeColor dye = null;
5786:         if (tile instanceof TileEntityShulkerBox)
5787:         {
5788:             dye = ((TileEntityShulkerBox) tile).getColor();
5789:         }
5790:         if (dye == null && world != null)
5791:         {
5792:             IBlockState state = world.getBlockState(pos);
5793:             Block block = state.getBlock();
5794:             if (block instanceof BlockShulkerBox)
5795:             {
5796:                 dye = ((BlockShulkerBox) block).getColor();
5797:             }
5798:         }
5799:         if (dye == null)
5800:         {
5801:             return 0xFFFFFF;
5802:         }
5803:         return dye.getColorValue();
5804:     }
5805: 
5806:     private void saveEntriesIfNeeded()
5807:     {
5808:         if (!entriesDirty || entriesFile == null)
5809:         {
5810:             return;
5811:         }
5812:         long now = System.currentTimeMillis();
5813:         if (now - lastEntriesSaveMs < 10000L)
5814:         {
5815:             return;
5816:         }
5817:         if (entriesSaveQueued.get())
5818:         {
5819:             return;
5820:         }
5821:         lastEntriesSaveMs = now;
5822:         String payload = buildEntriesSnapshot();
5823:         entriesDirty = false;
5824:         entriesSaveQueued.set(true);
5825:         final File target = entriesFile;
5826:         ioExecutor.execute(() -> {
5827:             try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(target), "UTF-8")))
5828:             {
5829:                 writer.write(payload);
5830:             }
5831:             catch (IOException ignored)
5832:             {
5833:                 // ignore
5834:             }
5835:             finally
5836:             {
5837:                 entriesSaveQueued.set(false);
5838:             }
5839:         });
5840:     }
5841: 
5842:     private void saveMenuCacheIfNeeded()
5843:     {
5844:         if (!menuCacheDirty || menuCacheFile == null)
5845:         {
5846:             return;
5847:         }
5848:         long now = System.currentTimeMillis();
5849:         if (now - lastMenuCacheSaveMs < 10000L)
5850:         {
5851:             return;
5852:         }
5853:         if (menuSaveQueued.get())
5854:         {
5855:             return;
5856:         }
5857:         lastMenuCacheSaveMs = now;
5858:         final File target = menuCacheFile;
5859:         final Map<String, CachedMenu> snapshot = new LinkedHashMap<>();
5860:         for (Map.Entry<String, CachedMenu> entry : menuCache.entrySet())
5861:         {
5862:             String key = entry.getKey();
5863:             CachedMenu menu = entry.getValue();
5864:             if (key == null || menu == null)
5865:             {
5866:                 continue;
5867:             }
5868:             snapshot.put(key, new CachedMenu(menu.title, menu.size, copyItemStackList(menu.items), menu.hash));
5869:         }
5870:         final CachedMenu customSnapshot = customMenuCache == null ? null
5871:             : new CachedMenu(customMenuCache.title, customMenuCache.size, copyItemStackList(customMenuCache.items),
5872:                 customMenuCache.hash);
5873:         menuCacheDirty = false;
5874:         menuSaveQueued.set(true);
5875:         ioExecutor.execute(() -> {
5876:             try
5877:             {
5878:                 saveMenuCacheSnapshot(target, snapshot, customSnapshot);
5879:             }
5880:             finally
5881:             {
5882:                 menuSaveQueued.set(false);
5883:             }
5884:         });
5885:     }
5886: 
5887:     private void checkConfigFileChanges()
5888:     {
5889:         if (config == null)
5890:         {
5891:             return;
5892:         }
5893:         long now = System.currentTimeMillis();
5894:         if (now - lastConfigCheckMs < 2000L)
5895:         {
5896:             return;
5897:         }
5898:         lastConfigCheckMs = now;
5899:         File cfg = config.getConfigFile();
5900:         if (cfg == null)
5901:         {
5902:             return;
5903:         }
5904:         long stamp = cfg.lastModified();
5905:         if (stamp != lastConfigStamp)
5906:         {
5907:             lastConfigStamp = stamp;
5908:             syncConfig(true);
5909:             setActionBar(true, "&eConfig reload: hotbar=" + enableSecondHotbar + " holo=#"
5910:                 + String.format(Locale.ROOT, "%06X", chestHoloTextColor), 3000L);
5911:         }
5912:     }
5913: 
5914:     private void saveChestIdCachesIfNeeded()
5915:     {
5916:         if (!chestIdDirty || chestCacheFile == null)
5917:         {
5918:             return;
5919:         }
5920:         long now = System.currentTimeMillis();
5921:         if (now - lastChestIdSaveMs < 10000L)
5922:         {
5923:             return;
5924:         }
5925:         if (chestSaveQueued.get())
5926:         {
5927:             return;
5928:         }
5929:         lastChestIdSaveMs = now;
5930:         final File target = chestCacheFile;
5931:         final Map<String, ChestCache> snapshot = new LinkedHashMap<>();
5932:         for (Map.Entry<String, ChestCache> entry : chestIdCaches.entrySet())
5933:         {
5934:             String id = entry.getKey();
5935:             ChestCache cache = entry.getValue();
5936:             if (id == null || cache == null)
5937:             {
5938:                 continue;
5939:             }
5940:             snapshot.put(id, new ChestCache(cache.dim, cache.pos, copyItemStackList(cache.items),
5941:                 System.currentTimeMillis(), cache.label));
5942:         }
5943:         chestIdDirty = false;
5944:         chestSaveQueued.set(true);
5945:         ioExecutor.execute(() -> {
5946:             try
5947:             {
5948:                 saveChestIdCachesSnapshot(target, snapshot);
5949:             }
5950:             finally
5951:             {
5952:                 chestSaveQueued.set(false);
5953:             }
5954:         });
5955:     }
5956: 
5957:     private void saveShulkerHolosIfNeeded()
5958:     {
5959:         if (!shulkerHoloDirty || shulkerHoloFile == null)
5960:         {
5961:             return;
5962:         }
5963:         long now = System.currentTimeMillis();
5964:         if (now - lastShulkerHoloSaveMs < 10000L)
5965:         {
5966:             return;
5967:         }
5968:         if (shulkerHoloSaveQueued.get())
5969:         {
5970:             return;
5971:         }
5972:         lastShulkerHoloSaveMs = now;
5973:         final File target = shulkerHoloFile;
5974:         final Map<String, ShulkerHolo> snapshot = new LinkedHashMap<>();
5975:         for (Map.Entry<String, ShulkerHolo> entry : shulkerHolos.entrySet())
5976:         {
5977:             String key = entry.getKey();
5978:             ShulkerHolo holo = entry.getValue();
5979:             if (key == null || holo == null || holo.pos == null)
5980:             {
5981:                 continue;
5982:             }
5983:             snapshot.put(key, new ShulkerHolo(holo.dim, holo.pos, holo.text, holo.color));
5984:         }
5985:         shulkerHoloDirty = false;
5986:         shulkerHoloSaveQueued.set(true);
5987:         ioExecutor.execute(() -> {
5988:             try
5989:             {
5990:                 saveShulkerHoloSnapshot(target, snapshot);
5991:             }
5992:             finally
5993:             {
5994:                 shulkerHoloSaveQueued.set(false);
5995:             }
5996:         });
5997:     }
5998: 
5999:     private void saveCodeBlueGlassIfNeeded()
6000:     {
6001:         if (!codeBlueGlassDirty || codeBlueGlassFile == null)
6002:         {
6003:             return;
6004:         }
6005:         long now = System.currentTimeMillis();
6006:         if (now - lastCodeBlueGlassSaveMs < 10000L)
6007:         {
6008:             return;
6009:         }
6010:         if (codeBlueGlassSaveQueued.get())
6011:         {
6012:             return;
6013:         }
6014:         lastCodeBlueGlassSaveMs = now;
6015:         final File target = codeBlueGlassFile;
6016:         final Map<String, BlockPos> snapshot = new LinkedHashMap<>(codeBlueGlassById);
6017:         codeBlueGlassDirty = false;
6018:         codeBlueGlassSaveQueued.set(true);
6019:         ioExecutor.execute(() -> {
6020:             try
6021:             {
6022:                 saveCodeBlueGlassSnapshot(target, snapshot);
6023:             }
6024:             finally
6025:             {
6026:                 codeBlueGlassSaveQueued.set(false);
6027:             }
6028:         });
6029:     }
6030: 
6031:     private void scanChestEntries(GuiChest chest)
6032:     {
6033:         if (chest == null)
6034:         {
6035:             return;
6036:         }
6037:         IInventory inv = getChestInventory(chest);
6038:         if (inv == null)
6039:         {
6040:             return;
6041:         }
6042:         for (int i = 0; i < inv.getSizeInventory(); i++)
6043:         {
6044:             ItemStack stack = inv.getStackInSlot(i);
6045:             if (stack == null || stack.isEmpty())
6046:             {
6047:                 continue;
6048:             }
6049:             int mode = getModeForItem(stack);
6050:             if (mode < 0)
6051:             {
6052:                 continue;
6053:             }
6054:             String text = extractEntryText(stack, mode);
6055:             if (text.isEmpty())
6056:             {
6057:                 continue;
6058:             }
6059:             recordEntryFromChest(mode, text);
6060:             if ((mode == INPUT_MODE_VARIABLE || mode == INPUT_MODE_ARRAY) && isSavedVariableStack(stack))
6061:             {
6062:                 savedVariableNames.add(text);
6063:             }
6064:         }
6065:     }
6066: 
6067:     private String extractEntryText(ItemStack stack, int mode)
6068:     {
6069:         if (stack == null || stack.isEmpty())
6070:         {
6071:             return "";
6072:         }
6073:         if (mode == INPUT_MODE_NUMBER)
6074:         {
6075:             return extractNumber(stack.getDisplayName());
6076:         }
6077:         if (mode == INPUT_MODE_VARIABLE || mode == INPUT_MODE_ARRAY)
6078:         {
6079:             return normalizePlainName(stack.getDisplayName());
6080:         }
6081:         if (mode == INPUT_MODE_LOCATION)
6082:         {
6083:             return toAmpersandCodes(stack.getDisplayName());
6084:         }
6085:         return toAmpersandCodes(stack.getDisplayName());
6086:     }
6087: 
6088:     private void recordEntryFromChest(int mode, String text)
6089:     {
6090:         if (text == null)
6091:         {
6092:             return;
6093:         }
6094:         String clean = text.trim();
6095:         if (clean.isEmpty())
6096:         {
6097:             return;
6098:         }
6099:         Map<String, Integer> entryCounts = getEntryCounts();
6100:         List<InputEntry> recentEntries = getRecentEntries();
6101:         String key = mode + "|" + clean;
6102:         int count = entryCounts.getOrDefault(key, 0) + 1;
6103:         entryCounts.put(key, count);
6104:         if (entryCounts.size() > ENTRY_COUNT_MAX)
6105:         {
6106:             entryCounts.clear();
6107:         }
6108:         boolean exists = false;
6109:         for (InputEntry entry : recentEntries)
6110:         {
6111:             if (entry.mode == mode && entry.text.equals(clean))
6112:             {
6113:                 exists = true;
6114:                 break;
6115:             }
6116:         }
6117:         if (!exists)
6118:         {
6119:             if (recentEntries.size() < ENTRY_RECENT_LIMIT)
6120:             {
6121:                 recentEntries.add(0, new InputEntry(mode, clean));
6122:             }
6123:             else if (count >= 2)
6124:             {
6125:                 int minIdx = -1;
6126:                 int minCount = Integer.MAX_VALUE;
6127:                 for (int i = 0; i < recentEntries.size(); i++)
6128:                 {
6129:                     InputEntry entry = recentEntries.get(i);
6130:                     String eKey = entry.mode + "|" + entry.text;
6131:                     int eCount = entryCounts.getOrDefault(eKey, 0);
6132:                     if (eCount < minCount)
6133:                     {
6134:                         minCount = eCount;
6135:                         minIdx = i;
6136:                     }
6137:                 }
6138:                 if (minIdx >= 0 && count > minCount)
6139:                 {
6140:                     recentEntries.remove(minIdx);
6141:                     recentEntries.add(0, new InputEntry(mode, clean));
6142:                 }
6143:             }
6144:         }
6145:         entriesDirty = true;
6146:     }
6147: 
6148:     private boolean isSavedVariableStack(ItemStack stack)
6149:     {
6150:         if (stack == null || stack.isEmpty() || !stack.hasTagCompound())
6151:         {
6152:             return false;
6153:         }
6154:         NBTTagCompound tag = stack.getTagCompound();
6155:         if (tag == null || !tag.hasKey("display"))
6156:         {
6157:             return false;
6158:         }
6159:         NBTTagCompound display = tag.getCompoundTag("display");
6160:         if (display.hasKey("LocName") && "save".equalsIgnoreCase(display.getString("LocName")))
6161:         {
6162:             return true;
6163:         }
6164:         if (display.hasKey("Lore"))
6165:         {
6166:             NBTTagList lore = display.getTagList("Lore", 8);
6167:             if (lore.tagCount() > 0)
6168:             {
6169:                 String first = lore.getStringTagAt(0);
6170:                 return first != null && first.contains("\u00a7d\u0421\u041e\u0425\u0420\u0410\u041d\u0415\u041d\u041e");
6171:             }
6172:         }
6173:         return false;
6174:     }
6175: 
6176:     private void applySavedVariableTag(ItemStack stack)
6177:     {
6178:         if (stack == null || stack.isEmpty())
6179:         {
6180:             return;
6181:         }
6182:         NBTTagCompound tag = stack.getTagCompound();
6183:         if (tag == null)
6184:         {
6185:             tag = new NBTTagCompound();
6186:         }
6187:         NBTTagCompound display = tag.hasKey("display") ? tag.getCompoundTag("display") : new NBTTagCompound();
6188:         display.setString("LocName", "save");
6189:         NBTTagList lore = display.hasKey("Lore") ? display.getTagList("Lore", 8) : new NBTTagList();
6190:         if (lore.tagCount() == 0)
6191:         {
6192:             lore.appendTag(new NBTTagString("\u00a7d\u0421\u041e\u0425\u0420\u0410\u041d\u0415\u041d\u041e"));
6193:         }
6194:         else
6195:         {
6196:             String first = lore.getStringTagAt(0);
6197:             if (first == null || !first.contains("\u00a7d\u0421\u041e\u0425\u0420\u0410\u041d\u0415\u041d\u041e"))
6198:             {
6199:                 NBTTagList newLore = new NBTTagList();
6200:                 newLore.appendTag(new NBTTagString("\u00a7d\u0421\u041e\u0425\u0420\u0410\u041d\u0415\u041d\u041e"));
6201:                 for (int i = 0; i < lore.tagCount(); i++)
6202:                 {
6203:                     newLore.appendTag(lore.get(i));
6204:                 }
6205:                 lore = newLore;
6206:             }
6207:         }
6208:         display.setTag("Lore", lore);
6209:         tag.setTag("display", display);
6210:         stack.setTagCompound(tag);
6211:     }
6212: 
6213:     private void removeSavedVariableTag(ItemStack stack)
6214:     {
6215:         if (stack == null || stack.isEmpty() || !stack.hasTagCompound())
6216:         {
6217:             return;
6218:         }
6219:         NBTTagCompound tag = stack.getTagCompound();
6220:         if (tag == null || !tag.hasKey("display"))
6221:         {
6222:             return;
6223:         }
6224:         NBTTagCompound display = tag.getCompoundTag("display");
6225:         if (display.hasKey("LocName") && "save".equalsIgnoreCase(display.getString("LocName")))
6226:         {
6227:             display.removeTag("LocName");
6228:         }
6229:         if (display.hasKey("Lore"))
6230:         {
6231:             NBTTagList lore = display.getTagList("Lore", 8);
6232:             if (lore.tagCount() > 0)
6233:             {
6234:                 String first = lore.getStringTagAt(0);
6235:                 if (first != null && first.contains("\u00a7d\u0421\u041e\u0425\u0420\u0410\u041d\u0415\u041d\u041e"))
6236:                 {
6237:                     NBTTagList newLore = new NBTTagList();
6238:                     for (int i = 1; i < lore.tagCount(); i++)
6239:                     {
6240:                         newLore.appendTag(lore.get(i));
6241:                     }
6242:                     lore = newLore;
6243:                 }
6244:             }
6245:             if (lore.tagCount() > 0)
6246:             {
6247:                 display.setTag("Lore", lore);
6248:             }
6249:             else
6250:             {
6251:                 display.removeTag("Lore");
6252:             }
6253:         }
6254:         tag.setTag("display", display);
6255:         stack.setTagCompound(tag);
6256:     }
6257: 
6258:     private void saveNote()
6259:     {
6260:         if (noteFile == null)
6261:         {
6262:             return;
6263:         }
6264:         try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(noteFile), "UTF-8")))
6265:         {
6266:             writer.write(noteText == null ? "" : noteText);
6267:         }
6268:         catch (Exception e)
6269:         {
6270:             // ignore
6271:         }
6272:     }
6273: 
6274:     private String buildEntriesSnapshot()
6275:     {
6276:         StringBuilder sb = new StringBuilder();
6277:         Set<String> scopes = new LinkedHashSet<>();
6278:         scopes.addAll(recentEntriesById.keySet());
6279:         scopes.addAll(entryCountsById.keySet());
6280:         if (scopes.isEmpty())
6281:         {
6282:             scopes.add("default");
6283:         }
6284:         sb.append("{\"recent\":[");
6285:         boolean firstRecent = true;
6286:         for (String scope : scopes)
6287:         {
6288:             List<InputEntry> list = recentEntriesById.get(scope);
6289:             if (list == null)
6290:             {
6291:                 continue;
6292:             }
6293:             for (InputEntry e : list)
6294:             {
6295:                 if (!firstRecent)
6296:                 {
6297:                     sb.append(",");
6298:                 }
6299:                 firstRecent = false;
6300:                 sb.append("{\"id\":\"");
6301:                 sb.append(escapeJson(scope));
6302:                 sb.append("\",\"mode\":");
6303:                 sb.append(Integer.toString(e.mode));
6304:                 sb.append(",\"text\":\"");
6305:                 sb.append(escapeJson(e.text));
6306:                 sb.append("\"}");
6307:             }
6308:         }
6309:         sb.append("],\"counts\":[");
6310:         boolean firstCount = true;
6311:         for (String scope : scopes)
6312:         {
6313:             Map<String, Integer> counts = entryCountsById.get(scope);
6314:             if (counts == null)
6315:             {
6316:                 continue;
6317:             }
6318:             for (Map.Entry<String, Integer> entry : counts.entrySet())
6319:             {
6320:                 if (!firstCount)
6321:                 {
6322:                     sb.append(",");
6323:                 }
6324:                 firstCount = false;
6325:                 sb.append("{\"id\":\"");
6326:                 sb.append(escapeJson(scope));
6327:                 sb.append("\",\"key\":\"");
6328:                 sb.append(escapeJson(entry.getKey()));
6329:                 sb.append("\",\"count\":");
6330:                 sb.append(Integer.toString(entry.getValue()));
6331:                 sb.append("}");
6332:             }
6333:         }
6334:         sb.append("]}");
6335:         return sb.toString();
6336:     }
6337: 
6338:     private List<ItemStack> copyItemStackList(List<ItemStack> items)
6339:     {
6340:         List<ItemStack> copy = new ArrayList<>();
6341:         if (items == null)
6342:         {
6343:             return copy;
6344:         }
6345:         for (ItemStack stack : items)
6346:         {
6347:             copy.add(stack == null || stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
6348:         }
6349:         return copy;
6350:     }
6351: 
6352:     private void saveChestIdCaches()
6353:     {
6354:         if (chestCacheFile == null)
6355:         {
6356:             return;
6357:         }
6358:         try
6359:         {
6360:             NBTTagCompound root = new NBTTagCompound();
6361:             NBTTagList list = new NBTTagList();
6362:             for (Map.Entry<String, ChestCache> entry : chestIdCaches.entrySet())
6363:             {
6364:                 String id = entry.getKey();
6365:                 ChestCache cache = entry.getValue();
6366:                 if (id == null || cache == null)
6367:                 {
6368:                     continue;
6369:                 }
6370:                 NBTTagCompound tag = new NBTTagCompound();
6371:                 tag.setString("Id", id);
6372:                 tag.setString("Label", cache.label == null ? "" : cache.label);
6373:                 tag.setInteger("Dim", cache.dim);
6374:                 tag.setInteger("X", cache.pos == null ? 0 : cache.pos.getX());
6375:                 tag.setInteger("Y", cache.pos == null ? 0 : cache.pos.getY());
6376:                 tag.setInteger("Z", cache.pos == null ? 0 : cache.pos.getZ());
6377:                 NBTTagList items = new NBTTagList();
6378:                 for (ItemStack stack : cache.items)
6379:                 {
6380:                     NBTTagCompound itemTag = new NBTTagCompound();
6381:                     if (!stack.isEmpty())
6382:                     {
6383:                         stack.writeToNBT(itemTag);
6384:                     }
6385:                     items.appendTag(itemTag);
6386:                 }
6387:                 tag.setTag("Items", items);
6388:                 list.appendTag(tag);
6389:             }
6390:             root.setTag("Caches", list);
6391:             CompressedStreamTools.write(root, chestCacheFile);
6392:         }
6393:         catch (Exception e)
6394:         {
6395:             // ignore
6396:         }
6397:     }
6398: 
6399:     private void saveChestIdCachesSnapshot(File target, Map<String, ChestCache> snapshot)
6400:     {
6401:         if (target == null)
6402:         {
6403:             return;
6404:         }
6405:         try
6406:         {
6407:             NBTTagCompound root = new NBTTagCompound();
6408:             NBTTagList list = new NBTTagList();
6409:             for (Map.Entry<String, ChestCache> entry : snapshot.entrySet())
6410:             {
6411:                 String id = entry.getKey();
6412:                 ChestCache cache = entry.getValue();
6413:                 if (id == null || cache == null)
6414:                 {
6415:                     continue;
6416:                 }
6417:                 NBTTagCompound tag = new NBTTagCompound();
6418:                 tag.setString("Id", id);
6419:                 tag.setString("Label", cache.label == null ? "" : cache.label);
6420:                 tag.setInteger("Dim", cache.dim);
6421:                 tag.setInteger("X", cache.pos == null ? 0 : cache.pos.getX());
6422:                 tag.setInteger("Y", cache.pos == null ? 0 : cache.pos.getY());
6423:                 tag.setInteger("Z", cache.pos == null ? 0 : cache.pos.getZ());
6424:                 NBTTagList items = new NBTTagList();
6425:                 for (ItemStack stack : cache.items)
6426:                 {
6427:                     NBTTagCompound itemTag = new NBTTagCompound();
6428:                     if (stack != null && !stack.isEmpty())
6429:                     {
6430:                         stack.writeToNBT(itemTag);
6431:                     }
6432:                     items.appendTag(itemTag);
6433:                 }
6434:                 tag.setTag("Items", items);
6435:                 list.appendTag(tag);
6436:             }
6437:             root.setTag("Caches", list);
6438:             CompressedStreamTools.write(root, target);
6439:         }
6440:         catch (Exception e)
6441:         {
6442:             // ignore
6443:         }
6444:     }
6445: 
6446:     private void loadChestIdCaches()
6447:     {
6448:         if (chestCacheFile == null || !chestCacheFile.exists())
6449:         {
6450:             return;
6451:         }
6452:         try
6453:         {
6454:             NBTTagCompound root = CompressedStreamTools.read(chestCacheFile);
6455:             if (root == null || !root.hasKey("Caches", 9))
6456:             {
6457:                 return;
6458:             }
6459:             NBTTagList list = root.getTagList("Caches", 10);
6460:             chestIdCaches.clear();
6461:             for (int i = 0; i < list.tagCount(); i++)
6462:             {
6463:                 NBTTagCompound tag = list.getCompoundTagAt(i);
6464:                 String id = tag.getString("Id");
6465:                 String label = tag.getString("Label");
6466:                 int dim = tag.hasKey("Dim") ? tag.getInteger("Dim") : 0;
6467:                 int x = tag.hasKey("X") ? tag.getInteger("X") : 0;
6468:                 int y = tag.hasKey("Y") ? tag.getInteger("Y") : 0;
6469:                 int z = tag.hasKey("Z") ? tag.getInteger("Z") : 0;
6470:                 NBTTagList itemsTag = tag.getTagList("Items", 10);
6471:                 List<ItemStack> items = new ArrayList<>();
6472:                 for (int j = 0; j < itemsTag.tagCount(); j++)
6473:                 {
6474:                     NBTTagCompound itemTag = itemsTag.getCompoundTagAt(j);
6475:                     ItemStack stack = new ItemStack(itemTag);
6476:                     items.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
6477:                 }
6478:                 if (id != null && !id.isEmpty())
6479:                 {
6480:                     BlockPos pos = new BlockPos(x, y, z);
6481:                     chestIdCaches.put(id, new ChestCache(dim, pos, items, System.currentTimeMillis(), label));
6482:                 }
6483:             }
6484:         }
6485:         catch (Exception e)
6486:         {
6487:             // ignore
6488:         }
6489:     }
6490: 
6491:     private void saveMenuCache()
6492:     {
6493:         if (menuCacheFile == null)
6494:         {
6495:             return;
6496:         }
6497:         try
6498:         {
6499:             NBTTagCompound root = new NBTTagCompound();
6500:             NBTTagList list = new NBTTagList();
6501:             for (Map.Entry<String, CachedMenu> entry : menuCache.entrySet())
6502:             {
6503:                 String key = entry.getKey();
6504:                 CachedMenu menu = entry.getValue();
6505:                 if (key == null || menu == null)
6506:                 {
6507:                     continue;
6508:                 }
6509:                 NBTTagCompound tag = new NBTTagCompound();
6510:                 tag.setString("Key", key);
6511:                 tag.setString("Title", menu.title == null ? "" : menu.title);
6512:                 tag.setInteger("Size", menu.size);
6513:                 tag.setString("Hash", menu.hash == null ? "" : menu.hash);
6514:                 NBTTagList items = new NBTTagList();
6515:                 for (ItemStack stack : menu.items)
6516:                 {
6517:                     NBTTagCompound itemTag = new NBTTagCompound();
6518:                     if (!stack.isEmpty())
6519:                     {
6520:                         stack.writeToNBT(itemTag);
6521:                     }
6522:                     items.appendTag(itemTag);
6523:                 }
6524:                 tag.setTag("Items", items);
6525:                 list.appendTag(tag);
6526:             }
6527:             root.setTag("Menus", list);
6528:             if (customMenuCache != null)
6529:             {
6530:                 NBTTagCompound custom = new NBTTagCompound();
6531:                 custom.setString("Title", customMenuCache.title == null ? "" : customMenuCache.title);
6532:                 custom.setInteger("Size", customMenuCache.size);
6533:                 custom.setString("Hash", customMenuCache.hash == null ? "" : customMenuCache.hash);
6534:                 NBTTagList items = new NBTTagList();
6535:                 for (ItemStack stack : customMenuCache.items)
6536:                 {
6537:                     NBTTagCompound itemTag = new NBTTagCompound();
6538:                     if (!stack.isEmpty())
6539:                     {
6540:                         stack.writeToNBT(itemTag);
6541:                     }
6542:                     items.appendTag(itemTag);
6543:                 }
6544:                 custom.setTag("Items", items);
6545:                 root.setTag("Custom", custom);
6546:             }
6547:             CompressedStreamTools.write(root, menuCacheFile);
6548:         }
6549:         catch (Exception e)
6550:         {
6551:             // ignore
6552:         }
6553:     }
6554: 
6555:     private void saveMenuCacheSnapshot(File target, Map<String, CachedMenu> snapshot, CachedMenu customSnapshot)
6556:     {
6557:         if (target == null)
6558:         {
6559:             return;
6560:         }
6561:         try
6562:         {
6563:             NBTTagCompound root = new NBTTagCompound();
6564:             NBTTagList list = new NBTTagList();
6565:             for (Map.Entry<String, CachedMenu> entry : snapshot.entrySet())
6566:             {
6567:                 String key = entry.getKey();
6568:                 CachedMenu menu = entry.getValue();
6569:                 if (key == null || menu == null)
6570:                 {
6571:                     continue;
6572:                 }
6573:                 NBTTagCompound tag = new NBTTagCompound();
6574:                 tag.setString("Key", key);
6575:                 tag.setString("Title", menu.title == null ? "" : menu.title);
6576:                 tag.setInteger("Size", menu.size);
6577:                 tag.setString("Hash", menu.hash == null ? "" : menu.hash);
6578:                 NBTTagList items = new NBTTagList();
6579:                 for (ItemStack stack : menu.items)
6580:                 {
6581:                     NBTTagCompound itemTag = new NBTTagCompound();
6582:                     if (stack != null && !stack.isEmpty())
6583:                     {
6584:                         stack.writeToNBT(itemTag);
6585:                     }
6586:                     items.appendTag(itemTag);
6587:                 }
6588:                 tag.setTag("Items", items);
6589:                 list.appendTag(tag);
6590:             }
6591:             root.setTag("Menus", list);
6592:             if (customSnapshot != null)
6593:             {
6594:                 NBTTagCompound custom = new NBTTagCompound();
6595:                 custom.setString("Title", customSnapshot.title == null ? "" : customSnapshot.title);
6596:                 custom.setInteger("Size", customSnapshot.size);
6597:                 custom.setString("Hash", customSnapshot.hash == null ? "" : customSnapshot.hash);
6598:                 NBTTagList items = new NBTTagList();
6599:                 for (ItemStack stack : customSnapshot.items)
6600:                 {
6601:                     NBTTagCompound itemTag = new NBTTagCompound();
6602:                     if (stack != null && !stack.isEmpty())
6603:                     {
6604:                         stack.writeToNBT(itemTag);
6605:                     }
6606:                     items.appendTag(itemTag);
6607:                 }
6608:                 custom.setTag("Items", items);
6609:                 root.setTag("Custom", custom);
6610:             }
6611:             CompressedStreamTools.write(root, target);
6612:         }
6613:         catch (Exception e)
6614:         {
6615:             // ignore
6616:         }
6617:     }
6618: 
6619:     private void saveShulkerHoloSnapshot(File target, Map<String, ShulkerHolo> snapshot)
6620:     {
6621:         if (target == null)
6622:         {
6623:             return;
6624:         }
6625:         try
6626:         {
6627:             NBTTagCompound root = new NBTTagCompound();
6628:             NBTTagList list = new NBTTagList();
6629:             for (ShulkerHolo holo : snapshot.values())
6630:             {
6631:                 if (holo == null || holo.pos == null)
6632:                 {
6633:                     continue;
6634:                 }
6635:                 NBTTagCompound tag = new NBTTagCompound();
6636:                 tag.setInteger("Dim", holo.dim);
6637:                 tag.setInteger("X", holo.pos.getX());
6638:                 tag.setInteger("Y", holo.pos.getY());
6639:                 tag.setInteger("Z", holo.pos.getZ());
6640:                 tag.setInteger("Color", holo.color);
6641:                 tag.setString("Text", holo.text == null ? "" : holo.text);
6642:                 list.appendTag(tag);
6643:             }
6644:             root.setTag("Holos", list);
6645:             CompressedStreamTools.write(root, target);
6646:         }
6647:         catch (Exception e)
6648:         {
6649:             // ignore
6650:         }
6651:     }
6652: 
6653:     private void saveCodeBlueGlassSnapshot(File target, Map<String, BlockPos> snapshot)
6654:     {
6655:         if (target == null)
6656:         {
6657:             return;
6658:         }
6659:         try
6660:         {
6661:             NBTTagCompound root = new NBTTagCompound();
6662:             NBTTagList list = new NBTTagList();
6663:             for (Map.Entry<String, BlockPos> entry : snapshot.entrySet())
6664:             {
6665:                 String key = entry.getKey();
6666:                 BlockPos pos = entry.getValue();
6667:                 if (key == null || pos == null)
6668:                 {
6669:                     continue;
6670:                 }
6671:                 NBTTagCompound tag = new NBTTagCompound();
6672:                 tag.setString("Key", key);
6673:                 tag.setInteger("X", pos.getX());
6674:                 tag.setInteger("Y", pos.getY());
6675:                 tag.setInteger("Z", pos.getZ());
6676:                 list.appendTag(tag);
6677:             }
6678:             root.setTag("Blue", list);
6679:             CompressedStreamTools.write(root, target);
6680:         }
6681:         catch (Exception e)
6682:         {
6683:             // ignore
6684:         }
6685:     }
6686: 
6687:     private void loadShulkerHolos()
6688:     {
6689:         if (shulkerHoloFile == null || !shulkerHoloFile.exists())
6690:         {
6691:             return;
6692:         }
6693:         try
6694:         {
6695:             NBTTagCompound root = CompressedStreamTools.read(shulkerHoloFile);
6696:             if (root == null || !root.hasKey("Holos", 9))
6697:             {
6698:                 return;
6699:             }
6700:             NBTTagList list = root.getTagList("Holos", 10);
6701:             shulkerHolos.clear();
6702:             for (int i = 0; i < list.tagCount(); i++)
6703:             {
6704:                 NBTTagCompound tag = list.getCompoundTagAt(i);
6705:                 int dim = tag.hasKey("Dim") ? tag.getInteger("Dim") : 0;
6706:                 int x = tag.hasKey("X") ? tag.getInteger("X") : 0;
6707:                 int y = tag.hasKey("Y") ? tag.getInteger("Y") : 0;
6708:                 int z = tag.hasKey("Z") ? tag.getInteger("Z") : 0;
6709:                 int color = tag.hasKey("Color") ? tag.getInteger("Color") : 0xFFFFFF;
6710:                 String text = tag.getString("Text");
6711:                 BlockPos pos = new BlockPos(x, y, z);
6712:                 String key = dim + ":" + pos.toString();
6713:                 shulkerHolos.put(key, new ShulkerHolo(dim, pos, text, color));
6714:             }
6715:         }
6716:         catch (Exception e)
6717:         {
6718:             // ignore
6719:         }
6720:     }
6721: 
6722:     private void loadCodeBlueGlass()
6723:     {
6724:         if (codeBlueGlassFile == null || !codeBlueGlassFile.exists())
6725:         {
6726:             return;
6727:         }
6728:         try
6729:         {
6730:             NBTTagCompound root = CompressedStreamTools.read(codeBlueGlassFile);
6731:             if (root == null || !root.hasKey("Blue", 9))
6732:             {
6733:                 return;
6734:             }
6735:             NBTTagList list = root.getTagList("Blue", 10);
6736:             codeBlueGlassById.clear();
6737:             for (int i = 0; i < list.tagCount(); i++)
6738:             {
6739:                 NBTTagCompound tag = list.getCompoundTagAt(i);
6740:                 String key = tag.getString("Key");
6741:                 int x = tag.hasKey("X") ? tag.getInteger("X") : 0;
6742:                 int y = tag.hasKey("Y") ? tag.getInteger("Y") : 0;
6743:                 int z = tag.hasKey("Z") ? tag.getInteger("Z") : 0;
6744:                 if (key != null && !key.isEmpty())
6745:                 {
6746:                     codeBlueGlassById.put(key, new BlockPos(x, y, z));
6747:                 }
6748:             }
6749:         }
6750:         catch (Exception e)
6751:         {
6752:             // ignore
6753:         }
6754:     }
6755: 
6756:     private void loadMenuCache()
6757:     {
6758:         if (menuCacheFile == null || !menuCacheFile.exists())
6759:         {
6760:             return;
6761:         }
6762:         try
6763:         {
6764:             NBTTagCompound root = CompressedStreamTools.read(menuCacheFile);
6765:             if (root == null)
6766:             {
6767:                 return;
6768:             }
6769:             if (root.hasKey("Menus", 9))
6770:             {
6771:                 NBTTagList list = root.getTagList("Menus", 10);
6772:                 menuCache.clear();
6773:                 for (int i = 0; i < list.tagCount(); i++)
6774:                 {
6775:                     NBTTagCompound tag = list.getCompoundTagAt(i);
6776:                     String key = tag.getString("Key");
6777:                     String title = tag.getString("Title");
6778:                     int size = tag.getInteger("Size");
6779:                     String hash = tag.getString("Hash");
6780:                     NBTTagList itemsTag = tag.getTagList("Items", 10);
6781:                     List<ItemStack> items = new ArrayList<>();
6782:                     for (int j = 0; j < itemsTag.tagCount(); j++)
6783:                     {
6784:                         NBTTagCompound itemTag = itemsTag.getCompoundTagAt(j);
6785:                         ItemStack stack = new ItemStack(itemTag);
6786:                         items.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
6787:                     }
6788:                     if (key != null && !key.isEmpty())
6789:                     {
6790:                         menuCache.put(key, new CachedMenu(title, size, items, hash));
6791:                     }
6792:                 }
6793:             }
6794:             if (root.hasKey("Custom", 10))
6795:             {
6796:                 NBTTagCompound custom = root.getCompoundTag("Custom");
6797:                 String title = custom.getString("Title");
6798:                 int size = custom.getInteger("Size");
6799:                 String hash = custom.getString("Hash");
6800:                 NBTTagList itemsTag = custom.getTagList("Items", 10);
6801:                 List<ItemStack> items = new ArrayList<>();
6802:                 for (int j = 0; j < itemsTag.tagCount(); j++)
6803:                 {
6804:                     NBTTagCompound itemTag = itemsTag.getCompoundTagAt(j);
6805:                     ItemStack stack = new ItemStack(itemTag);
6806:                     items.add(stack.isEmpty() ? ItemStack.EMPTY : stack.copy());
6807:                 }
6808:                 customMenuCache = new CachedMenu(title, size, items, hash);
6809:             }
6810:         }
6811:         catch (Exception e)
6812:         {
6813:             // ignore
6814:         }
6815:     }
6816: 
6817:     private void loadNote()
6818:     {
6819:         if (noteFile == null || !noteFile.exists())
6820:         {
6821:             noteText = "";
6822:             return;
6823:         }
6824:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(noteFile), "UTF-8")))
6825:         {
6826:             StringBuilder sb = new StringBuilder();
6827:             String line;
6828:             while ((line = reader.readLine()) != null)
6829:             {
6830:                 if (sb.length() > 0)
6831:                 {
6832:                     sb.append('\n');
6833:                 }
6834:                 sb.append(line);
6835:             }
6836:             noteText = sb.toString();
6837:         }
6838:         catch (Exception e)
6839:         {
6840:             noteText = "";
6841:         }
6842:     }
6843: 
6844:     private void loadEntries()
6845:     {
6846:         if (entriesFile == null || !entriesFile.exists())
6847:         {
6848:             return;
6849:         }
6850:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(entriesFile), "UTF-8")))
6851:         {
6852:             StringBuilder sb = new StringBuilder();
6853:             String line;
6854:             while ((line = reader.readLine()) != null)
6855:             {
6856:                 sb.append(line);
6857:             }
6858:             String json = sb.toString();
6859:             parseEntriesJson(json);
6860:         }
6861:         catch (IOException ignored)
6862:         {
6863:             // ignore
6864:         }
6865:     }
6866: 
6867:     private void parseEntriesJson(String json)
6868:     {
6869:         if (json == null || json.isEmpty())
6870:         {
6871:             return;
6872:         }
6873:         clearEntryCaches();
6874:         parseEntryArray(json, "\"recent\":[", true);
6875:         parseEntryArray(json, "\"counts\":[", false);
6876:     }
6877: 
6878:     private void parseEntryArray(String json, String marker, boolean isRecent)
6879:     {
6880:         int start = json.indexOf(marker);
6881:         if (start < 0)
6882:         {
6883:             return;
6884:         }
6885:         start += marker.length();
6886:         int end = json.indexOf("]", start);
6887:         if (end < 0)
6888:         {
6889:             return;
6890:         }
6891:         String body = json.substring(start, end);
6892:         String[] parts = body.split("\\},\\{");
6893:         for (String part : parts)
6894:         {
6895:             String p = part.replace("{", "").replace("}", "");
6896:             String idStr = extractJsonField(p, "id");
6897:             String modeStr = extractJsonField(p, "mode");
6898:             String textStr = extractJsonField(p, "text");
6899:             String keyStr = extractJsonField(p, "key");
6900:             String countStr = extractJsonField(p, "count");
6901:             String scope = normalizeEntryScopeId(idStr);
6902:             if (isRecent)
6903:             {
6904:                 if (modeStr != null && textStr != null)
6905:                 {
6906:                     try
6907:                     {
6908:                         int mode = Integer.parseInt(modeStr.trim());
6909:                         getRecentEntriesForScope(scope).add(new InputEntry(mode, textStr));
6910:                     }
6911:                     catch (NumberFormatException ignored)
6912:                     {
6913:                         // ignore
6914:                     }
6915:                 }
6916:             }
6917:             else
6918:             {
6919:                 if (keyStr != null && countStr != null)
6920:                 {
6921:                     try
6922:                     {
6923:                         int count = Integer.parseInt(countStr.trim());
6924:                         getEntryCountsForScope(scope).put(keyStr, count);
6925:                     }
6926:                     catch (NumberFormatException ignored)
6927:                     {
6928:                         // ignore
6929:                     }
6930:                 }
6931:             }
6932:         }
6933:     }
6934: 
6935:     private String extractJsonField(String text, String field)
6936:     {
6937:         String needle = "\"" + field + "\":";
6938:         int idx = text.indexOf(needle);
6939:         if (idx < 0)
6940:         {
6941:             return null;
6942:         }
6943:         idx += needle.length();
6944:         if (idx >= text.length())
6945:         {
6946:             return null;
6947:         }
6948:         if (text.charAt(idx) == '"')
6949:         {
6950:             idx++;
6951:             int end = text.indexOf("\"", idx);
6952:             if (end < 0)
6953:             {
6954:                 return null;
6955:             }
6956:             String raw = text.substring(idx, end);
6957:             return raw.replace("\\\"", "\"").replace("\\\\", "\\");
6958:         }
6959:         int end = text.indexOf(",", idx);
6960:         if (end < 0)
6961:         {
6962:             end = text.length();
6963:         }
6964:         return text.substring(idx, end);
6965:     }
6966: 
6967:     private void drawSidePanels(GuiContainer gui, int mouseX, int mouseY)
6968:     {
6969:         Minecraft mc = Minecraft.getMinecraft();
6970:         if (mc == null || mc.fontRenderer == null)
6971:         {
6972:             return;
6973:         }
6974:         int left = getGuiLeft(gui);
6975:         int top = getGuiTop(gui);
6976:         int xSize = getGuiXSize(gui);
6977:         int ySize = getGuiYSize(gui);
6978: 
6979:         int panelWidth = 120;
6980:         int rightX = left + xSize + 6;
6981:         int rightY = top;
6982:         net.minecraft.client.gui.Gui.drawRect(rightX, rightY, rightX + panelWidth, rightY + ySize, 0x66000000);
6983: 
6984:         int y = rightY + 6;
6985:         mc.fontRenderer.drawStringWithShadow("Recent", rightX + 4, y, 0xAAAAAA);
6986:         y += 12;
6987:         for (InputEntry entry : getRecentEntries())
6988:         {
6989:             String line = formatEntryLine(entry);
6990:             mc.fontRenderer.drawStringWithShadow(line, rightX + 4, y, 0xFFFFFF);
6991:             y += 10;
6992:             if (y > rightY + ySize - 20)
6993:             {
6994:                 break;
6995:             }
6996:         }
6997: 
6998:         y += 4;
6999:         mc.fontRenderer.drawStringWithShadow("Frequent", rightX + 4, y, 0xAAAAAA);
7000:         y += 12;
7001:         for (InputEntry entry : getFrequentEntries())
7002:         {
7003:             String line = formatEntryLine(entry);
7004:             mc.fontRenderer.drawStringWithShadow(line, rightX + 4, y, 0xFFFFFF);
7005:             y += 10;
7006:             if (y > rightY + ySize - 10)
7007:             {
7008:                 break;
7009:             }
7010:         }
7011: 
7012:         int btnWidth = panelWidth - 8;
7013:         int btnHeight = 12;
7014:         int btnX = rightX + 4;
7015:         int btnY2 = rightY + ySize - btnHeight - 4;
7016:         int btnY1 = btnY2 - btnHeight - 2;
7017:         net.minecraft.client.gui.Gui.drawRect(btnX, btnY1, btnX + btnWidth, btnY1 + btnHeight, 0x88000000);
7018:         net.minecraft.client.gui.Gui.drawRect(btnX, btnY2, btnX + btnWidth, btnY2 + btnHeight, 0x88000000);
7019:         mc.fontRenderer.drawStringWithShadow("Export Raw", btnX + 4, btnY1 + 2, 0xFFFFFF);
7020:         mc.fontRenderer.drawStringWithShadow("Export Clean", btnX + 4, btnY2 + 2, 0xFFFFFF);
7021: 
7022:         if (typePickerActive)
7023:         {
7024:             int leftX = left - panelWidth - 6;
7025:             if (leftX < 4)
7026:             {
7027:                 leftX = 4;
7028:             }
7029:             int leftY = top;
7030:             net.minecraft.client.gui.Gui.drawRect(leftX, leftY, leftX + panelWidth, leftY + 80, 0x66000000);
7031:             int ty = leftY + 6;
7032:             mc.fontRenderer.drawStringWithShadow("Type", leftX + 4, ty, 0xAAAAAA);
7033:             ty += 12;
7034:             mc.fontRenderer.drawStringWithShadow("[T] Text", leftX + 4, ty, 0xFFFFFF);
7035:             ty += 10;
7036:             mc.fontRenderer.drawStringWithShadow("[N] Number", leftX + 4, ty, 0xFFFFFF);
7037:             ty += 10;
7038:             mc.fontRenderer.drawStringWithShadow("[V] Variable", leftX + 4, ty, 0xFFFFFF);
7039:             ty += 10;
7040:             mc.fontRenderer.drawStringWithShadow("[A] Array", leftX + 4, ty, 0xFFFFFF);
7041:         }
7042:     }
7043: 
7044:     private boolean handleSidePanelClick(GuiContainer gui, int mouseX, int mouseY)
7045:     {
7046:         if (!editorModeActive)
7047:         {
7048:             return false;
7049:         }
7050:         if (codeMenuActive && isCodeMenuScreen(gui))
7051:         {
7052:             return false;
7053:         }
7054:         if (handleExportButtons(gui, mouseX, mouseY))
7055:         {
7056:             return true;
7057:         }
7058:         InputEntry entry = getEntryAt(gui, mouseX, mouseY);
7059:         if (entry != null)
7060:         {
7061:             if (inputActive)
7062:             {
7063:                 if (isShiftDown() && (entry.mode == INPUT_MODE_VARIABLE || entry.mode == INPUT_MODE_ARRAY))
7064:                 {
7065:                     appendVariablePlaceholder(entry.text);
7066:                     return true;
7067:                 }
7068:                 inputMode = entry.mode;
7069:                 inputContext = INPUT_CONTEXT_SLOT;
7070:                 inputSlotTemplate = templateForMode(entry.mode);
7071:                 setInputText(entry.text);
7072:                 submitInputText(false);
7073:                 return true;
7074:             }
7075:             if (quickApplyWindowId > 0 && quickApplySlotNumber >= 0
7076:                 && gui.inventorySlots.windowId == quickApplyWindowId)
7077:             {
7078:                 applyEntryToSlot(entry, gui);
7079:                 typePickerActive = false;
7080:                 return true;
7081:             }
7082:         }
7083: 
7084:         if (typePickerActive)
7085:         {
7086:             int picked = getTypeOptionAt(gui, mouseX, mouseY);
7087:             if (picked >= 0)
7088:             {
7089:                 Slot slot = findSlotByNumber(gui.inventorySlots, typePickerSlotNumber);
7090:                 if (slot != null)
7091:                 {
7092:                     ItemStack template = templateForMode(picked);
7093:                     String title = picked == INPUT_MODE_NUMBER ? "Number"
7094:                         : picked == INPUT_MODE_VARIABLE ? "Variable"
7095:                         : picked == INPUT_MODE_ARRAY ? "Array" : "Text";
7096:                     startSlotInput(gui, slot, template, picked, "", title);
7097:                 }
7098:                 typePickerActive = false;
7099:                 return true;
7100:             }
7101:         }
7102:         return false;
7103:     }
7104: 
7105:     private boolean handleExportButtons(GuiContainer gui, int mouseX, int mouseY)
7106:     {
7107:         if (gui == null)
7108:         {
7109:             return false;
7110:         }
7111:         int left = getGuiLeft(gui);
7112:         int top = getGuiTop(gui);
7113:         int xSize = getGuiXSize(gui);
7114:         int ySize = getGuiYSize(gui);
7115:         int panelWidth = 120;
7116:         int rightX = left + xSize + 6;
7117:         int rightY = top;
7118:         int btnWidth = panelWidth - 8;
7119:         int btnHeight = 12;
7120:         int btnX = rightX + 4;
7121:         int btnY2 = rightY + ySize - btnHeight - 4;
7122:         int btnY1 = btnY2 - btnHeight - 2;
7123:         if (mouseX >= btnX && mouseX <= btnX + btnWidth && mouseY >= btnY1 && mouseY <= btnY1 + btnHeight)
7124:         {
7125:             exportGuiToClipboard(gui, true, false);
7126:             return true;
7127:         }
7128:         if (mouseX >= btnX && mouseX <= btnX + btnWidth && mouseY >= btnY2 && mouseY <= btnY2 + btnHeight)
7129:         {
7130:             exportGuiToClipboard(gui, false, true);
7131:             return true;
7132:         }
7133:         return false;
7134:     }
7135: 
7136:     private boolean handleShiftEditClick(GuiContainer gui)
7137:     {
7138:         Slot hovered = getSlotUnderMouse(gui);
7139:         if (hovered == null)
7140:         {
7141:             return false;
7142:         }
7143:         if (!hovered.getHasStack())
7144:         {
7145:             typePickerActive = true;
7146:             typePickerWindowId = gui.inventorySlots.windowId;
7147:             typePickerSlotNumber = hovered.slotNumber;
7148:             quickApplyWindowId = gui.inventorySlots.windowId;
7149:             quickApplySlotNumber = hovered.slotNumber;
7150:             return true;
7151:         }
7152: 
7153:         ItemStack stack = hovered.getStack();
7154:         int mode = getModeForItem(stack);
7155:         if (mode < 0)
7156:         {
7157:             return false;
7158:         }
7159:         String preset;
7160:         if (mode == INPUT_MODE_NUMBER)
7161:         {
7162:             preset = extractNumber(stack.getDisplayName());
7163:         }
7164:         else if (mode == INPUT_MODE_VARIABLE || mode == INPUT_MODE_ARRAY)
7165:         {
7166:             preset = normalizePlainName(stack.getDisplayName());
7167:         }
7168:         else
7169:         {
7170:             preset = toAmpersandCodes(stack.getDisplayName());
7171:         }
7172:         startSlotInput(gui, hovered, stack.copy(), mode, preset, "Edit");
7173:         return true;
7174:     }
7175: 
7176:     private void applyEntryToSlot(InputEntry entry, GuiContainer gui)
7177:     {
7178:         Minecraft mc = Minecraft.getMinecraft();
7179:         if (mc == null || mc.player == null || mc.playerController == null)
7180:         {
7181:             return;
7182:         }
7183:         if (!mc.playerController.isInCreativeMode() || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
7184:         {
7185:             setActionBar(false, "&cCreative only.", 2000L);
7186:             return;
7187:         }
7188:         Slot slot = findSlotByNumber(gui.inventorySlots, quickApplySlotNumber);
7189:         if (slot == null)
7190:         {
7191:             return;
7192:         }
7193:         ItemStack template = templateForMode(entry.mode);
7194:         ItemStack stack = template.isEmpty() ? new ItemStack(Items.BOOK, 1) : template.copy();
7195:         stack.setCount(1);
7196:         String display = buildEntryDisplay(entry);
7197:         stack.setStackDisplayName(display);
7198:         if (entry.mode == INPUT_MODE_VARIABLE && savedVariableNames.contains(entry.text))
7199:         {
7200:             applySavedVariableTag(stack);
7201:         }
7202:         placeInContainerSlot(mc, gui.inventorySlots, slot.slotNumber, stack);
7203:         recordEntry(entry.mode, entry.text);
7204:     }
7205: 
7206:     private void placeInContainerSlot(Minecraft mc, Container container, int slotNumber, ItemStack stack)
7207:     {
7208:         Integer tempHotbar = findEmptyHotbarSlot(mc);
7209:         if (tempHotbar == null)
7210:         {
7211:             tempHotbar = mc.player.inventory.currentItem;
7212:         }
7213:         ItemStack original = mc.player.inventory.getStackInSlot(tempHotbar);
7214:         mc.player.inventory.setInventorySlotContents(tempHotbar, stack);
7215:         sendCreativeSlotUpdate(mc, tempHotbar, stack);
7216: 
7217:         Integer invSlotIndex = findContainerSlotForHotbar(container, tempHotbar);
7218:         if (invSlotIndex != null)
7219:         {
7220:             mc.playerController.windowClick(container.windowId, invSlotIndex, 0, ClickType.PICKUP, mc.player);
7221:             mc.playerController.windowClick(container.windowId, slotNumber, 0, ClickType.PICKUP, mc.player);
7222:             if (!mc.player.inventory.getItemStack().isEmpty())
7223:             {
7224:                 mc.playerController.windowClick(container.windowId, invSlotIndex, 0, ClickType.PICKUP, mc.player);
7225:             }
7226:         }
7227: 
7228:         mc.player.inventory.setInventorySlotContents(tempHotbar, original);
7229:         sendCreativeSlotUpdate(mc, tempHotbar, original);
7230:     }
7231: 
7232:     private int getModeForItem(ItemStack stack)
7233:     {
7234:         if (stack == null || stack.isEmpty())
7235:         {
7236:             return -1;
7237:         }
7238:         if (stack.getItem() == Items.SLIME_BALL)
7239:         {
7240:             return INPUT_MODE_NUMBER;
7241:         }
7242:         if (stack.getItem() == Items.MAGMA_CREAM)
7243:         {
7244:             return INPUT_MODE_VARIABLE;
7245:         }
7246:         if (stack.getItem() == Items.ITEM_FRAME)
7247:         {
7248:             return INPUT_MODE_ARRAY;
7249:         }
7250:         if (stack.getItem() == Items.BOOK)
7251:         {
7252:             return INPUT_MODE_TEXT;
7253:         }
7254:         if (stack.getItem() == Items.PAPER)
7255:         {
7256:             return INPUT_MODE_LOCATION;
7257:         }
7258:         return -1;
7259:     }
7260: 
7261:     private ItemStack templateForMode(int mode)
7262:     {
7263:         if (mode == INPUT_MODE_NUMBER)
7264:         {
7265:             ItemStack cached = getCachedTemplateForItem(Items.SLIME_BALL);
7266:             return cached.isEmpty() ? new ItemStack(Items.SLIME_BALL, 1) : cached;
7267:         }
7268:         if (mode == INPUT_MODE_VARIABLE)
7269:         {
7270:             ItemStack cached = getCachedTemplateForItem(Items.MAGMA_CREAM);
7271:             return cached.isEmpty() ? new ItemStack(Items.MAGMA_CREAM, 1) : cached;
7272:         }
7273:         if (mode == INPUT_MODE_ARRAY)
7274:         {
7275:             ItemStack cached = getCachedTemplateForItem(Items.ITEM_FRAME);
7276:             return cached.isEmpty() ? new ItemStack(Items.ITEM_FRAME, 1) : cached;
7277:         }
7278:         if (mode == INPUT_MODE_TEXT)
7279:         {
7280:             ItemStack cached = getCachedTemplateForItem(Items.BOOK);
7281:             return cached.isEmpty() ? new ItemStack(Items.BOOK, 1) : cached;
7282:         }
7283:         if (mode == INPUT_MODE_LOCATION)
7284:         {
7285:             ItemStack cached = getCachedTemplateForItem(Items.PAPER);
7286:             return cached.isEmpty() ? new ItemStack(Items.PAPER, 1) : cached;
7287:         }
7288:         return new ItemStack(Items.BOOK, 1);
7289:     }
7290: 
7291:     private ItemStack getCachedTemplateForItem(Item item)
7292:     {
7293:         if (item == null)
7294:         {
7295:             return ItemStack.EMPTY;
7296:         }
7297:         if (customMenuCache != null)
7298:         {
7299:             for (ItemStack stack : customMenuCache.items)
7300:             {
7301:                 if (!stack.isEmpty() && stack.getItem() == item)
7302:                 {
7303:                     return stack.copy();
7304:                 }
7305:             }
7306:         }
7307:         if (codeMenuInventory != null)
7308:         {
7309:             for (int i = 0; i < codeMenuInventory.getSizeInventory(); i++)
7310:             {
7311:                 ItemStack stack = codeMenuInventory.getStackInSlot(i);
7312:                 if (!stack.isEmpty() && stack.getItem() == item)
7313:                 {
7314:                     return stack.copy();
7315:                 }
7316:             }
7317:         }
7318:         return ItemStack.EMPTY;
7319:     }
7320: 
7321:     private String buildEntryDisplay(InputEntry entry)
7322:     {
7323:         if (entry.mode == INPUT_MODE_NUMBER)
7324:         {
7325:             return applyColorCodes("&c" + entry.text);
7326:         }
7327:         if (entry.mode == INPUT_MODE_LOCATION)
7328:         {
7329:             return applyColorCodes("&b" + entry.text);
7330:         }
7331:         if (entry.mode == INPUT_MODE_VARIABLE || entry.mode == INPUT_MODE_ARRAY)
7332:         {
7333:             return applyColorCodes("&r" + entry.text);
7334:         }
7335:         return normalizeTextName(entry.text);
7336:     }
7337: 
7338:     private String formatEntryLine(InputEntry entry)
7339:     {
7340:         char label = entry.mode == INPUT_MODE_NUMBER ? 'N'
7341:             : entry.mode == INPUT_MODE_VARIABLE ? 'V'
7342:             : entry.mode == INPUT_MODE_ARRAY ? 'A'
7343:             : entry.mode == INPUT_MODE_LOCATION ? 'L' : 'T';
7344:         String display = buildEntryDisplay(entry);
7345:         return "\u00a77[" + label + "]\u00a7r " + display;
7346:     }
7347: 
7348:     private InputEntry getEntryAt(GuiContainer gui, int mouseX, int mouseY)
7349:     {
7350:         int left = getGuiLeft(gui);
7351:         int top = getGuiTop(gui);
7352:         int xSize = getGuiXSize(gui);
7353:         int ySize = getGuiYSize(gui);
7354:         int panelWidth = 120;
7355:         int rightX = left + xSize + 6;
7356:         int rightY = top;
7357:         if (mouseX < rightX || mouseX > rightX + panelWidth || mouseY < rightY || mouseY > rightY + ySize)
7358:         {
7359:             return null;
7360:         }
7361:         int y = rightY + 6 + 12;
7362:         for (InputEntry entry : getRecentEntries())
7363:         {
7364:             if (mouseY >= y && mouseY <= y + 10)
7365:             {
7366:                 return entry;
7367:             }
7368:             y += 10;
7369:         }
7370:         y += 4 + 12;
7371:         for (InputEntry entry : getFrequentEntries())
7372:         {
7373:             if (mouseY >= y && mouseY <= y + 10)
7374:             {
7375:                 return entry;
7376:             }
7377:             y += 10;
7378:         }
7379:         return null;
7380:     }
7381: 
7382:     private int getTypeOptionAt(GuiContainer gui, int mouseX, int mouseY)
7383:     {
7384:         if (!typePickerActive)
7385:         {
7386:             return -1;
7387:         }
7388:         int left = getGuiLeft(gui);
7389:         int top = getGuiTop(gui);
7390:         int panelWidth = 120;
7391:         int leftX = left - panelWidth - 6;
7392:         if (leftX < 4)
7393:         {
7394:             leftX = 4;
7395:         }
7396:         int leftY = top;
7397:         if (mouseX < leftX || mouseX > leftX + panelWidth || mouseY < leftY || mouseY > leftY + 80)
7398:         {
7399:             return -1;
7400:         }
7401:         int y = leftY + 6 + 12;
7402:         if (mouseY >= y && mouseY <= y + 10)
7403:         {
7404:             return INPUT_MODE_TEXT;
7405:         }
7406:         y += 10;
7407:         if (mouseY >= y && mouseY <= y + 10)
7408:         {
7409:             return INPUT_MODE_NUMBER;
7410:         }
7411:         y += 10;
7412:         if (mouseY >= y && mouseY <= y + 10)
7413:         {
7414:             return INPUT_MODE_VARIABLE;
7415:         }
7416:         y += 10;
7417:         if (mouseY >= y && mouseY <= y + 10)
7418:         {
7419:             return INPUT_MODE_ARRAY;
7420:         }
7421:         return -1;
7422:     }
7423: 
7424:     private int getScaledMouseX(Minecraft mc, GuiScreen gui)
7425:     {
7426:         if (mc == null || gui == null)
7427:         {
7428:             return 0;
7429:         }
7430:         return Mouse.getEventX() * gui.width / mc.displayWidth;
7431:     }
7432: 
7433:     private int getScaledMouseY(Minecraft mc, GuiScreen gui)
7434:     {
7435:         if (mc == null || gui == null)
7436:         {
7437:             return 0;
7438:         }
7439:         return gui.height - Mouse.getEventY() * gui.height / mc.displayHeight - 1;
7440:     }
7441: 
7442:     private int getGuiLeft(GuiContainer gui)
7443:     {
7444:         return getGuiIntField(gui, "guiLeft", "field_147003_i", guiLeftField);
7445:     }
7446: 
7447:     private int getGuiTop(GuiContainer gui)
7448:     {
7449:         return getGuiIntField(gui, "guiTop", "field_147009_r", guiTopField);
7450:     }
7451: 
7452:     private int getGuiXSize(GuiContainer gui)
7453:     {
7454:         return getGuiIntField(gui, "xSize", "field_146999_f", xSizeField);
7455:     }
7456: 
7457:     private int getGuiYSize(GuiContainer gui)
7458:     {
7459:         return getGuiIntField(gui, "ySize", "field_147000_g", ySizeField);
7460:     }
7461: 
7462:     private int getGuiIntField(GuiContainer gui, String name, String obf, java.lang.reflect.Field cache)
7463:     {
7464:         try
7465:         {
7466:             if (cache == null)
7467:             {
7468:                 try
7469:                 {
7470:                     cache = GuiContainer.class.getDeclaredField(name);
7471:                 }
7472:                 catch (NoSuchFieldException e)
7473:                 {
7474:                     cache = GuiContainer.class.getDeclaredField(obf);
7475:                 }
7476:                 cache.setAccessible(true);
7477:                 if ("guiLeft".equals(name))
7478:                 {
7479:                     guiLeftField = cache;
7480:                 }
7481:                 else if ("guiTop".equals(name))
7482:                 {
7483:                     guiTopField = cache;
7484:                 }
7485:                 else if ("xSize".equals(name))
7486:                 {
7487:                     xSizeField = cache;
7488:                 }
7489:                 else if ("ySize".equals(name))
7490:                 {
7491:                     ySizeField = cache;
7492:                 }
7493:             }
7494:             Object value = cache.get(gui);
7495:             return value instanceof Integer ? (Integer) value : 0;
7496:         }
7497:         catch (Exception e)
7498:         {
7499:             return 0;
7500:         }
7501:     }
7502: 
7503:     private void renderChestPreview(Minecraft mc, ChestCache cache, BlockPos pos)
7504:     {
7505:         if (mc == null || mc.fontRenderer == null || cache == null || cache.items == null)
7506:         {
7507:             return;
7508:         }
7509:         boolean noDepth = chestHoloUseGuiRender;
7510:         if (isPlayerSouthOf(pos))
7511:         {
7512:             renderChestPreviewFace(mc, cache, pos, 0.0F, -0.06F, chestHoloScale, chestHoloTextWidth, noDepth);
7513:         }
7514:         else
7515:         {
7516:             renderChestPreviewFace(mc, cache, pos, 180.0F, 0.06F, chestHoloScale, chestHoloTextWidth, noDepth);
7517:         }
7518:     }
7519: 
7520:     private void renderChestPreviewFace(Minecraft mc, ChestCache cache, BlockPos pos, float yaw, float zOffset,
7521:         float scale, int textWidth, boolean disableDepth)
7522:     {
7523:         int size = cache.items.size();
7524:         int rows = Math.max(1, (int) Math.ceil(size / 9.0));
7525:         rows = Math.min(rows, 6);
7526:         int cols = 9;
7527: 
7528:         int pad = 4;
7529:         int slot = 18;
7530:         int guiWidth = cols * slot + pad * 2;
7531:         int guiHeight = rows * slot + pad * 2 + 12;
7532: 
7533:         double x = pos.getX() + 0.5;
7534:         double y = getChestYOffset(pos);
7535:         double z = pos.getZ() + 0.5;
7536:         double forward = 0.51;
7537:         if (yaw == 0.0F)
7538:         {
7539:             z -= forward;
7540:         }
7541:         else
7542:         {
7543:             z += forward;
7544:             z -= 1.0;
7545:         }
7546:         z += 0.5;
7547:         z += 0.5;
7548: 
7549:         GlStateManager.pushMatrix();
7550:         GlStateManager.translate(x, y, z);
7551:         GlStateManager.rotate(yaw, 0.0F, 1.0F, 0.0F);
7552:         GlStateManager.translate(0.0F, 0.0F, zOffset);
7553:         float axisScale = Math.abs(scale);
7554:         GlStateManager.scale(scale, -axisScale, axisScale);
7555:         GlStateManager.disableLighting();
7556:         if (disableDepth)
7557:         {
7558:             GlStateManager.disableDepth();
7559:             GlStateManager.depthMask(false);
7560:         }
7561:         else
7562:         {
7563:             GlStateManager.enableDepth();
7564:             GlStateManager.depthMask(true);
7565:         }
7566:         GlStateManager.enableBlend();
7567:         GlStateManager.disableCull();
7568:         GlStateManager.enablePolygonOffset();
7569:         GlStateManager.doPolygonOffset(-1.0F, -10.0F);
7570:         GlStateManager.color(1f, 1f, 1f, 1f);
7571: 
7572:         int left = -guiWidth / 2;
7573:         int top = -guiHeight / 2;
7574:         Gui.drawRect(left, top, left + guiWidth, top + guiHeight, 0xCC000000);
7575:         Gui.drawRect(left, top, left + guiWidth, top + 12, 0xFF111111);
7576:         String label = (cache.label == null || cache.label.trim().isEmpty()) ? CHEST_HOLO_LABEL : cache.label;
7577:         mc.fontRenderer.drawStringWithShadow(label, left + 6, top + 2, chestHoloTextColor);
7578: 
7579:         int textMaxWidth = cols * slot;
7580:         renderTextColumn(mc, cache.items, left + pad, top + 12, cols, slot, textMaxWidth, guiWidth, guiHeight);
7581:         GlStateManager.disablePolygonOffset();
7582:         GlStateManager.enableCull();
7583:         GlStateManager.enableLighting();
7584:         GlStateManager.disableBlend();
7585:         if (disableDepth)
7586:         {
7587:             GlStateManager.enableDepth();
7588:             GlStateManager.depthMask(true);
7589:         }
7590:         GlStateManager.popMatrix();
7591:     }
7592: 
7593:     private void renderChestPreviewWithFbo(Minecraft mc, ChestCache cache, BlockPos pos)
7594:     {
7595:         if (mc == null || cache == null || pos == null)
7596:         {
7597:             return;
7598:         }
7599:         if (chestHoloUseGuiRender)
7600:         {
7601:             renderChestPreview(mc, cache, pos);
7602:             if (debugUi)
7603:             {
7604:                 lastHoloInfo = "holo key=" + cache.dim + ":" + pos.toString() + " mode=gui";
7605:             }
7606:             return;
7607:         }
7608:         String key = cache.dim + ":" + pos.toString();
7609:         if (chestHoloUseTestPipeline)
7610:         {
7611:             TestChestHolo holo = chestTestHolos.get(key);
7612:             if (holo == null || holo.cache != cache)
7613:             {
7614:                 holo = new TestChestHolo(pos, cache, true, lastTestScale, lastTestTextWidth, lastTestTexSize);
7615:                 chestTestHolos.put(key, holo);
7616:             }
7617:             renderChestPreviewFbo(mc, holo);
7618:             if (debugUi)
7619:             {
7620:                 lastHoloInfo = "holo key=" + key + " tex=" + lastTestTexSize + " w=" + lastTestTextWidth
7621:                     + " s=" + lastTestScale + " re=forced mode=test font="
7622:                     + (chestHoloSmoothFont ? "linear" : "nearest");
7623:             }
7624:             return;
7625:         }
7626:         ChestPreviewFbo preview = chestPreviewFbos.get(key);
7627:         if (preview == null)
7628:         {
7629:             preview = new ChestPreviewFbo();
7630:             chestPreviewFbos.put(key, preview);
7631:         }
7632:         String hash = buildItemHash(cache.items);
7633:         int size = chestHoloTexSize;
7634:         int textWidth = chestHoloTextWidth;
7635:         boolean rerender = false;
7636:         if (preview.fbo == null || preview.fbo.framebufferTextureWidth != size)
7637:         {
7638:             if (preview.fbo != null)
7639:             {
7640:                 preview.fbo.deleteFramebuffer();
7641:             }
7642:             preview.fbo = new Framebuffer(size, size, true);
7643:             preview.lastHash = null;
7644:             preview.lastTexSize = size;
7645:             rerender = true;
7646:         }
7647:         if (chestHoloForceRerender)
7648:         {
7649:             renderChestPreviewToFramebuffer(mc, cache, preview.fbo, size, size, textWidth);
7650:             preview.lastHash = hash;
7651:             preview.lastTextWidth = textWidth;
7652:             preview.lastTexSize = size;
7653:             rerender = true;
7654:         }
7655:         else if (preview.lastHash == null || !preview.lastHash.equals(hash)
7656:             || preview.lastTextWidth != textWidth || preview.lastTexSize != size)
7657:         {
7658:             renderChestPreviewToFramebuffer(mc, cache, preview.fbo, size, size, textWidth);
7659:             preview.lastHash = hash;
7660:             preview.lastTextWidth = textWidth;
7661:             preview.lastTexSize = size;
7662:             rerender = true;
7663:         }
7664:         renderFramebufferQuad(mc, pos, preview.fbo, size, size, chestHoloScale);
7665:         if (debugUi)
7666:         {
7667:             lastHoloInfo = "holo key=" + key + " tex=" + size + " w=" + textWidth + " s=" + chestHoloScale
7668:                 + " re=" + rerender + " force=" + chestHoloForceRerender + " mode=cache font="
7669:                 + (chestHoloSmoothFont ? "linear" : "nearest");
7670:         }
7671:     }
7672: 
7673:     private static String toAmpersandCodes(String text)
7674:     {
7675:         if (text == null)
7676:         {
7677:             return "";
7678:         }
7679:         return text.replace("\u00a7", "&");
7680:     }
7681: 
7682:     private static String extractDigits(String text)
7683:     {
7684:         if (text == null)
7685:         {
7686:             return "";
7687:         }
7688:         String clean = TextFormatting.getTextWithoutFormattingCodes(text);
7689:         StringBuilder sb = new StringBuilder();
7690:         for (int i = 0; i < clean.length(); i++)
7691:         {
7692:             char c = clean.charAt(i);
7693:             if (c >= '0' && c <= '9')
7694:             {
7695:                 sb.append(c);
7696:             }
7697:         }
7698:         return sb.toString();
7699:     }
7700: 
7701:     private static String extractNumber(String text)
7702:     {
7703:         if (text == null)
7704:         {
7705:             return "";
7706:         }
7707:         String clean = TextFormatting.getTextWithoutFormattingCodes(text);
7708:         if (clean == null)
7709:         {
7710:             return "";
7711:         }
7712:         StringBuilder sb = new StringBuilder();
7713:         boolean dot = false;
7714:         boolean minus = false;
7715:         for (int i = 0; i < clean.length(); i++)
7716:         {
7717:             char c = clean.charAt(i);
7718:             if (c >= '0' && c <= '9')
7719:             {
7720:                 sb.append(c);
7721:             }
7722:             else if (c == '-' && !minus && sb.length() == 0)
7723:             {
7724:                 sb.append(c);
7725:                 minus = true;
7726:             }
7727:             else if (c == '.' && !dot)
7728:             {
7729:                 sb.append(c);
7730:                 dot = true;
7731:             }
7732:         }
7733:         return sb.toString();
7734:     }
7735: 
7736:     private void submitInputText(boolean giveExtra)
7737:     {
7738:         Minecraft mc = Minecraft.getMinecraft();
7739:         if (mc == null || mc.player == null || mc.playerController == null)
7740:         {
7741:             setInputActive(false);
7742:             return;
7743:         }
7744:         if (!mc.playerController.isInCreativeMode() || mc.playerController.getCurrentGameType() != GameType.CREATIVE)
7745:         {
7746:             setActionBar(false, "&cCreative only.", 2000L);
7747:             setInputActive(false);
7748:             return;
7749:         }
7750:         String raw = getInputText().trim();
7751:         if (raw.isEmpty())
7752:         {
7753:             setInputActive(false);
7754:             return;
7755:         }
7756:         String finalRaw = raw;
7757:         String display;
7758:         if (inputMode == INPUT_MODE_NUMBER)
7759:         {
7760:             String number = extractNumber(raw);
7761:             if (number.isEmpty())
7762:             {
7763:                 setInputActive(false);
7764:                 return;
7765:             }
7766:             finalRaw = number;
7767:             display = applyColorCodes("&c" + number);
7768:         }
7769:         else if (inputMode == INPUT_MODE_LOCATION)
7770:         {
7771:             finalRaw = raw.trim();
7772:             if (finalRaw.isEmpty())
7773:             {
7774:                 setInputActive(false);
7775:                 return;
7776:             }
7777:             display = finalRaw;
7778:         }
7779:         else if (inputMode == INPUT_MODE_VARIABLE || inputMode == INPUT_MODE_ARRAY)
7780:         {
7781:             finalRaw = normalizePlainName(raw);
7782:             if (finalRaw.isEmpty())
7783:             {
7784:                 setInputActive(false);
7785:                 return;
7786:             }
7787:             display = applyColorCodes("&r" + finalRaw);
7788:         }
7789:         else
7790:         {
7791:             display = normalizeTextName(finalRaw);
7792:         }
7793: 
7794:         if (inputContext == INPUT_CONTEXT_GIVE)
7795:         {
7796:             ItemStack give = inputGiveTemplate.isEmpty() ? new ItemStack(Items.BOOK, 1) : inputGiveTemplate.copy();
7797:             give.setCount(1);
7798:             give.setStackDisplayName(display);
7799:             if (inputMode == INPUT_MODE_VARIABLE && (inputSaveVariable || savedVariableNames.contains(finalRaw)))
7800:             {
7801:                 applySavedVariableTag(give);
7802:                 if (inputSaveVariable)
7803:                 {
7804:                     savedVariableNames.add(finalRaw);
7805:                 }
7806:             }
7807:             else if (inputMode == INPUT_MODE_VARIABLE)
7808:             {
7809:                 removeSavedVariableTag(give);
7810:             }
7811:             giveItemToHotbar(mc, give);
7812:             recordEntry(inputMode, finalRaw);
7813:             if (giveExtra)
7814:             {
7815:                 ItemStack extra = give.copy();
7816:                 extra.setCount(64);
7817:                 giveExtraIfMissing(mc, extra, display);
7818:             }
7819:             setInputActive(false);
7820:             return;
7821:         }
7822: 
7823:         if (mc.player.openContainer == null)
7824:         {
7825:             if (debugUi)
7826:             {
7827:                 setActionBar(false, "&cInput: no container", 1500L);
7828:             }
7829:             setInputActive(false);
7830:             return;
7831:         }
7832:         if (mc.player.openContainer.windowId != inputTargetWindowId)
7833:         {
7834:             if (shulkerEditActive)
7835:             {
7836:                 inputTargetWindowId = mc.player.openContainer.windowId;
7837:             }
7838:             else
7839:             {
7840:                 if (debugUi)
7841:                 {
7842:                     setActionBar(false, "&cInput: windowId mismatch", 1500L);
7843:                 }
7844:                 setInputActive(false);
7845:                 return;
7846:             }
7847:         }
7848: 
7849:         Slot target = findSlotByNumber(mc.player.openContainer, inputTargetSlotNumber);
7850:         if (target == null)
7851:         {
7852:             if (debugUi)
7853:             {
7854:                 setActionBar(false, "&cInput: slot not found", 1500L);
7855:             }
7856:             setInputActive(false);
7857:             return;
7858:         }
7859: 
7860:         ItemStack placed = inputSlotTemplate.isEmpty() ? new ItemStack(Items.BOOK, 1) : inputSlotTemplate.copy();
7861:         placed.setCount(1);
7862:         placed.setStackDisplayName(display);
7863:         if (inputMode == INPUT_MODE_VARIABLE && (inputSaveVariable || savedVariableNames.contains(finalRaw)))
7864:         {
7865:             applySavedVariableTag(placed);
7866:             if (inputSaveVariable)
7867:             {
7868:                 savedVariableNames.add(finalRaw);
7869:             }
7870:         }
7871:         else if (inputMode == INPUT_MODE_VARIABLE)
7872:         {
7873:             removeSavedVariableTag(placed);
7874:         }
7875: 
7876:         Integer tempHotbar = findEmptyHotbarSlot(mc);
7877:         if (tempHotbar == null)
7878:         {
7879:             tempHotbar = mc.player.inventory.currentItem;
7880:         }
7881:         ItemStack original = mc.player.inventory.getStackInSlot(tempHotbar);
7882: 
7883:         mc.player.inventory.setInventorySlotContents(tempHotbar, placed);
7884:         sendCreativeSlotUpdate(mc, tempHotbar, placed);
7885: 
7886:         Integer invSlotIndex = findContainerSlotForHotbar(mc.player.openContainer, tempHotbar);
7887:         if (invSlotIndex != null)
7888:         {
7889:             mc.playerController.windowClick(mc.player.openContainer.windowId, invSlotIndex, 0, ClickType.PICKUP,
7890:                 mc.player);
7891:             mc.playerController.windowClick(mc.player.openContainer.windowId, target.slotNumber, 0, ClickType.PICKUP,
7892:                 mc.player);
7893:             if (!mc.player.inventory.getItemStack().isEmpty())
7894:             {
7895:                 mc.playerController.windowClick(mc.player.openContainer.windowId, invSlotIndex, 0, ClickType.PICKUP,
7896:                     mc.player);
7897:             }
7898:         }
7899: 
7900:         mc.player.inventory.setInventorySlotContents(tempHotbar, original);
7901:         sendCreativeSlotUpdate(mc, tempHotbar, original);
7902: 
7903:         recordEntry(inputMode, finalRaw);
7904:         if (giveExtra)
7905:         {
7906:             ItemStack extra = placed.copy();
7907:             extra.setCount(64);
7908:             giveExtraIfMissing(mc, extra, display);
7909:         }
7910: 
7911:         if (shulkerEditPos != null)
7912:         {
7913:             putShulkerHolo(shulkerEditDim, shulkerEditPos, display, shulkerEditColor);
7914:             shulkerEditActive = false;
7915:             shulkerEditWindowId = -1;
7916:             shulkerEditSlotNumber = -1;
7917:             shulkerEditPos = null;
7918:         }
7919: 
7920:         setInputActive(false);
7921:     }
7922: 
7923:     private Slot findSlotByNumber(Container container, int slotNumber)
7924:     {
7925:         if (container == null)
7926:         {
7927:             return null;
7928:         }
7929:         for (Slot slot : container.inventorySlots)
7930:         {
7931:             if (slot.slotNumber == slotNumber)
7932:             {
7933:                 return slot;
7934:             }
7935:         }
7936:         return null;
7937:     }
7938: 
7939:     private Integer findContainerSlotForHotbar(Container container, int hotbarIndex)
7940:     {
7941:         if (container == null)
7942:         {
7943:             return null;
7944:         }
7945:         for (Slot slot : container.inventorySlots)
7946:         {
7947:             if (slot.inventory == Minecraft.getMinecraft().player.inventory && slot.getSlotIndex() == hotbarIndex)
7948:             {
7949:                 return slot.slotNumber;
7950:             }
7951:         }
7952:         return null;
7953:     }
7954: 
7955:     private Integer findEmptyHotbarSlot(Minecraft mc)
7956:     {
7957:         for (int i = 0; i < 9; i++)
7958:         {
7959:             ItemStack stack = mc.player.inventory.getStackInSlot(i);
7960:             if (stack == null || stack.isEmpty())
7961:             {
7962:                 return i;
7963:             }
7964:         }
7965:         return null;
7966:     }
7967: 
7968:     private Integer findEmptyInventorySlot(Minecraft mc)
7969:     {
7970:         int size = mc.player.inventory.getSizeInventory();
7971:         for (int i = 9; i < size; i++)
7972:         {
7973:             ItemStack stack = mc.player.inventory.getStackInSlot(i);
7974:             if (stack == null || stack.isEmpty())
7975:             {
7976:                 return i;
7977:             }
7978:         }
7979:         return null;
7980:     }
7981: 
7982:     private void giveItemToHotbar(Minecraft mc, ItemStack stack)
7983:     {
7984:         Integer slot = findEmptyHotbarSlot(mc);
7985:         if (slot == null)
7986:         {
7987:             slot = findEmptyInventorySlot(mc);
7988:         }
7989:         if (slot == null)
7990:         {
7991:             setActionBar(false, "&eNo empty inventory slot.", 2000L);
7992:             return;
7993:         }
7994:         mc.player.inventory.setInventorySlotContents(slot, stack);
7995:         sendCreativeSlotUpdate(mc, slot, stack);
7996:     }
7997: 
7998:     private void giveExtraIfMissing(Minecraft mc, ItemStack stack, String display)
7999:     {
8000:         if (!inventoryHasDisplayName(mc, display))
8001:         {
8002:             Integer extraSlot = findEmptyHotbarSlot(mc);
8003:             if (extraSlot == null)
8004:             {
8005:                 extraSlot = findEmptyInventorySlot(mc);
8006:             }
8007:             if (extraSlot == null)
8008:             {
8009:                 setActionBar(false, "&eNo empty inventory slot for x64.", 2000L);
8010:                 return;
8011:             }
8012:             mc.player.inventory.setInventorySlotContents(extraSlot, stack);
8013:             sendCreativeSlotUpdate(mc, extraSlot, stack);
8014:         }
8015:     }
8016: 
8017:     private boolean inventoryHasDisplayName(Minecraft mc, String display)
8018:     {
8019:         for (int i = 0; i < mc.player.inventory.getSizeInventory(); i++)
8020:         {
8021:             ItemStack stack = mc.player.inventory.getStackInSlot(i);
8022:             if (!stack.isEmpty() && display.equals(stack.getDisplayName()))
8023:             {
8024:                 return true;
8025:             }
8026:         }
8027:         return false;
8028:     }
8029: 
8030:     private String normalizeTextName(String raw)
8031:     {
8032:         String text = raw.trim();
8033:         if (!text.startsWith("&r") && !text.startsWith("\u00a7r"))
8034:         {
8035:             text = "&r" + text;
8036:         }
8037:         return applyColorCodes(text);
8038:     }
8039: 
8040:     private CommandResult executeCommand(String cmdFinal, String asPlayer)
8041:     {
8042:         if (cmdFinal == null || cmdFinal.trim().isEmpty())
8043:         {
8044:             return new CommandResult(false, "none");
8045:         }
8046:         if (mcServer != null)
8047:         {
8048:             mcServer.addScheduledTask(() -> {
8049:                 ICommandSender sender = mcServer;
8050:                 if (asPlayer != null && mcServer.getPlayerList() != null)
8051:                 {
8052:                     EntityPlayerMP player = mcServer.getPlayerList().getPlayerByUsername(asPlayer);
8053:                     if (player != null)
8054:                     {
8055:                         sender = player;
8056:                     }
8057:                 }
8058:                 mcServer.getCommandManager().executeCommand(sender, cmdFinal);
8059:             });
8060:             return new CommandResult(true, "server");
8061:         }
8062:         Minecraft mc = Minecraft.getMinecraft();
8063:         if (mc != null && mc.player != null)
8064:         {
8065:             String clientCmd = "/" + cmdFinal;
8066:             mc.addScheduledTask(() -> mc.player.sendChatMessage(clientCmd));
8067:             lastApiChatSentMs = System.currentTimeMillis();
8068:             return new CommandResult(true, "client");
8069:         }
8070:         return new CommandResult(false, "none");
8071:     }
8072: 
8073:     private boolean sendChatMessage(String text)
8074:     {
8075:         Minecraft mc = Minecraft.getMinecraft();
8076:         if (mc != null && mc.player != null)
8077:         {
8078:             mc.addScheduledTask(() -> mc.player.sendChatMessage(text));
8079:             lastApiChatSentMs = System.currentTimeMillis();
8080:             return true;
8081:         }
8082:         return false;
8083:     }
8084: 
8085:     private boolean broadcastServerMessage(String text)
8086:     {
8087:         if (mcServer != null && mcServer.getPlayerList() != null)
8088:         {
8089:             mcServer.getPlayerList().sendMessage(new TextComponentString(text));
8090:             return true;
8091:         }
8092:         return false;
8093:     }
8094: 
8095:     @SubscribeEvent
8096:     public void onRenderOverlay(RenderGameOverlayEvent.Text event)
8097:     {
8098:         Minecraft mc = Minecraft.getMinecraft();
8099:         if (mc == null || mc.fontRenderer == null)
8100:         {
8101:             return;
8102:         }
8103:         if (debugUi)
8104:         {
8105:             String dbg = "dev=" + editorModeActive + " creative=" + (mc.playerController != null
8106:                 && mc.playerController.isInCreativeMode())
8107:                 + " hotbar2=" + enableSecondHotbar
8108:                 + " input=" + inputActive
8109:                 + " codeMenu=" + codeMenuActive
8110:                 + " cache=" + (customMenuCache != null);
8111:             mc.fontRenderer.drawStringWithShadow(dbg, 4, 4, 0xFFFFFF);
8112:             String dbg2 = "cacheRoot=" + (cachePathRoot == null ? "-" : cachePathRoot)
8113:                 + " pending=" + (pendingCacheKey == null ? "-" : pendingCacheKey);
8114:             mc.fontRenderer.drawStringWithShadow(dbg2, 4, 14, 0xFFFFFF);
8115:             long sinceDev = System.currentTimeMillis() - lastDevCommandMs;
8116:             mc.fontRenderer.drawStringWithShadow("devMs=" + sinceDev, 4, 24, 0xFFFFFF);
8117:             String dbg3 = "pendingDev=" + pendingDev + " cacheSize=" + chestCaches.size();
8118:             mc.fontRenderer.drawStringWithShadow(dbg3, 4, 34, 0xFFFFFF);
8119:             String dbg4 = "awaitCache=" + awaitingCacheSnapshot + " ticks=" + cacheOpenTicks;
8120:             mc.fontRenderer.drawStringWithShadow(dbg4, 4, 44, 0xFFFFFF);
8121:             String dbg5 = "lastClick=" + (lastClickedPos == null ? "-" : lastClickedPos.toString());
8122:             mc.fontRenderer.drawStringWithShadow(dbg5, 4, 54, 0xFFFFFF);
8123:             String dbg6 = "pendingChest=" + pendingChestSnapshot + " chest=" + lastClickedChest;
8124:             mc.fontRenderer.drawStringWithShadow(dbg6, 4, 64, 0xFFFFFF);
8125:             String screenName = mc.currentScreen == null ? "-" : mc.currentScreen.getClass().getSimpleName();
8126:             String contName = (mc.player == null || mc.player.openContainer == null) ? "-" :
8127:                 mc.player.openContainer.getClass().getSimpleName();
8128:             mc.fontRenderer.drawStringWithShadow("screen=" + screenName, 4, 74, 0xFFFFFF);
8129:             mc.fontRenderer.drawStringWithShadow("container=" + contName, 4, 84, 0xFFFFFF);
8130:             mc.fontRenderer.drawStringWithShadow("snap=" + lastSnapshotInfo, 4, 94, 0xFFFFFF);
8131:             mc.fontRenderer.drawStringWithShadow("devUntil=" + pendingDevUntilMs, 4, 104, 0xFFFFFF);
8132:             mc.fontRenderer.drawStringWithShadow("sign=" + lastClickedIsSign, 4, 114, 0xFFFFFF);
8133:             mc.fontRenderer.drawStringWithShadow("holo=" + lastHoloInfo, 4, 124, 0xFFFFFF);
8134:             if (editorModeActive)
8135:             {
8136:                 String sbLine = getScoreboardLine(12);
8137:                 if (sbLine != null && !sbLine.isEmpty())
8138:                 {
8139:                     mc.fontRenderer.drawStringWithShadow("sb12=" + sbLine, 4, 134, 0xFFFFFF);
8140:                 }
8141:             }
8142:         }
8143:         long now = System.currentTimeMillis();
8144:         String text1 = now <= actionBarExpireMs ? actionBarText : "";
8145:         String text2 = now <= actionBar2ExpireMs ? actionBar2Text : "";
8146:         if (text1.isEmpty() && text2.isEmpty())
8147:         {
8148:             return;
8149:         }
8150: 
8151:         ScaledResolution res = event.getResolution();
8152:         int centerX = res.getScaledWidth() / 2;
8153:         int baseY = res.getScaledHeight() - 59;
8154:         int lineHeight = mc.fontRenderer.FONT_HEIGHT + 2;
8155: 
8156:         if (!text1.isEmpty())
8157:         {
8158:             int w1 = mc.fontRenderer.getStringWidth(text1);
8159:             mc.fontRenderer.drawStringWithShadow(text1, centerX - (w1 / 2), baseY, 0xFFFFFF);
8160:         }
8161:         if (!text2.isEmpty())
8162:         {
8163:             int w2 = mc.fontRenderer.getStringWidth(text2);
8164:             mc.fontRenderer.drawStringWithShadow(text2, centerX - (w2 / 2), baseY + lineHeight, 0xFFFFFF);
8165:         }
8166:     }
8167: 
8168:     @SubscribeEvent
8169:     public void onRenderWorld(RenderWorldLastEvent event)
8170:     {
8171:         Minecraft mc = Minecraft.getMinecraft();
8172:         if (mc == null || mc.player == null || mc.world == null)
8173:         {
8174:             return;
8175:         }
8176:         double px = mc.player.lastTickPosX + (mc.player.posX - mc.player.lastTickPosX) * event.getPartialTicks();
8177:         double py = mc.player.lastTickPosY + (mc.player.posY - mc.player.lastTickPosY) * event.getPartialTicks();
8178:         double pz = mc.player.lastTickPosZ + (mc.player.posZ - mc.player.lastTickPosZ) * event.getPartialTicks();
8179: 
8180:         GlStateManager.pushMatrix();
8181:         GlStateManager.translate(-px, -py, -pz);
8182:         RenderHelper.disableStandardItemLighting();
8183:         if (editorModeActive)
8184:         {
8185:             for (ChestCache cache : chestCaches.values())
8186:             {
8187:                 if (cache.dim != mc.world.provider.getDimension())
8188:                 {
8189:                     continue;
8190:                 }
8191:                 BlockPos pos = cache.pos;
8192:                 if (pos == null)
8193:                 {
8194:                     continue;
8195:                 }
8196:                 if (mc.player.getDistanceSq(pos) > CHEST_PREVIEW_RANGE * CHEST_PREVIEW_RANGE)
8197:                 {
8198:                     continue;
8199:                 }
8200:                 renderChestPreviewWithFbo(mc, cache, pos);
8201:             }
8202:             if (testHoloActive && testHoloPos != null)
8203:             {
8204:                 renderTestHolo(mc, testHoloPos);
8205:             }
8206:             if (!testChestHolos.isEmpty())
8207:             {
8208:                 for (TestChestHolo holo : testChestHolos)
8209:                 {
8210:                     renderChestHolo(mc, holo);
8211:                 }
8212:             }
8213:         }
8214:         if (!shulkerHolos.isEmpty())
8215:         {
8216:             int dim = mc.world == null ? 0 : mc.world.provider.getDimension();
8217:             for (ShulkerHolo holo : shulkerHolos.values())
8218:             {
8219:                 if (holo != null && holo.dim == dim)
8220:                 {
8221:                     renderShulkerHolo(mc, holo);
8222:                 }
8223:             }
8224:         }
8225:         renderSignSearchMarkers(mc);
8226:         GlStateManager.popMatrix();
8227:     }
8228: 
8229:     private void renderTestHolo(Minecraft mc, BlockPos pos)
8230:     {
8231:         if (mc == null || mc.getRenderItem() == null || mc.fontRenderer == null)
8232:         {
8233:             return;
8234:         }
8235:         ItemStack stack = new ItemStack(Blocks.DIRT, 1);
8236:         double x = pos.getX() + 0.5;
8237:         double y = pos.getY() + 0.8;
8238:         double z = pos.getZ() + 0.5;
8239: 
8240:         GlStateManager.pushMatrix();
8241:         GlStateManager.translate(x, y, z);
8242:         GlStateManager.rotate(180.0F - mc.getRenderManager().playerViewY, 0.0F, 1.0F, 0.0F);
8243:         GlStateManager.rotate(-mc.getRenderManager().playerViewX, 1.0F, 0.0F, 0.0F);
8244:         GlStateManager.scale(0.5F, 0.5F, 0.5F);
8245:         RenderHelper.enableStandardItemLighting();
8246:         mc.getRenderItem().renderItem(stack, ItemCameraTransforms.TransformType.FIXED);
8247:         RenderHelper.disableStandardItemLighting();
8248:         GlStateManager.popMatrix();
8249: 
8250:         GlStateManager.pushMatrix();
8251:         GlStateManager.translate(x, y + 0.6, z);
8252:         GlStateManager.rotate(180.0F - mc.getRenderManager().playerViewY, 0.0F, 1.0F, 0.0F);
8253:         GlStateManager.rotate(-mc.getRenderManager().playerViewX, 1.0F, 0.0F, 0.0F);
8254:         GlStateManager.scale(-0.025F, -0.025F, 0.025F);
8255:         GlStateManager.disableLighting();
8256:         GlStateManager.disableDepth();
8257:         GlStateManager.enableBlend();
8258:         mc.fontRenderer.drawStringWithShadow(HOLO_LABEL, -mc.fontRenderer.getStringWidth(HOLO_LABEL) / 2, 0, 0xFFFFFF);
8259:         GlStateManager.enableDepth();
8260:         GlStateManager.popMatrix();
8261:     }
8262: 
8263:     private void putShulkerHolo(int dim, BlockPos pos, String text, int color)
8264:     {
8265:         if (pos == null)
8266:         {
8267:             return;
8268:         }
8269:         String key = dim + ":" + pos.toString();
8270:         String safe = text == null ? "" : text;
8271:         shulkerHolos.put(key, new ShulkerHolo(dim, pos, safe, color));
8272:         shulkerHoloDirty = true;
8273:         setActionBar(true, "&aShulker holo set", 1500L);
8274:     }
8275: 
8276:     private void renderShulkerHolo(Minecraft mc, ShulkerHolo holo)
8277:     {
8278:         if (mc == null || mc.fontRenderer == null || holo == null || holo.pos == null)
8279:         {
8280:             return;
8281:         }
8282:         double x = holo.pos.getX() + 0.5;
8283:         double y = holo.pos.getY() + shulkerHoloYOffset;
8284:         double z = holo.pos.getZ() + 0.5 + shulkerHoloZOffset;
8285:         GlStateManager.pushMatrix();
8286:         GlStateManager.translate(x, y, z);
8287:         if (shulkerHoloBillboard)
8288:         {
8289:             GlStateManager.rotate(180.0F - mc.getRenderManager().playerViewY, 0.0F, 1.0F, 0.0F);
8290:             GlStateManager.rotate(-mc.getRenderManager().playerViewX, 1.0F, 0.0F, 0.0F);
8291:         }
8292:         else
8293:         {
8294:             GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
8295:         }
8296:         GlStateManager.scale(shulkerHoloScale, -shulkerHoloScale, shulkerHoloScale);
8297:         GlStateManager.disableLighting();
8298:         if (!shulkerHoloCull)
8299:         {
8300:             GlStateManager.disableCull();
8301:         }
8302:         if (!shulkerHoloDepth)
8303:         {
8304:             GlStateManager.disableDepth();
8305:         }
8306:         GlStateManager.enableBlend();
8307:         GlStateManager.color(1f, 1f, 1f, 1f);
8308:         String text = holo.text == null ? "" : holo.text;
8309:         int width = mc.fontRenderer.getStringWidth(text);
8310:         mc.fontRenderer.drawStringWithShadow(text, -width / 2, 0, holo.color);
8311:         GlStateManager.enableDepth();
8312:         if (!shulkerHoloCull)
8313:         {
8314:             GlStateManager.enableCull();
8315:         }
8316:         GlStateManager.popMatrix();
8317:     }
8318: 
8319:     private void renderSignSearchMarkers(Minecraft mc)
8320:     {
8321:         if (mc == null || mc.fontRenderer == null || mc.world == null)
8322:         {
8323:             return;
8324:         }
8325:         if (signSearchQuery == null || signSearchMatches.isEmpty())
8326:         {
8327:             return;
8328:         }
8329:         int dim = mc.world.provider.getDimension();
8330:         if (dim != signSearchDim)
8331:         {
8332:             return;
8333:         }
8334:         for (BlockPos pos : signSearchMatches)
8335:         {
8336:             if (pos == null)
8337:             {
8338:                 continue;
8339:             }
8340:             if (mc.player.getDistanceSq(pos) > 256.0 * 256.0)
8341:             {
8342:                 continue;
8343:             }
8344:             double x = pos.getX() + 0.5;
8345:             double y = pos.getY() + 1.2;
8346:             double z = pos.getZ() + 0.5;
8347:             GlStateManager.pushMatrix();
8348:             GlStateManager.translate(x, y, z);
8349:             GlStateManager.rotate(180.0F - mc.getRenderManager().playerViewY, 0.0F, 1.0F, 0.0F);
8350:             GlStateManager.rotate(-mc.getRenderManager().playerViewX, 1.0F, 0.0F, 0.0F);
8351:             GlStateManager.scale(-0.02F, -0.02F, 0.02F);
8352:             GlStateManager.disableLighting();
8353:             GlStateManager.disableDepth();
8354:             GlStateManager.enableBlend();
8355:             String label = "SIGN";
8356:             int width = mc.fontRenderer.getStringWidth(label);
8357:             mc.fontRenderer.drawStringWithShadow(label, -width / 2, 0, 0x00FF00);
8358:             GlStateManager.enableDepth();
8359:             GlStateManager.popMatrix();
8360:         }
8361:     }
8362: 
8363:     private void renderChestHolo(Minecraft mc, TestChestHolo holo)
8364:     {
8365:         if (holo == null || holo.cache == null || holo.pos == null)
8366:         {
8367:             return;
8368:         }
8369:         if (!holo.useFbo)
8370:         {
8371:             float scale = holo.scale > 0 ? holo.scale : CHEST_HOLO_SCALE;
8372:             int textWidth = holo.textWidth > 0 ? holo.textWidth : CHEST_HOLO_TEXT_WIDTH;
8373:             renderChestPreviewFace(mc, holo.cache, holo.pos, 180.0F, 0.0F, scale, textWidth, true);
8374:             return;
8375:         }
8376:         renderChestPreviewFbo(mc, holo);
8377:     }
8378: 
8379:     private void renderChestPreviewFbo(Minecraft mc, TestChestHolo holo)
8380:     {
8381:         if (mc == null || mc.fontRenderer == null || holo.cache == null)
8382:         {
8383:             return;
8384:         }
8385:         int size = holo.texSize > 0 ? holo.texSize : CHEST_HOLO_TEX_SIZE;
8386:         if (holo.fbo == null || holo.fbo.framebufferTextureWidth != size)
8387:         {
8388:             if (holo.fbo != null)
8389:             {
8390:                 holo.fbo.deleteFramebuffer();
8391:             }
8392:             holo.fbo = new Framebuffer(size, size, true);
8393:             holo.lastHash = null;
8394:         }
8395:         String hash = buildItemHash(holo.cache.items);
8396:         if (holo.lastHash == null || !holo.lastHash.equals(hash))
8397:         {
8398:             int textWidth = holo.textWidth > 0 ? holo.textWidth : CHEST_HOLO_TEXT_WIDTH;
8399:             renderChestPreviewToFramebuffer(mc, holo.cache, holo.fbo, size, size, textWidth);
8400:             holo.lastHash = hash;
8401:         }
8402:         float scale = holo.scale > 0 ? holo.scale : CHEST_HOLO_SCALE;
8403:         renderFramebufferQuad(mc, holo.pos, holo.fbo, size, size, scale);
8404:     }
8405: 
8406:     private void renderChestPreviewToFramebuffer(Minecraft mc, ChestCache cache, Framebuffer fbo, int w, int h,
8407:         int textWidth)
8408:     {
8409:         fbo.bindFramebuffer(true);
8410:         GlStateManager.clearColor(0f, 0f, 0f, 0f);
8411:         GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
8412:         GlStateManager.disableDepth();
8413:         GlStateManager.disableLighting();
8414:         GlStateManager.enableBlend();
8415: 
8416:         GlStateManager.matrixMode(GL11.GL_PROJECTION);
8417:         GlStateManager.pushMatrix();
8418:         GlStateManager.loadIdentity();
8419:         GlStateManager.ortho(0.0D, w, h, 0.0D, 1000.0D, 3000.0D);
8420:         GlStateManager.matrixMode(GL11.GL_MODELVIEW);
8421:         GlStateManager.pushMatrix();
8422:         GlStateManager.loadIdentity();
8423:         GlStateManager.translate(0.0F, 0.0F, -2000.0F);
8424: 
8425:         int size = cache.items.size();
8426:         int rows = Math.max(1, (int) Math.ceil(size / 9.0));
8427:         rows = Math.min(rows, 6);
8428:         int cols = 9;
8429:         int pad = 4;
8430:         int slot = 18;
8431:         int guiWidth = cols * slot + pad * 2;
8432:         int guiHeight = rows * slot + pad * 2 + 12;
8433:         int left = (w - guiWidth) / 2;
8434:         int top = (h - guiHeight) / 2;
8435: 
8436:         Gui.drawRect(left, top, left + guiWidth, top + guiHeight, 0xCC000000);
8437:         Gui.drawRect(left, top, left + guiWidth, top + 12, 0xFF111111);
8438:         String label = (cache.label == null || cache.label.trim().isEmpty()) ? CHEST_HOLO_LABEL : cache.label;
8439:         mc.fontRenderer.drawStringWithShadow(label, left + 6, top + 2, chestHoloTextColor);
8440: 
8441:         int textMaxWidth = cols * slot;
8442:         renderTextColumnToFramebuffer(mc, cache.items, left + pad, top + 12, cols, slot, textMaxWidth, guiWidth, guiHeight);
8443: 
8444:         GlStateManager.matrixMode(GL11.GL_MODELVIEW);
8445:         GlStateManager.popMatrix();
8446:         GlStateManager.matrixMode(GL11.GL_PROJECTION);
8447:         GlStateManager.popMatrix();
8448:         GlStateManager.matrixMode(GL11.GL_MODELVIEW);
8449: 
8450:         fbo.unbindFramebuffer();
8451:         mc.getFramebuffer().bindFramebuffer(true);
8452:     }
8453: 
8454:     private void renderFramebufferQuad(Minecraft mc, BlockPos pos, Framebuffer fbo, int w, int h, float scale)
8455:     {
8456:         if (isPlayerSouthOf(pos))
8457:         {
8458:             renderFramebufferQuadFace(mc, pos, fbo, w, h, 0.0F, false, -0.51F, scale);
8459:         }
8460:         else
8461:         {
8462:             renderFramebufferQuadFace(mc, pos, fbo, w, h, 180.0F, false, 0.51F, -scale);
8463:         }
8464:     }
8465: 
8466:     private void renderFramebufferQuadFace(Minecraft mc, BlockPos pos, Framebuffer fbo, int w, int h, float yaw,
8467:         boolean flipU, float zOffset, float scale)
8468:     {
8469:         double x = pos.getX() + 0.5;
8470:         double y = getChestYOffset(pos);
8471:         double z = pos.getZ() + 0.5;
8472:         double forward = 0.51;
8473:         if (yaw == 0.0F)
8474:         {
8475:             z -= forward;
8476:         }
8477:         else
8478:         {
8479:             z += forward;
8480:             z -= 1.0;
8481:         }
8482: 
8483:         GlStateManager.pushMatrix();
8484:         GlStateManager.translate(x, y, z);
8485:         GlStateManager.rotate(yaw, 0.0F, 1.0F, 0.0F);
8486:         GlStateManager.translate(0.0F, 0.0F, zOffset);
8487:         float axisScale = Math.abs(scale);
8488:         GlStateManager.scale(scale, -axisScale, axisScale);
8489:         GlStateManager.disableLighting();
8490:         GlStateManager.enableDepth();
8491:         GlStateManager.depthMask(true);
8492:         GlStateManager.enableBlend();
8493:         GlStateManager.disableCull();
8494:         GlStateManager.enablePolygonOffset();
8495:         GlStateManager.doPolygonOffset(-1.0F, -10.0F);
8496: 
8497:         float halfW = w / 2.0f;
8498:         float halfH = h / 2.0f;
8499:         GlStateManager.bindTexture(fbo.framebufferTexture);
8500:         int fboFilter = chestHoloSmoothFont ? GL11.GL_LINEAR : GL11.GL_NEAREST;
8501:         GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, fboFilter);
8502:         GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, fboFilter);
8503:         Tessellator tess = Tessellator.getInstance();
8504:         BufferBuilder buffer = tess.getBuffer();
8505:         float u1 = flipU ? 1f : 0f;
8506:         float u2 = flipU ? 0f : 1f;
8507:         buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
8508:         buffer.pos(-halfW, -halfH, 0).tex(u1, 1).endVertex();
8509:         buffer.pos(halfW, -halfH, 0).tex(u2, 1).endVertex();
8510:         buffer.pos(halfW, halfH, 0).tex(u2, 0).endVertex();
8511:         buffer.pos(-halfW, halfH, 0).tex(u1, 0).endVertex();
8512:         tess.draw();
8513: 
8514:         GlStateManager.disablePolygonOffset();
8515:         GlStateManager.enableCull();
8516:         GlStateManager.enableLighting();
8517:         GlStateManager.disableBlend();
8518:         GlStateManager.popMatrix();
8519:     }
8520: 
8521:     private String buildItemHash(List<ItemStack> items)
8522:     {
8523:         if (items == null)
8524:         {
8525:             return "";
8526:         }
8527:         StringBuilder sb = new StringBuilder();
8528:         for (ItemStack stack : items)
8529:         {
8530:             if (stack == null || stack.isEmpty())
8531:             {
8532:                 sb.append("_");
8533:                 continue;
8534:             }
8535:             sb.append(stack.getItem().getRegistryName()).append("#");
8536:             sb.append(stack.getCount()).append(";");
8537:             if (stack.hasTagCompound())
8538:             {
8539:                 sb.append(stack.getTagCompound().toString());
8540:             }
8541:             sb.append("|");
8542:         }
8543:         return sb.toString();
8544:     }
8545: 
8546: 
8547:     private void renderTextColumn(Minecraft mc, List<ItemStack> items, int left, int top, int cols, int slot,
8548:         int maxWidth, int guiWidth, int guiHeight)
8549:     {
8550:         if (mc == null || mc.fontRenderer == null || items == null)
8551:         {
8552:             return;
8553:         }
8554:         ResourceLocation fontTex = getFontTextureLocation(mc.fontRenderer);
8555:         if (fontTex != null)
8556:         {
8557:             TextureManager tm = mc.getTextureManager();
8558:             tm.bindTexture(fontTex);
8559:             int filter = chestHoloSmoothFont ? GL11.GL_LINEAR : GL11.GL_NEAREST;
8560:             GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, filter);
8561:             GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, filter);
8562:         }
8563:         int maxLines = 6;
8564:         int fontHeight = mc.fontRenderer.FONT_HEIGHT;
8565:         int count = items.size();
8566:         int gridLeft = left;
8567:         int gridTop = top;
8568:         int gridRight = left + guiWidth - 1;
8569:         int gridBottom = top + guiHeight - 1;
8570:         List<LabelCandidate> candidates = new ArrayList<>();
8571:         for (int idx = 0; idx < count; idx++)
8572:         {
8573:             int row = idx / cols;
8574:             if (row >= maxLines)
8575:             {
8576:                 break;
8577:             }
8578:             ItemStack stack = items.get(idx);
8579:             if (stack == null || stack.isEmpty())
8580:             {
8581:                 continue;
8582:             }
8583:             if (stack.getItem() == net.minecraft.item.Item.getItemFromBlock(Blocks.STAINED_GLASS_PANE))
8584:             {
8585:                 continue;
8586:             }
8587:             String name = getPreviewName(stack);
8588:             if (name == null || name.isEmpty())
8589:             {
8590:                 continue;
8591:             }
8592:             String tag = getItemTagColored(stack);
8593:             String lineText = tag + " " + name + TextFormatting.RESET;
8594:             String clipped = mc.fontRenderer.trimStringToWidth(lineText, Math.max(maxWidth, 1024));
8595:             int textWidth = mc.fontRenderer.getStringWidth(clipped);
8596:             int col = idx % cols;
8597:             int rowY = idx / cols;
8598:             int baseX = left + col * slot + (slot - textWidth) / 2;
8599:             int baseY = top + rowY * slot + (slot - fontHeight) / 2;
8600:             candidates.add(new LabelCandidate(idx, clipped, textWidth, fontHeight, baseX, baseY));
8601:         }
8602: 
8603:         LayoutResult pass1 = layoutCandidates(candidates, gridLeft, gridTop, gridRight, gridBottom);
8604:         LayoutResult finalLayout = pass1;
8605:         if (!pass1.overflow.isEmpty())
8606:         {
8607:             List<Rect> legendReserved = new ArrayList<>();
8608:             for (Label label : pass1.overflow)
8609:             {
8610:                 int col = label.slot % cols;
8611:                 int row = label.slot / cols;
8612:                 int cx = left + col * slot + slot / 2;
8613:                 int cy = top + row * slot + slot / 2;
8614:                 legendReserved.add(new Rect(cx - 4, cy - 4, 8, 8));
8615:             }
8616:             finalLayout = layoutCandidates(candidates, gridLeft, gridTop, gridRight, gridBottom, legendReserved);
8617:         }
8618: 
8619:         for (PlacedLabel placed : finalLayout.placed)
8620:         {
8621:             mc.fontRenderer.drawStringWithShadow(placed.text, placed.x, placed.y, chestHoloTextColor);
8622:         }
8623:         if (!finalLayout.overflow.isEmpty())
8624:         {
8625:             renderOverflowLegend(mc, finalLayout.overflow, left, top, cols, slot, fontHeight, guiWidth);
8626:         }
8627:         if (fontTex != null)
8628:         {
8629:             GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
8630:             GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
8631:         }
8632:     }
8633: 
8634:     private String getItemTagColored(ItemStack stack)
8635:     {
8636:         if (stack == null || stack.isEmpty())
8637:         {
8638:             return TextFormatting.GRAY + "[-]";
8639:         }
8640:         if (stack.getItem() == Items.BOOK)
8641:         {
8642:             return TextFormatting.WHITE + "[T]";
8643:         }
8644:         if (stack.getItem() == Items.SLIME_BALL)
8645:         {
8646:             return TextFormatting.RED + "[N]";
8647:         }
8648:         if (stack.getItem() == Items.MAGMA_CREAM)
8649:         {
8650:             return TextFormatting.GOLD + "[V]";
8651:         }
8652:         if (stack.getItem() == Items.ITEM_FRAME)
8653:         {
8654:             return TextFormatting.GREEN + "[A]";
8655:         }
8656:         if (stack.getItem() == Items.PAPER)
8657:         {
8658:             return TextFormatting.WHITE + "[P]";
8659:         }
8660:         if (stack.getItem() == Items.GLASS_BOTTLE)
8661:         {
8662:             return TextFormatting.AQUA + "[B]";
8663:         }
8664:         if (stack.getItem() == Items.NETHER_STAR)
8665:         {
8666:             return TextFormatting.YELLOW + "[S]";
8667:         }
8668:         if (stack.getItem() == Items.SHULKER_SHELL)
8669:         {
8670:             return TextFormatting.LIGHT_PURPLE + "[K]";
8671:         }
8672:         if (stack.getItem() == Items.PRISMARINE_SHARD)
8673:         {
8674:             return TextFormatting.DARK_AQUA + "[R]";
8675:         }
8676:         return TextFormatting.GRAY + "[I]";
8677:     }
8678: 
8679:     private String getPreviewName(ItemStack stack)
8680:     {
8681:         if (stack == null || stack.isEmpty())
8682:         {
8683:             return "";
8684:         }
8685:         String tag = getItemTagColored(stack);
8686:         String genericTag = String.valueOf(TextFormatting.GRAY) + "[I]";
8687:         if (genericTag.equals(tag))
8688:         {
8689:             Minecraft mc = Minecraft.getMinecraft();
8690:             EntityPlayer player = mc == null ? null : mc.player;
8691:             try
8692:             {
8693:                 java.util.List<String> tooltip = stack.getTooltip(player, net.minecraft.client.util.ITooltipFlag.TooltipFlags.NORMAL);
8694:                 for (String line : tooltip)
8695:                 {
8696:                     if (line == null)
8697:                     {
8698:                         continue;
8699:                     }
8700:                     String stripped = TextFormatting.getTextWithoutFormattingCodes(line);
8701:                     if (stripped != null && stripped.indexOf(0x25cf) >= 0)
8702:                     {
8703:                         String cleaned = line.replace(String.valueOf((char)0x25cf), "");
8704:                         String cleanedStripped = TextFormatting.getTextWithoutFormattingCodes(cleaned);
8705:                         if (cleanedStripped != null)
8706:                         {
8707:                             cleanedStripped = cleanedStripped.trim();
8708:                         }
8709:                         if (cleanedStripped != null && !cleanedStripped.isEmpty())
8710:                         {
8711:                             return cleaned.trim();
8712:                         }
8713:                     }
8714:                 }
8715:             }
8716:             catch (Exception e)
8717:             {
8718:                 // ignore tooltip failures
8719:             }
8720:         }
8721:         return stack.getDisplayName();
8722:     }
8723: 
8724:     private void renderTextColumnToFramebuffer(Minecraft mc, List<ItemStack> items, int left, int top, int cols,
8725:         int slot, int maxWidth, int guiWidth, int guiHeight)
8726:     {
8727:         renderTextColumn(mc, items, left, top, cols, slot, maxWidth, guiWidth, guiHeight);
8728:     }
8729: 
8730:     private Rect placeLabel(int x, int y, int w, int h, int minX, int minY, int maxX, int maxY, List<Rect> placed)
8731:     {
8732:         int[] steps = new int[]{0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8};
8733:         for (int dy : steps)
8734:         {
8735:             for (int dx : steps)
8736:             {
8737:                 int px = x + dx * 6;
8738:                 int py = y + dy * 6;
8739:                 Rect candidate = new Rect(px, py, w, h);
8740:                 if (candidate.x < minX || candidate.y < minY || candidate.right() > maxX || candidate.bottom() > maxY)
8741:                 {
8742:                     continue;
8743:                 }
8744:                 boolean overlap = false;
8745:                 for (Rect rect : placed)
8746:                 {
8747:                     if (rect.intersects(candidate))
8748:                     {
8749:                         overlap = true;
8750:                         break;
8751:                     }
8752:                 }
8753:                 if (!overlap)
8754:                 {
8755:                     return candidate;
8756:                 }
8757:             }
8758:         }
8759:         return null;
8760:     }
8761: 
8762:     private LayoutResult layoutCandidates(List<LabelCandidate> candidates, int minX, int minY, int maxX, int maxY)
8763:     {
8764:         return layoutCandidates(candidates, minX, minY, maxX, maxY, new ArrayList<>());
8765:     }
8766: 
8767:     private LayoutResult layoutCandidates(List<LabelCandidate> candidates, int minX, int minY, int maxX, int maxY,
8768:         List<Rect> reserved)
8769:     {
8770:         List<PlacedLabel> placed = new ArrayList<>();
8771:         List<Rect> rects = new ArrayList<>(reserved);
8772:         List<Label> overflow = new ArrayList<>();
8773:         for (LabelCandidate candidate : candidates)
8774:         {
8775:             int minAllowedX = minX;
8776:             int maxAllowedX = maxX - candidate.w;
8777:             if (maxAllowedX < minAllowedX)
8778:             {
8779:                 overflow.add(new Label(candidate.slot, candidate.text));
8780:                 continue;
8781:             }
8782:             int baseX = candidate.x;
8783:             if (baseX < minAllowedX)
8784:             {
8785:                 baseX = minAllowedX;
8786:             }
8787:             else if (baseX > maxAllowedX)
8788:             {
8789:                 baseX = maxAllowedX;
8790:             }
8791:             Rect placedRect = placeLabel(baseX, candidate.y, candidate.w, candidate.h, minX, minY, maxX, maxY, rects);
8792:             if (placedRect == null)
8793:             {
8794:                 overflow.add(new Label(candidate.slot, candidate.text));
8795:             }
8796:             else
8797:             {
8798:                 rects.add(placedRect);
8799:                 placed.add(new PlacedLabel(candidate.text, placedRect.x, placedRect.y));
8800:             }
8801:         }
8802:         return new LayoutResult(placed, overflow);
8803:     }
8804: 
8805:     private static class LabelCandidate
8806:     {
8807:         final int slot;
8808:         final String text;
8809:         final int w;
8810:         final int h;
8811:         final int x;
8812:         final int y;
8813: 
8814:         LabelCandidate(int slot, String text, int w, int h, int x, int y)
8815:         {
8816:             this.slot = slot;
8817:             this.text = text;
8818:             this.w = w;
8819:             this.h = h;
8820:             this.x = x;
8821:             this.y = y;
8822:         }
8823:     }
8824: 
8825:     private static class PlacedLabel
8826:     {
8827:         final String text;
8828:         final int x;
8829:         final int y;
8830: 
8831:         PlacedLabel(String text, int x, int y)
8832:         {
8833:             this.text = text;
8834:             this.x = x;
8835:             this.y = y;
8836:         }
8837:     }
8838: 
8839:     private static class LayoutResult
8840:     {
8841:         final List<PlacedLabel> placed;
8842:         final List<Label> overflow;
8843: 
8844:         LayoutResult(List<PlacedLabel> placed, List<Label> overflow)
8845:         {
8846:             this.placed = placed;
8847:             this.overflow = overflow;
8848:         }
8849:     }
8850: 
8851:     private void renderOverflowLegend(Minecraft mc, List<Label> overflow, int left, int top, int cols, int slot,
8852:         int fontHeight, int guiWidth)
8853:     {
8854:         int legendHeight = overflow.size() * (fontHeight + 2) + 4;
8855:         int legendY = top - legendHeight;
8856:         Gui.drawRect(left, legendY, left + guiWidth, legendY + legendHeight, 0xCC000000);
8857:         Gui.drawRect(left, legendY, left + guiWidth, legendY + 1, 0xFF111111);
8858:         int index = 1;
8859:         for (Label label : overflow)
8860:         {
8861:             int row = label.slot / cols;
8862:             int col = label.slot % cols;
8863:             int cx = left + col * slot + slot / 2;
8864:             int cy = top + row * slot + slot / 2;
8865:             String mark = String.valueOf(index);
8866:             int mw = mc.fontRenderer.getStringWidth(mark);
8867:             mc.fontRenderer.drawStringWithShadow(mark, cx - mw / 2, cy - fontHeight / 2, chestHoloTextColor);
8868: 
8869:             String legend = index + ": " + label.text;
8870:             mc.fontRenderer.drawStringWithShadow(legend, left, legendY + (index - 1) * (fontHeight + 2),
8871:                 chestHoloTextColor);
8872:             index++;
8873:         }
8874:     }
8875: 
8876:     private static class Rect
8877:     {
8878:         final int x;
8879:         final int y;
8880:         final int w;
8881:         final int h;
8882: 
8883:         Rect(int x, int y, int w, int h)
8884:         {
8885:             this.x = x;
8886:             this.y = y;
8887:             this.w = w;
8888:             this.h = h;
8889:         }
8890: 
8891:         int right()
8892:         {
8893:             return x + w;
8894:         }
8895: 
8896:         int bottom()
8897:         {
8898:             return y + h;
8899:         }
8900: 
8901:         boolean intersects(Rect other)
8902:         {
8903:             return x < other.right() && right() > other.x && y < other.bottom() && bottom() > other.y;
8904:         }
8905:     }
8906: 
8907:     private static class Label
8908:     {
8909:         final int slot;
8910:         final String text;
8911: 
8912:         Label(int slot, String text)
8913:         {
8914:             this.slot = slot;
8915:             this.text = text;
8916:         }
8917:     }
8918: 
8919:     private BlockPos getTargetedBlockPos()
8920:     {
8921:         Minecraft mc = Minecraft.getMinecraft();
8922:         if (mc == null || mc.objectMouseOver == null)
8923:         {
8924:             return null;
8925:         }
8926:         if (mc.objectMouseOver.getBlockPos() == null)
8927:         {
8928:             return null;
8929:         }
8930:         return mc.objectMouseOver.getBlockPos();
8931:     }
8932: 
8933:     private boolean isPlayerSouthOf(BlockPos pos)
8934:     {
8935:         Minecraft mc = Minecraft.getMinecraft();
8936:         if (mc == null || mc.player == null || mc.world == null || pos == null)
8937:         {
8938:             return true;
8939:         }
8940:         String key = chestKey(mc.world.provider.getDimension(), pos);
8941:         double dz = mc.player.posZ - pos.getZ();
8942:         if (dz >= 1.25)
8943:         {
8944:             chestFaceSouth.put(key, true);
8945:             return true;
8946:         }
8947:         if (dz <= -0.25)
8948:         {
8949:             chestFaceSouth.put(key, false);
8950:             return false;
8951:         }
8952:         Boolean cached = chestFaceSouth.get(key);
8953:         return cached != null ? cached : dz >= 0;
8954:     }
8955: 
8956:     private double getChestYOffset(BlockPos pos)
8957:     {
8958:         if (pos == null)
8959:         {
8960:             return 1.25;
8961:         }
8962:         String key = pos.getX() + ":" + pos.getY() + ":" + pos.getZ();
8963:         Double val = chestYOffset.get(key);
8964:         if (val != null)
8965:         {
8966:             return val;
8967:         }
8968:         double base = 1.25;
8969:         double extra = ((pos.getX() + pos.getZ()) & 1) == 0 ? 0.0 : 1.25;
8970:         double y = pos.getY() + base + extra;
8971:         chestYOffset.put(key, y);
8972:         return y;
8973:     }
8974: 
8975:     private ResourceLocation getFontTextureLocation(net.minecraft.client.gui.FontRenderer fontRenderer)
8976:     {
8977:         if (fontRenderer == null)
8978:         {
8979:             return null;
8980:         }
8981:         try
8982:         {
8983:             if (fontTextureField == null)
8984:             {
8985:                 try
8986:                 {
8987:                     fontTextureField = net.minecraft.client.gui.FontRenderer.class.getDeclaredField("locationFontTexture");
8988:                 }
8989:                 catch (NoSuchFieldException e)
8990:                 {
8991:                     fontTextureField = net.minecraft.client.gui.FontRenderer.class.getDeclaredField("field_78288_b");
8992:                 }
8993:                 fontTextureField.setAccessible(true);
8994:             }
8995:             Object value = fontTextureField.get(fontRenderer);
8996:             return value instanceof ResourceLocation ? (ResourceLocation) value : null;
8997:         }
8998:         catch (Exception e)
8999:         {
9000:         }
9001:         return null;
9002:     }
9003: 
9004:     private String getScoreboardLine(int lineNumber)
9005:     {
9006:         Minecraft mc = Minecraft.getMinecraft();
9007:         if (mc == null || mc.world == null)
9008:         {
9009:             return null;
9010:         }
9011:         Scoreboard sb = mc.world.getScoreboard();
9012:         if (sb == null)
9013:         {
9014:             return null;
9015:         }
9016:         ScoreObjective obj = sb.getObjectiveInDisplaySlot(1);
9017:         if (obj == null)
9018:         {
9019:             return null;
9020:         }
9021:         Collection<Score> scores = sb.getSortedScores(obj);
9022:         List<Score> list = new ArrayList<>();
9023:         for (Score score : scores)
9024:         {
9025:             String name = score.getPlayerName();
9026:             if (name == null || name.startsWith("#"))
9027:             {
9028:                 continue;
9029:             }
9030:             list.add(score);
9031:         }
9032:         int size = list.size();
9033:         if (size > 15)
9034:         {
9035:             list = list.subList(size - 15, size);
9036:         }
9037:         int idx = list.size() - lineNumber;
9038:         if (idx < 0 || idx >= list.size())
9039:         {
9040:             return null;
9041:         }
9042:         Score score = list.get(idx);
9043:         ScorePlayerTeam team = sb.getPlayersTeam(score.getPlayerName());
9044:         String line = ScorePlayerTeam.formatPlayerName(team, score.getPlayerName());
9045:         if (line == null)
9046:         {
9047:             return null;
9048:         }
9049:         return TextFormatting.getTextWithoutFormattingCodes(line);
9050:     }
9051: 
9052:     private String getScoreboardLineByScore(int scoreValue)
9053:     {
9054:         Minecraft mc = Minecraft.getMinecraft();
9055:         if (mc == null || mc.world == null)
9056:         {
9057:             return null;
9058:         }
9059:         Scoreboard sb = mc.world.getScoreboard();
9060:         if (sb == null)
9061:         {
9062:             return null;
9063:         }
9064:         ScoreObjective obj = sb.getObjectiveInDisplaySlot(1);
9065:         if (obj == null)
9066:         {
9067:             return null;
9068:         }
9069:         Collection<Score> scores = sb.getSortedScores(obj);
9070:         List<Score> list = new ArrayList<>();
9071:         for (Score score : scores)
9072:         {
9073:             String name = score.getPlayerName();
9074:             if (name == null || name.startsWith("#"))
9075:             {
9076:                 continue;
9077:             }
9078:             list.add(score);
9079:         }
9080:         int size = list.size();
9081:         if (size > 15)
9082:         {
9083:             list = list.subList(size - 15, size);
9084:         }
9085:         for (Score score : list)
9086:         {
9087:             if (score.getScorePoints() != scoreValue)
9088:             {
9089:                 continue;
9090:             }
9091:             ScorePlayerTeam team = sb.getPlayersTeam(score.getPlayerName());
9092:             String line = ScorePlayerTeam.formatPlayerName(team, score.getPlayerName());
9093:             if (line == null)
9094:             {
9095:                 return null;
9096:             }
9097:             return TextFormatting.getTextWithoutFormattingCodes(line);
9098:         }
9099:         return null;
9100:     }
9101: 
9102:     private String getScoreboardIdLine()
9103:     {
9104:         String line = getScoreboardLineByScore(12);
9105:         if (line == null)
9106:         {
9107:             return null;
9108:         }
9109:         return line.contains("ID") ? line : null;
9110:     }
9111: 
9112:     private String getScoreboardTitle()
9113:     {
9114:         Minecraft mc = Minecraft.getMinecraft();
9115:         if (mc == null || mc.world == null)
9116:         {
9117:             return null;
9118:         }
9119:         Scoreboard sb = mc.world.getScoreboard();
9120:         if (sb == null)
9121:         {
9122:             return null;
9123:         }
9124:         ScoreObjective obj = sb.getObjectiveInDisplaySlot(1);
9125:         if (obj == null)
9126:         {
9127:             return null;
9128:         }
9129:         String title = obj.getDisplayName();
9130:         if (title == null)
9131:         {
9132:             return null;
9133:         }
9134:         return TextFormatting.getTextWithoutFormattingCodes(title);
9135:     }
9136: 
9137:     private static void loadConfig(FMLPreInitializationEvent event)
9138:     {
9139:         config = new Configuration(event.getSuggestedConfigurationFile());
9140:         syncConfig(true);
9141:     }
9142: 
9143:     private void initEntriesFile(FMLPreInitializationEvent event)
9144:     {
9145:         if (event == null)
9146:         {
9147:             return;
9148:         }
9149:         File cfg = event.getSuggestedConfigurationFile();
9150:         if (cfg == null)
9151:         {
9152:             return;
9153:         }
9154:         File dir = cfg.getParentFile();
9155:         if (dir == null)
9156:         {
9157:             return;
9158:         }
9159:         entriesFile = new File(dir, "mcpythonapi_entries.json");
9160:         loadEntries();
9161:         noteFile = new File(dir, "mcpythonapi_note.txt");
9162:         loadNote();
9163:         chestCacheFile = new File(dir, "mcpythonapi_chest_cache.dat");
9164:         loadChestIdCaches();
9165:         menuCacheFile = new File(dir, "mcpythonapi_menu_cache.dat");
9166:         loadMenuCache();
9167:         shulkerHoloFile = new File(dir, "mcpythonapi_shulker_holos.dat");
9168:         loadShulkerHolos();
9169:         codeBlueGlassFile = new File(dir, "mcpythonapi_code_glass.dat");
9170:         loadCodeBlueGlass();
9171:     }
9172: 
9173:     private void initIoExecutor()
9174:     {
9175:         if (ioExecutor != null)
9176:         {
9177:             return;
9178:         }
9179:         ioExecutor = Executors.newSingleThreadExecutor(new ThreadFactory()
9180:         {
9181:             @Override
9182:             public Thread newThread(Runnable r)
9183:             {
9184:                 Thread t = new Thread(r, "MC-Python-IO");
9185:                 t.setDaemon(true);
9186:                 return t;
9187:             }
9188:         });
9189:     }
9190: 
9191:     private static void syncConfig(boolean loadFromDisk)
9192:     {
9193:         if (config == null)
9194:         {
9195:             return;
9196:         }
9197:         try
9198:         {
9199:             if (loadFromDisk)
9200:             {
9201:                 config.load();
9202:             }
9203:             enableSecondHotbar = config.getBoolean("enableSecondHotbar", "hotbar", true,
9204:                 "Enable the second hotbar swap feature.");
9205:             String holoColor = config.getString("holoTextColor", "hologram", "FFFFFF",
9206:                 "Hex RGB text color for chest holograms (e.g. FFFFFF).");
9207:             chestHoloTextColor = parseHexColor(holoColor, 0xFFFFFF);
9208:         }
9209:         finally
9210:         {
9211:             if (config.hasChanged())
9212:             {
9213:                 config.save();
9214:             }
9215:         }
9216:     }
9217: 
9218:     private static class CachedMenu
9219:     {
9220:         final String title;
9221:         final int size;
9222:         final List<ItemStack> items;
9223:         final String hash;
9224: 
9225:         CachedMenu(String title, int size, List<ItemStack> items, String hash)
9226:         {
9227:             this.title = title == null ? "" : title;
9228:             this.size = size;
9229:             this.items = items;
9230:             this.hash = hash == null ? "" : hash;
9231:         }
9232:     }
9233: 
9234:     private static class ClickAction
9235:     {
9236:         final int slotNumber;
9237:         final int button;
9238:         final ClickType type;
9239: 
9240:         ClickAction(int slotNumber, int button, ClickType type)
9241:         {
9242:             this.slotNumber = slotNumber;
9243:             this.button = button;
9244:             this.type = type;
9245:         }
9246:     }
9247: 
9248:     private static class InputEntry
9249:     {
9250:         final int mode;
9251:         final String text;
9252: 
9253:         InputEntry(int mode, String text)
9254:         {
9255:             this.mode = mode;
9256:             this.text = text == null ? "" : text;
9257:         }
9258:     }
9259: 
9260:     private static class ExportResult
9261:     {
9262:         final String text;
9263:         final int itemCount;
9264: 
9265:         ExportResult(String text, int itemCount)
9266:         {
9267:             this.text = text == null ? "" : text;
9268:             this.itemCount = itemCount;
9269:         }
9270:     }
9271: 
9272:     private static class CopiedSlot
9273:     {
9274:         final int slotNumber;
9275:         final ItemStack stack;
9276: 
9277:         CopiedSlot(int slotNumber, ItemStack stack)
9278:         {
9279:             this.slotNumber = slotNumber;
9280:             this.stack = stack;
9281:         }
9282:     }
9283: 
9284:     private static class ShulkerHolo
9285:     {
9286:         final int dim;
9287:         final BlockPos pos;
9288:         final String text;
9289:         final int color;
9290: 
9291:         ShulkerHolo(int dim, BlockPos pos, String text, int color)
9292:         {
9293:             this.dim = dim;
9294:             this.pos = pos;
9295:             this.text = text == null ? "" : text;
9296:             this.color = color;
9297:         }
9298:     }
9299: 
9300:     private static class ChestPreviewFbo
9301:     {
9302:         Framebuffer fbo;
9303:         String lastHash;
9304:         int lastTexSize;
9305:         int lastTextWidth;
9306:     }
9307: 
9308:     private static class ChestCache
9309:     {
9310:         final int dim;
9311:         final BlockPos pos;
9312:         final List<ItemStack> items;
9313:         final long updatedMs;
9314:         final String label;
9315: 
9316:         ChestCache(int dim, BlockPos pos, List<ItemStack> items, long updatedMs, String label)
9317:         {
9318:             this.dim = dim;
9319:             this.pos = pos;
9320:             this.items = items;
9321:             this.updatedMs = updatedMs;
9322:             this.label = label == null ? "" : label;
9323:         }
9324:     }
9325: 
9326:     private static class TestChestHolo
9327:     {
9328:         final BlockPos pos;
9329:         final ChestCache cache;
9330:         final boolean useFbo;
9331:         final float scale;
9332:         final int textWidth;
9333:         final int texSize;
9334:         Framebuffer fbo;
9335:         String lastHash;
9336: 
9337:         TestChestHolo(BlockPos pos, ChestCache cache, boolean useFbo, float scale, int textWidth, int texSize)
9338:         {
9339:             this.pos = pos;
9340:             this.cache = cache;
9341:             this.useFbo = useFbo;
9342:             this.scale = scale;
9343:             this.textWidth = textWidth;
9344:             this.texSize = texSize;
9345:         }
9346:     }
9347: 
9348:     private static class RegistryEntry
9349:     {
9350:         final String name;
9351:         final int port;
9352:         final String mode;
9353:         long lastSeenMs;
9354: 
9355:         RegistryEntry(String name, int port, String mode)
9356:         {
9357:             this.name = name;
9358:             this.port = port;
9359:             this.mode = mode == null ? "" : mode;
9360:         }
9361:     }
9362: 
9363:     private static class CommandResult
9364:     {
9365:         final boolean executed;
9366:         final String mode;
9367: 
9368:         CommandResult(boolean executed, String mode)
9369:         {
9370:             this.executed = executed;
9371:             this.mode = mode;
9372:         }
9373:     }
9374: }    
